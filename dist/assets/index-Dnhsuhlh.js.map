{"version":3,"file":"index-Dnhsuhlh.js","sources":["../../src/types.ts","../../node_modules/lz-string/libs/lz-string.js","../../src/utils/urlState.ts","../../src/utils/fingerJoints.ts","../../src/utils/fingerPoints.ts","../../src/utils/genderRules.ts","../../src/utils/panelGenerator.ts","../../src/store/useBoxStore.ts","../../src/components/UI/Panel.tsx","../../src/components/BoxTree.tsx","../../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../../node_modules/three/examples/jsm/lines/LineMaterial.js","../../node_modules/three/examples/jsm/lines/LineSegments2.js","../../src/components/VoidMesh.tsx","../../src/components/SubAssembly3D.tsx","../../src/components/PanelPathRenderer.tsx","../../src/components/Box3D.tsx","../../src/components/ViewportToolbar.tsx","../../src/components/EditorToolbar.tsx","../../src/components/Viewport3D.tsx","../../src/utils/editableAreas.ts","../../src/utils/cornerFinish.ts","../../src/components/SketchView2D.tsx","../../src/components/UI/NumberInput.tsx","../../src/components/SubdivisionControls.tsx","../../src/components/PanelProperties.tsx","../../src/components/AssemblyProperties.tsx","../../src/components/DimensionForm.tsx","../../src/components/UI/Modal.tsx","../../src/utils/svgExport.ts","../../src/components/ExportModal.tsx","../../src/utils/projectStorage.ts","../../src/components/ProjectBrowserModal.tsx","../../src/components/SaveProjectModal.tsx","../../src/App.tsx","../../src/main.tsx"],"sourcesContent":["// Assembly axis determines which pair of faces acts as \"lids\"\nexport type AssemblyAxis = 'x' | 'y' | 'z';\n\n// Tab direction for each lid\nexport type LidTabDirection = 'tabs-out' | 'tabs-in';\n\n// Configuration for a single lid face\nexport interface LidConfig {\n  enabled: boolean;              // Whether face is solid (redundant with Face.solid but explicit)\n  tabDirection: LidTabDirection;\n  inset: number;                 // Inset from outer dimension (mm), 0 = flush with outer\n}\n\n// Feet configuration for assembly\nexport interface FeetConfig {\n  enabled: boolean;\n  height: number;       // How far feet extend downward (mm)\n  width: number;        // Width of each foot (mm)\n  inset: number;        // Distance from panel edge to outer edge of foot (mm)\n}\n\n// Default feet config\nexport const defaultFeetConfig: FeetConfig = {\n  enabled: false,\n  height: 15,\n  width: 20,\n  inset: 0,\n};\n\n// Assembly configuration for a box or sub-assembly\nexport interface AssemblyConfig {\n  assemblyAxis: AssemblyAxis;\n  lids: {\n    positive: LidConfig;  // top (Y), right (X), or front (Z)\n    negative: LidConfig;  // bottom (Y), left (X), or back (Z)\n  };\n  feet?: FeetConfig;    // Optional feet configuration\n}\n\n// Helper: Get the role of a face (wall or lid) based on assembly axis\nexport const getFaceRole = (faceId: FaceId, axis: AssemblyAxis): 'wall' | 'lid' => {\n  switch (axis) {\n    case 'y':\n      return (faceId === 'top' || faceId === 'bottom') ? 'lid' : 'wall';\n    case 'x':\n      return (faceId === 'left' || faceId === 'right') ? 'lid' : 'wall';\n    case 'z':\n      return (faceId === 'front' || faceId === 'back') ? 'lid' : 'wall';\n  }\n};\n\n// Helper: Get which side of the assembly axis a lid face is on\nexport const getLidSide = (faceId: FaceId, axis: AssemblyAxis): 'positive' | 'negative' | null => {\n  const lidMap: Record<AssemblyAxis, { positive: FaceId; negative: FaceId }> = {\n    y: { positive: 'top', negative: 'bottom' },\n    x: { positive: 'right', negative: 'left' },\n    z: { positive: 'front', negative: 'back' },\n  };\n  const mapping = lidMap[axis];\n  if (faceId === mapping.positive) return 'positive';\n  if (faceId === mapping.negative) return 'negative';\n  return null;\n};\n\n// Helper: Get the FaceId for a lid given axis and side\nexport const getLidFaceId = (axis: AssemblyAxis, side: 'positive' | 'negative'): FaceId => {\n  const lidMap: Record<AssemblyAxis, { positive: FaceId; negative: FaceId }> = {\n    y: { positive: 'top', negative: 'bottom' },\n    x: { positive: 'right', negative: 'left' },\n    z: { positive: 'front', negative: 'back' },\n  };\n  return lidMap[axis][side];\n};\n\n// Helper: Get wall priority for wall-to-wall tab direction\n// Lower priority face has tabs OUT, higher priority face has slots IN\nexport const getWallPriority = (faceId: FaceId): number => {\n  const priorities: Record<FaceId, number> = {\n    front: 1,\n    back: 2,\n    left: 3,\n    right: 4,\n    top: 5,\n    bottom: 6,\n  };\n  return priorities[faceId];\n};\n\n// Default assembly config - Y axis with tabs-out on both lids\nexport const defaultAssemblyConfig: AssemblyConfig = {\n  assemblyAxis: 'y',\n  lids: {\n    positive: { enabled: true, tabDirection: 'tabs-out', inset: 0 },\n    negative: { enabled: true, tabDirection: 'tabs-out', inset: 0 },\n  },\n};\n\nexport interface BoxConfig {\n  width: number;\n  height: number;\n  depth: number;\n  materialThickness: number;\n  fingerWidth: number;\n  fingerGap: number;  // Gap at corners (multiplier of fingerWidth, e.g., 1.5 = 1.5x fingerWidth)\n  assembly: AssemblyConfig;\n}\n\nexport type FaceId = 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom';\n\nexport type SelectionMode = 'void' | 'panel' | 'assembly' | null;\n\n// View mode for switching between 3D and 2D editing\nexport type ViewMode = '3d' | '2d';\n\nexport interface Face {\n  id: FaceId;\n  solid: boolean;\n}\n\nexport interface Bounds {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n  h: number;\n  d: number;\n}\n\n// Per-face offsets for sub-assembly positioning\n// Positive = outset (extend beyond clearance), Negative = inset (retract from clearance)\n// Only meaningful for faces that border open parent faces\nexport interface FaceOffsets {\n  front: number;\n  back: number;\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n}\n\nexport const defaultFaceOffsets: FaceOffsets = {\n  front: 0, back: 0, left: 0, right: 0, top: 0, bottom: 0,\n};\n\n// Options for creating a sub-assembly\nexport interface CreateSubAssemblyOptions {\n  clearance?: number;         // Base clearance from void walls (mm)\n  assemblyAxis?: AssemblyAxis; // Axis for lids\n  faceOffsets?: FaceOffsets;  // Per-face offset adjustments\n}\n\n// A sub-assembly is a nested box that fits inside a void\n// It has 6 faces just like the main box, each can be open or closed\nexport interface SubAssembly {\n  id: string;\n  clearance: number;  // Base gap between sub-assembly and parent void (mm)\n  faceOffsets: FaceOffsets;  // Per-face offset adjustments (mm)\n  faces: Face[];      // Which faces are solid/open (same as main box)\n  rootVoid: Void;     // Sub-assembly's internal void structure\n  materialThickness: number;\n  assembly: AssemblyConfig;  // Assembly configuration for this sub-assembly\n}\n\n// Position mode for subdivisions\nexport type SplitPositionMode = 'absolute' | 'percentage';\n\n// Hierarchical void structure - subdivisions create child voids\nexport interface Void {\n  id: string;\n  bounds: Bounds;\n  children: Void[];  // Child voids created by subdivision\n  subAssembly?: SubAssembly;  // Optional nested sub-assembly (e.g., drawer)\n  // If this void was created by splitting a parent:\n  splitAxis?: 'x' | 'y' | 'z';\n  splitPosition?: number;  // Absolute position in box coordinates where the split occurred\n  splitPositionMode?: SplitPositionMode;  // 'absolute' = fixed position, 'percentage' = scales with dimensions\n  splitPercentage?: number;  // 0.0 to 1.0 - position as percentage of parent void dimension (along split axis)\n  // If this void is a lid inset cap (space between inset lid and outer edge):\n  lidInsetSide?: 'positive' | 'negative';\n  // If this is the main interior void (when lid insets exist):\n  isMainInterior?: boolean;\n}\n\n// Legacy flat subdivision interface (kept for panel generation)\nexport interface Subdivision {\n  id: string;\n  axis: 'x' | 'y' | 'z';\n  position: number;  // Absolute position in mm\n  bounds: Bounds;    // The bounds of the parent void at time of split\n  positionMode?: SplitPositionMode;  // Position mode (absolute or percentage)\n  percentage?: number;  // Position as percentage of parent void (0.0 to 1.0)\n}\n\n// Preview state for showing potential subdivisions before confirming\nexport interface SubdivisionPreview {\n  voidId: string;\n  axis: 'x' | 'y' | 'z';\n  count: number;  // Number of divisions (1 = single split, 2+ = distribute)\n  positions: number[];  // Absolute positions of preview planes\n}\n\n// Preview state for showing potential sub-assembly before creating\nexport interface SubAssemblyPreview {\n  voidId: string;\n  bounds: Bounds;  // The calculated bounds of the sub-assembly\n  clearance: number;\n  assemblyAxis: AssemblyAxis;\n  faceOffsets: FaceOffsets;\n}\n\nexport interface BoxState {\n  config: BoxConfig;\n  faces: Face[];\n  rootVoid: Void;  // Single root void that contains the hierarchy\n  selectionMode: SelectionMode;\n  // Multi-select enabled - use Sets instead of single IDs\n  selectedVoidIds: Set<string>;\n  selectedSubAssemblyIds: Set<string>;\n  selectedPanelIds: Set<string>;  // FaceId or subdivision panel ids\n  selectedAssemblyId: string | null;  // 'main' for main box (single select for assembly)\n  // Hover state - synchronized between tree and 3D view\n  hoveredVoidId: string | null;\n  hoveredPanelId: string | null;\n  hoveredAssemblyId: string | null;  // 'main' or sub-assembly id\n  subdivisionPreview: SubdivisionPreview | null;\n  subAssemblyPreview: SubAssemblyPreview | null;\n  // Visibility controls for voids\n  hiddenVoidIds: Set<string>;  // Set of void IDs that are hidden\n  isolatedVoidId: string | null;  // If set, only show this void and its descendants\n  isolateHiddenVoidIds: Set<string>;  // Void IDs hidden specifically by the isolate action (for restore)\n  // Visibility controls for sub-assemblies\n  hiddenSubAssemblyIds: Set<string>;  // Set of sub-assembly IDs that are hidden\n  isolatedSubAssemblyId: string | null;  // If set, only show this sub-assembly\n  isolateHiddenSubAssemblyIds: Set<string>;  // Sub-assembly IDs hidden by isolate action\n  // Visibility controls for face panels (includes dividers)\n  hiddenFaceIds: Set<string>;  // Set of face panel IDs that are hidden (e.g., 'face-front', 'subasm-xxx-face-top', 'divider-void-1-split')\n  isolatedPanelId: string | null;  // If set, only show this panel\n  isolateHiddenFaceIds: Set<string>;  // Face IDs hidden by isolate action\n  // Generated panel paths - the source of truth for geometry\n  panelCollection: PanelCollection | null;\n  // Flag indicating panels need regeneration (config changed since last generate)\n  panelsDirty: boolean;\n  // Debug visualization toggles\n  showDebugAnchors: boolean;\n  // 2D Sketch View state\n  viewMode: ViewMode;\n  sketchPanelId: string | null;  // Panel being edited in 2D view\n}\n\nexport interface BoxActions {\n  setConfig: (config: Partial<BoxConfig>) => void;\n  toggleFace: (faceId: FaceId) => void;\n  setSelectionMode: (mode: SelectionMode) => void;\n  // Selection actions - additive parameter enables multi-select (e.g., shift-click)\n  selectVoid: (voidId: string | null, additive?: boolean) => void;\n  selectPanel: (panelId: string | null, additive?: boolean) => void;\n  selectAssembly: (assemblyId: string | null) => void;  // 'main' or sub-assembly id\n  selectSubAssembly: (subAssemblyId: string | null, additive?: boolean) => void;\n  clearSelection: () => void;  // Clear all selections\n  // Hover actions - synchronized between tree and 3D view\n  setHoveredVoid: (voidId: string | null) => void;\n  setHoveredPanel: (panelId: string | null) => void;\n  setHoveredAssembly: (assemblyId: string | null) => void;\n  setSubdivisionPreview: (preview: SubdivisionPreview | null) => void;\n  setSubAssemblyPreview: (preview: SubAssemblyPreview | null) => void;\n  applySubdivision: () => void;  // Apply the current preview\n  removeVoid: (voidId: string) => void;\n  resetVoids: () => void;\n  // Assembly config actions for main box\n  setAssemblyAxis: (axis: AssemblyAxis) => void;\n  setLidTabDirection: (side: 'positive' | 'negative', direction: LidTabDirection) => void;\n  setLidInset: (side: 'positive' | 'negative', inset: number) => void;\n  setFeetConfig: (feetConfig: FeetConfig) => void;\n  // Sub-assembly actions\n  createSubAssembly: (voidId: string, options?: CreateSubAssemblyOptions) => void;\n  toggleSubAssemblyFace: (subAssemblyId: string, faceId: FaceId) => void;\n  setSubAssemblyClearance: (subAssemblyId: string, clearance: number) => void;\n  removeSubAssembly: (voidId: string) => void;\n  purgeVoid: (voidId: string) => void;  // Remove all children and sub-assemblies\n  // Assembly config actions for sub-assemblies\n  setSubAssemblyAxis: (subAssemblyId: string, axis: AssemblyAxis) => void;\n  setSubAssemblyLidTabDirection: (subAssemblyId: string, side: 'positive' | 'negative', direction: LidTabDirection) => void;\n  setSubAssemblyLidInset: (subAssemblyId: string, side: 'positive' | 'negative', inset: number) => void;\n  // Visibility actions for voids\n  toggleVoidVisibility: (voidId: string) => void;\n  setIsolatedVoid: (voidId: string | null) => void;\n  // Visibility actions for sub-assemblies\n  toggleSubAssemblyVisibility: (subAssemblyId: string) => void;\n  setIsolatedSubAssembly: (subAssemblyId: string | null) => void;\n  // Visibility actions for face panels (includes dividers)\n  toggleFaceVisibility: (faceId: string) => void;\n  setIsolatedPanel: (panelId: string | null) => void;\n  // Panel path actions\n  generatePanels: () => void;                    // Generate panel paths from current config\n  clearPanels: () => void;                       // Clear generated panels\n  updatePanelPath: (panelId: string, updates: Partial<PanelPath>) => void;\n  addPanelHole: (panelId: string, hole: PanelHole) => void;\n  removePanelHole: (panelId: string, holeId: string) => void;\n  addAugmentation: (augmentation: PanelAugmentation) => void;\n  removeAugmentation: (augmentationId: string) => void;\n  togglePanelVisibility: (panelId: string) => void;\n  setEdgeExtension: (\n    panelId: string,\n    edge: 'top' | 'bottom' | 'left' | 'right',\n    value: number\n  ) => void;\n  setDividerPosition: (\n    subdivisionId: string,\n    newPosition: number\n  ) => void;\n  setDividerPositionMode: (\n    subdivisionId: string,\n    mode: SplitPositionMode\n  ) => void;\n  // URL state management\n  loadFromUrl: () => boolean;  // Returns true if state was loaded\n  saveToUrl: () => void;\n  getShareableUrl: () => string;\n  // Debug visualization\n  toggleDebugAnchors: () => void;\n  // 2D Sketch View actions\n  setViewMode: (mode: ViewMode) => void;\n  enterSketchView: (panelId: string) => void;\n  exitSketchView: () => void;\n}\n\n// Subdivision panel - a physical divider piece to be cut\nexport interface SubdivisionPanel {\n  id: string;\n  axis: 'x' | 'y' | 'z';\n  position: number;      // Absolute position in mm\n  parentBounds: Bounds;  // Bounds of the void this subdivision is in\n  width: number;         // panel width in mm\n  height: number;        // panel height in mm\n  // Which outer faces this panel meets (for finger joints)\n  meetsTop: boolean;\n  meetsBottom: boolean;\n  meetsLeft: boolean;\n  meetsRight: boolean;\n  // Intersecting subdivisions (for interlocking slots)\n  intersections: SubdivisionIntersection[];\n}\n\nexport interface SubdivisionIntersection {\n  subdivisionId: string;\n  axis: 'x' | 'y' | 'z';\n  position: number;      // position along this panel's width in mm\n  fromTop: boolean;      // slot comes from top (true) or bottom (false)\n}\n\n// =============================================================================\n// Panel Path Model - Stored geometry that can be manipulated and exported\n// =============================================================================\n\n// A 2D point\nexport interface PathPoint {\n  x: number;\n  y: number;\n}\n\n// A closed path (contour or hole)\nexport interface Path {\n  points: PathPoint[];\n  closed: boolean;  // Should always be true for panel outlines/holes\n}\n\n// Types of holes that can be added to a panel\nexport type HoleType = 'slot' | 'circle' | 'rectangle' | 'custom';\n\n// A hole in a panel (slot, decorative cutout, etc.)\nexport interface PanelHole {\n  id: string;\n  type: HoleType;\n  path: Path;\n  // Source info - what created this hole\n  source?: {\n    type: 'divider-slot' | 'lid-slot' | 'extension-slot' | 'decorative' | 'functional';\n    sourceId?: string;  // ID of divider/lid that created this slot\n  };\n}\n\n// Types of panels\nexport type PanelType = 'face' | 'divider' | 'lid';\n\n// Source information for a panel\nexport interface PanelSource {\n  type: PanelType;\n  // For faces: the face ID\n  faceId?: FaceId;\n  // For dividers: the subdivision info\n  subdivisionId?: string;\n  axis?: 'x' | 'y' | 'z';\n  // For sub-assembly panels\n  subAssemblyId?: string;\n}\n\n// Edge extensions for panel edge editing (V1 - straight edges only)\nexport interface EdgeExtensions {\n  top: number;     // mm (positive = outward, negative = inward)\n  bottom: number;\n  left: number;\n  right: number;\n}\n\nexport const defaultEdgeExtensions: EdgeExtensions = {\n  top: 0, bottom: 0, left: 0, right: 0\n};\n\n// Corner finish types\nexport type CornerFinishType = 'none' | 'chamfer' | 'fillet';\n\nexport interface CornerFinish {\n  cornerId: string;\n  type: CornerFinishType;\n  radius: number;\n}\n\n// A panel with its 2D path geometry and 3D positioning\nexport interface PanelPath {\n  id: string;\n  source: PanelSource;\n\n  // 2D geometry (in mm, centered at origin)\n  outline: Path;              // Outer contour with finger joints\n  holes: PanelHole[];         // Slots, decorative cutouts, etc.\n\n  // Dimensions (for reference, derived from outline bounds)\n  width: number;              // X extent of outline\n  height: number;             // Y extent of outline\n  thickness: number;          // Material thickness (Z extent when extruded)\n\n  // 3D positioning (for rendering)\n  position: [number, number, number];\n  rotation: [number, number, number];\n\n  // Display properties\n  label?: string;\n  color?: string;\n  visible: boolean;\n\n  // Edge extensions (V1 - only for straight edges)\n  edgeExtensions: EdgeExtensions;\n\n  // Corner finishes (chamfers, fillets)\n  cornerFinishes?: CornerFinish[];\n}\n\n// Augmentation types that can be added to panels\nexport type AugmentationType = 'feet-notch' | 'handle-cutout' | 'vent-holes' | 'custom-hole';\n\n// An augmentation is a modification to a panel (hole, notch, etc.)\nexport interface PanelAugmentation {\n  id: string;\n  type: AugmentationType;\n  panelId: string;           // Which panel this augmentation belongs to\n  hole: PanelHole;           // The actual geometry\n  // Parameters for regeneration (optional, for parametric augmentations)\n  params?: Record<string, number | string | boolean>;\n}\n\n// Collection of all generated panels\nexport interface PanelCollection {\n  panels: PanelPath[];\n  augmentations: PanelAugmentation[];\n  // Generation metadata\n  generatedAt: number;       // Timestamp\n  sourceConfigHash?: string; // Hash of config used to generate (for dirty detection)\n}\n\n// Helper: Calculate bounding box of a path\nexport const getPathBounds = (path: Path): { minX: number; maxX: number; minY: number; maxY: number; width: number; height: number } => {\n  if (path.points.length === 0) {\n    return { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0 };\n  }\n\n  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;\n  for (const p of path.points) {\n    minX = Math.min(minX, p.x);\n    maxX = Math.max(maxX, p.x);\n    minY = Math.min(minY, p.y);\n    maxY = Math.max(maxY, p.y);\n  }\n\n  return { minX, maxX, minY, maxY, width: maxX - minX, height: maxY - minY };\n};\n\n// Helper: Create a rectangular path\nexport const createRectPath = (width: number, height: number, centerX = 0, centerY = 0): Path => {\n  const hw = width / 2;\n  const hh = height / 2;\n  return {\n    points: [\n      { x: centerX - hw, y: centerY + hh },  // top-left\n      { x: centerX + hw, y: centerY + hh },  // top-right\n      { x: centerX + hw, y: centerY - hh },  // bottom-right\n      { x: centerX - hw, y: centerY - hh },  // bottom-left\n    ],\n    closed: true,\n  };\n};\n\n// Helper: Create a circular path (approximated with segments)\nexport const createCirclePath = (radius: number, centerX = 0, centerY = 0, segments = 32): Path => {\n  const points: PathPoint[] = [];\n  for (let i = 0; i < segments; i++) {\n    const angle = (i / segments) * Math.PI * 2;\n    points.push({\n      x: centerX + Math.cos(angle) * radius,\n      y: centerY + Math.sin(angle) * radius,\n    });\n  }\n  return { points, closed: true };\n};\n\n// =============================================================================\n// Finger Joint System v2 - Assembly-level finger point generation\n// =============================================================================\n\n// Joint gender determines whether an edge has tabs (male) or slots (female)\nexport type JointGender = 'male' | 'female';\n\n// Finger points for one axis of an assembly\nexport interface AxisFingerPoints {\n  axis: 'x' | 'y' | 'z';\n  points: number[];           // Transition positions along axis (from negative end after MT inset)\n  innerOffset: number;        // Distance from MT-inset edge to first finger transition\n  fingerLength: number;       // Actual finger/hole length used (may differ from config due to remainder distribution)\n  maxJointLength: number;     // axis_length - 2*MT\n}\n\n// Assembly-level finger point data for all 3 axes\nexport interface AssemblyFingerData {\n  x: AxisFingerPoints;\n  y: AxisFingerPoints;\n  z: AxisFingerPoints;\n}\n\n// Configuration for finger point calculation\nexport interface FingerPointConfig {\n  materialThickness: number;\n  fingerLength: number;       // Target finger length\n  minDistance: number;        // Minimum gap from bounding box corner to first finger\n}\n\n// Helper: Get the axis dimension from box config\nexport const getAxisDimension = (axis: 'x' | 'y' | 'z', config: BoxConfig): number => {\n  switch (axis) {\n    case 'x': return config.width;\n    case 'y': return config.height;\n    case 'z': return config.depth;\n  }\n};\n\n// Helper: Get which axis an edge is parallel to based on face and edge position\nexport const getEdgeAxis = (\n  faceId: FaceId,\n  edgePosition: 'top' | 'bottom' | 'left' | 'right'\n): 'x' | 'y' | 'z' => {\n  // Edge axis mapping: which assembly axis each edge runs parallel to\n  // Front/back faces are in XY plane, left/right in YZ plane, top/bottom in XZ plane\n  // For top/bottom faces: in 2D layout, top/bottom edges run along X, left/right run along Z\n  const edgeAxes: Record<FaceId, Record<string, 'x' | 'y' | 'z'>> = {\n    front:  { top: 'x', bottom: 'x', left: 'y', right: 'y' },\n    back:   { top: 'x', bottom: 'x', left: 'y', right: 'y' },\n    left:   { top: 'z', bottom: 'z', left: 'y', right: 'y' },\n    right:  { top: 'z', bottom: 'z', left: 'y', right: 'y' },\n    top:    { top: 'x', bottom: 'x', left: 'z', right: 'z' },\n    bottom: { top: 'x', bottom: 'x', left: 'z', right: 'z' },\n  };\n  return edgeAxes[faceId][edgePosition];\n};\n","// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.5\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (typeof define === 'function' && define.amd) {\n  define(function () { return LZString; });\n} else if( typeof module !== 'undefined' && module != null ) {\n  module.exports = LZString\n} else if( typeof angular !== 'undefined' && angular != null ) {\n  angular.module('LZString', [])\n  .factory('LZString', function () {\n    return LZString;\n  });\n}\n","import { BoxConfig, Face, Void, AssemblyConfig, defaultAssemblyConfig, EdgeExtensions, defaultEdgeExtensions, SubAssembly, FaceOffsets, defaultFaceOffsets } from '../types';\nimport { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from 'lz-string';\n\n// Compact serialization format for URL storage\ninterface SerializedState {\n  v: number;  // Version for future compatibility\n  c: {        // Config\n    w: number;  // width\n    h: number;  // height\n    d: number;  // depth\n    mt: number; // materialThickness\n    fw: number; // fingerWidth\n    fg: number; // fingerGap\n    a?: SerializedAssembly;  // assembly (optional, defaults used if missing)\n  };\n  f: number;  // Faces bitmap (6 bits, one per face)\n  r: SerializedVoid;  // Root void\n  e?: Record<string, [number, number, number, number]>;  // Edge extensions by panel ID [top, bottom, left, right]\n}\n\ninterface SerializedAssembly {\n  ax: 'x' | 'y' | 'z';  // assemblyAxis\n  lp?: [string, number];  // lid positive [tabDirection, inset] if not default\n  ln?: [string, number];  // lid negative [tabDirection, inset] if not default\n}\n\ninterface SerializedSubAssembly {\n  id: string;\n  cl: number;             // clearance\n  fo?: [number, number, number, number, number, number];  // faceOffsets [front, back, left, right, top, bottom] if non-zero\n  f: number;              // faces bitmap\n  rv: SerializedVoid;     // rootVoid\n  mt: number;             // materialThickness\n  a?: SerializedAssembly; // assembly config\n}\n\ninterface SerializedVoid {\n  id: string;\n  b: [number, number, number, number, number, number];  // bounds [x, y, z, w, h, d]\n  ch?: SerializedVoid[];  // children\n  sa?: 'x' | 'y' | 'z';   // splitAxis\n  sp?: number;            // splitPosition\n  sub?: SerializedSubAssembly;  // subAssembly\n}\n\n// Face order for bitmap encoding\nconst FACE_ORDER = ['front', 'back', 'left', 'right', 'top', 'bottom'] as const;\n\n// Round number to 2 decimal places to save space\nconst r = (n: number): number => Math.round(n * 100) / 100;\n\n// Serialize faces to a bitmap (1 = solid, 0 = open)\nconst serializeFaces = (faces: Face[]): number => {\n  let bitmap = 0;\n  for (let i = 0; i < FACE_ORDER.length; i++) {\n    const face = faces.find(f => f.id === FACE_ORDER[i]);\n    if (face?.solid) {\n      bitmap |= (1 << i);\n    }\n  }\n  return bitmap;\n};\n\n// Deserialize faces from bitmap\nconst deserializeFaces = (bitmap: number): Face[] => {\n  return FACE_ORDER.map((id, i) => ({\n    id,\n    solid: (bitmap & (1 << i)) !== 0,\n  }));\n};\n\n// Serialize face offsets (only if non-zero)\nconst serializeFaceOffsets = (fo: FaceOffsets): [number, number, number, number, number, number] | undefined => {\n  if (fo.front === 0 && fo.back === 0 && fo.left === 0 && fo.right === 0 && fo.top === 0 && fo.bottom === 0) {\n    return undefined;\n  }\n  return [r(fo.front), r(fo.back), r(fo.left), r(fo.right), r(fo.top), r(fo.bottom)];\n};\n\n// Deserialize face offsets\nconst deserializeFaceOffsets = (sfo?: [number, number, number, number, number, number]): FaceOffsets => {\n  if (!sfo) return { ...defaultFaceOffsets };\n  return {\n    front: sfo[0],\n    back: sfo[1],\n    left: sfo[2],\n    right: sfo[3],\n    top: sfo[4],\n    bottom: sfo[5],\n  };\n};\n\n// Serialize sub-assembly\nconst serializeSubAssembly = (sub: SubAssembly): SerializedSubAssembly => {\n  return {\n    id: sub.id,\n    cl: r(sub.clearance),\n    fo: serializeFaceOffsets(sub.faceOffsets),\n    f: serializeFaces(sub.faces),\n    rv: serializeVoid(sub.rootVoid),\n    mt: r(sub.materialThickness),\n    a: serializeAssembly(sub.assembly),\n  };\n};\n\n// Deserialize sub-assembly\nconst deserializeSubAssembly = (ssub: SerializedSubAssembly): SubAssembly => {\n  return {\n    id: ssub.id,\n    clearance: ssub.cl,\n    faceOffsets: deserializeFaceOffsets(ssub.fo),\n    faces: deserializeFaces(ssub.f),\n    rootVoid: deserializeVoid(ssub.rv),\n    materialThickness: ssub.mt,\n    assembly: deserializeAssembly(ssub.a),\n  };\n};\n\n// Serialize void tree\nconst serializeVoid = (v: Void): SerializedVoid => {\n  const result: SerializedVoid = {\n    id: v.id,\n    b: [r(v.bounds.x), r(v.bounds.y), r(v.bounds.z), r(v.bounds.w), r(v.bounds.h), r(v.bounds.d)],\n  };\n\n  if (v.children && v.children.length > 0) {\n    result.ch = v.children.map(serializeVoid);\n  }\n  if (v.splitAxis) {\n    result.sa = v.splitAxis;\n  }\n  if (v.splitPosition !== undefined) {\n    result.sp = r(v.splitPosition);\n  }\n  if (v.subAssembly) {\n    result.sub = serializeSubAssembly(v.subAssembly);\n  }\n\n  return result;\n};\n\n// Deserialize void tree\nconst deserializeVoid = (sv: SerializedVoid): Void => {\n  const result: Void = {\n    id: sv.id,\n    bounds: {\n      x: sv.b[0],\n      y: sv.b[1],\n      z: sv.b[2],\n      w: sv.b[3],\n      h: sv.b[4],\n      d: sv.b[5],\n    },\n    children: sv.ch ? sv.ch.map(deserializeVoid) : [],\n    splitAxis: sv.sa,\n    splitPosition: sv.sp,\n  };\n\n  if (sv.sub) {\n    result.subAssembly = deserializeSubAssembly(sv.sub);\n  }\n\n  return result;\n};\n\n// Serialize assembly config (only non-default values)\nconst serializeAssembly = (a: AssemblyConfig): SerializedAssembly | undefined => {\n  const isDefault =\n    a.assemblyAxis === 'y' &&\n    a.lids.positive.tabDirection === 'tabs-out' &&\n    a.lids.positive.inset === 0 &&\n    a.lids.negative.tabDirection === 'tabs-out' &&\n    a.lids.negative.inset === 0;\n\n  if (isDefault) return undefined;\n\n  const result: SerializedAssembly = { ax: a.assemblyAxis };\n\n  if (a.lids.positive.tabDirection !== 'tabs-out' || a.lids.positive.inset !== 0) {\n    result.lp = [a.lids.positive.tabDirection, a.lids.positive.inset];\n  }\n  if (a.lids.negative.tabDirection !== 'tabs-out' || a.lids.negative.inset !== 0) {\n    result.ln = [a.lids.negative.tabDirection, a.lids.negative.inset];\n  }\n\n  return result;\n};\n\n// Deserialize assembly config\nconst deserializeAssembly = (sa?: SerializedAssembly): AssemblyConfig => {\n  if (!sa) return { ...defaultAssemblyConfig };\n\n  return {\n    assemblyAxis: sa.ax,\n    lids: {\n      positive: {\n        enabled: true,\n        tabDirection: (sa.lp?.[0] as 'tabs-out' | 'tabs-in') ?? 'tabs-out',\n        inset: sa.lp?.[1] ?? 0,\n      },\n      negative: {\n        enabled: true,\n        tabDirection: (sa.ln?.[0] as 'tabs-out' | 'tabs-in') ?? 'tabs-out',\n        inset: sa.ln?.[1] ?? 0,\n      },\n    },\n  };\n};\n\n// Serialize edge extensions (only non-zero)\nconst serializeExtensions = (\n  extensions: Record<string, EdgeExtensions>\n): Record<string, [number, number, number, number]> | undefined => {\n  const result: Record<string, [number, number, number, number]> = {};\n  let hasAny = false;\n\n  for (const [panelId, ext] of Object.entries(extensions)) {\n    if (ext.top !== 0 || ext.bottom !== 0 || ext.left !== 0 || ext.right !== 0) {\n      result[panelId] = [ext.top, ext.bottom, ext.left, ext.right];\n      hasAny = true;\n    }\n  }\n\n  return hasAny ? result : undefined;\n};\n\n// Deserialize edge extensions\nconst deserializeExtensions = (\n  se?: Record<string, [number, number, number, number]>\n): Record<string, EdgeExtensions> => {\n  if (!se) return {};\n\n  const result: Record<string, EdgeExtensions> = {};\n  for (const [panelId, [top, bottom, left, right]] of Object.entries(se)) {\n    result[panelId] = { top, bottom, left, right };\n  }\n  return result;\n};\n\n// Main serialization function\nexport interface ProjectState {\n  config: BoxConfig;\n  faces: Face[];\n  rootVoid: Void;\n  edgeExtensions: Record<string, EdgeExtensions>;\n}\n\nexport const serializeProject = (state: ProjectState): string => {\n  const serialized: SerializedState = {\n    v: 1,\n    c: {\n      w: r(state.config.width),\n      h: r(state.config.height),\n      d: r(state.config.depth),\n      mt: r(state.config.materialThickness),\n      fw: r(state.config.fingerWidth),\n      fg: r(state.config.fingerGap),\n      a: serializeAssembly(state.config.assembly),\n    },\n    f: serializeFaces(state.faces),\n    r: serializeVoid(state.rootVoid),\n    e: serializeExtensions(state.edgeExtensions),\n  };\n\n  // Convert to JSON and compress with lz-string\n  const json = JSON.stringify(serialized);\n  const compressed = compressToEncodedURIComponent(json);\n  return compressed;\n};\n\n// Try to deserialize with lz-string first, fall back to old base64 format\nexport const deserializeProject = (encoded: string): ProjectState | null => {\n  try {\n    // Try lz-string decompression first\n    let json = decompressFromEncodedURIComponent(encoded);\n\n    // Fall back to old base64 format if lz-string fails\n    if (!json) {\n      json = decodeURIComponent(atob(encoded));\n    }\n\n    const serialized: SerializedState = JSON.parse(json);\n\n    // Version check for future compatibility\n    if (serialized.v !== 1) {\n      console.warn('Unknown project version:', serialized.v);\n    }\n\n    const config: BoxConfig = {\n      width: serialized.c.w,\n      height: serialized.c.h,\n      depth: serialized.c.d,\n      materialThickness: serialized.c.mt,\n      fingerWidth: serialized.c.fw,\n      fingerGap: serialized.c.fg,\n      assembly: deserializeAssembly(serialized.c.a),\n    };\n\n    return {\n      config,\n      faces: deserializeFaces(serialized.f),\n      rootVoid: deserializeVoid(serialized.r),\n      edgeExtensions: deserializeExtensions(serialized.e),\n    };\n  } catch (e) {\n    console.error('Failed to deserialize project:', e);\n    return null;\n  }\n};\n\n// URL helpers - using query parameter for better sharing compatibility\nconst URL_PARAM = 'p';\n\nexport const saveToUrl = (state: ProjectState): void => {\n  const encoded = serializeProject(state);\n  const url = new URL(window.location.href);\n  url.searchParams.set(URL_PARAM, encoded);\n  url.hash = ''; // Clear any old hash\n  window.history.replaceState(null, '', url.toString());\n};\n\nexport const loadFromUrl = (): ProjectState | null => {\n  const params = new URLSearchParams(window.location.search);\n  const encoded = params.get(URL_PARAM);\n\n  // Also check hash for backwards compatibility with old URLs\n  if (!encoded) {\n    const hash = window.location.hash.slice(1);\n    if (hash) return deserializeProject(hash);\n    return null;\n  }\n\n  return deserializeProject(encoded);\n};\n\nexport const clearUrlState = (): void => {\n  const url = new URL(window.location.href);\n  url.searchParams.delete(URL_PARAM);\n  url.hash = '';\n  window.history.replaceState(null, '', url.toString());\n};\n\nexport const getShareableUrl = (state: ProjectState): string => {\n  const encoded = serializeProject(state);\n  const url = new URL(window.location.href);\n  url.searchParams.set(URL_PARAM, encoded);\n  url.hash = '';\n  return url.toString();\n};\n","export interface Point {\n  x: number;\n  y: number;\n}\n\nexport interface FingerJointConfig {\n  edgeLength: number;\n  fingerWidth: number;\n  materialThickness: number;\n  isTabOut: boolean;\n  kerf: number;\n  yUp?: boolean;  // If true, use Y-up coordinate system (Three.js), otherwise Y-down (SVG)\n  cornerGapMultiplier?: number;  // Gap at corners as multiplier of fingerWidth (default: 1.5)\n  // Asymmetric corner gaps - add extra gap when perpendicular edge doesn't have tabs\n  // (panel extends to box edge and contains the anchor sphere)\n  startCornerExtra?: number;  // Extra gap at start (in mm, added to base corner gap)\n  endCornerExtra?: number;    // Extra gap at end (in mm, added to base corner gap)\n  // For anchored generation: generate pattern based on originalLength with offset\n  originalLength?: number;  // The \"base\" length for finger pattern calculation (before extensions)\n  patternOffset?: number;   // Offset into the pattern (positive = start has moved inward/shrunk)\n  // Invert perpendicular direction without changing tab/slot positions\n  // Used when generating patterns from canonical direction for reversed edges\n  invertPerpendicular?: boolean;\n}\n\nexport const generateFingerJointPath = (\n  start: Point,\n  end: Point,\n  config: FingerJointConfig\n): Point[] => {\n  const { fingerWidth, materialThickness, isTabOut } = config;\n\n  const dx = end.x - start.x;\n  const dy = end.y - start.y;\n  const actualLength = Math.sqrt(dx * dx + dy * dy);\n\n  if (actualLength < 0.001) return [start, end];\n\n  const unitX = dx / actualLength;\n  const unitY = dy / actualLength;\n\n  // Perpendicular direction depends on coordinate system\n  // invertPerpendicular flips the direction for canonical direction generation\n  const perpSign = config.invertPerpendicular ? -1 : 1;\n  const perpX = perpSign * (config.yUp ? -unitY : unitY);\n  const perpY = perpSign * (config.yUp ? unitX : -unitX);\n\n  // Use originalLength for pattern calculation if provided\n  const patternLength = config.originalLength ?? config.edgeLength;\n\n  // Pattern offset: how much the start has moved inward (shrunk)\n  // Positive offset means the start moved toward the end (shrinking from start)\n  const patternOffset = config.patternOffset ?? 0;\n\n  // Corner gap to keep fingers away from corners\n  // Asymmetric gaps: add extra when perpendicular edge doesn't have tabs\n  // (panel extends to box edge and contains the anchor sphere)\n  const gapMultiplier = config.cornerGapMultiplier ?? 1.5;\n  const baseCornerGap = fingerWidth * gapMultiplier;\n  const startCornerGap = baseCornerGap + (config.startCornerExtra ?? 0);\n  const endCornerGap = baseCornerGap + (config.endCornerExtra ?? 0);\n  const usableLength = patternLength - startCornerGap - endCornerGap;\n\n  // If usable length is too small, just return a straight edge\n  if (usableLength < fingerWidth) {\n    return [start, end];\n  }\n\n  // Calculate number of fingers based on pattern length\n  let numFingers = Math.max(1, Math.floor(usableLength / fingerWidth));\n  if (numFingers % 2 === 0) numFingers++;\n\n  const actualFingerWidth = usableLength / numFingers;\n  const depth = materialThickness;\n\n  // Helper to convert pattern position to actual position along the edge\n  // patternPos is position in the original (non-offset) pattern\n  // Returns position along the actual edge, or null if outside\n  const patternToActual = (patternPos: number): number | null => {\n    const actualPos = patternPos - patternOffset;\n    if (actualPos < -0.001 || actualPos > actualLength + 0.001) return null;\n    return Math.max(0, Math.min(actualLength, actualPos));\n  };\n\n  const points: Point[] = [];\n\n  // Start point\n  points.push(start);\n\n  // Corner gap at start - only if visible after offset\n  const cornerGapActual = patternToActual(startCornerGap);\n  if (cornerGapActual !== null && cornerGapActual > 0.001) {\n    points.push({\n      x: start.x + unitX * cornerGapActual,\n      y: start.y + unitY * cornerGapActual,\n    });\n  }\n\n  // Generate fingers\n  for (let i = 0; i < numFingers; i++) {\n    const isEvenPosition = i % 2 === 0;\n    const fingerStartPattern = startCornerGap + i * actualFingerWidth;\n    const fingerEndPattern = startCornerGap + (i + 1) * actualFingerWidth;\n\n    const fingerStartActual = patternToActual(fingerStartPattern);\n    const fingerEndActual = patternToActual(fingerEndPattern);\n\n    // Skip fingers entirely outside the actual edge\n    if (fingerStartActual === null && fingerEndActual === null) continue;\n    if (fingerEndPattern < patternOffset) continue;  // Entirely before actual start\n    if (fingerStartPattern > patternOffset + actualLength) continue;  // Entirely after actual end\n\n    // Clamp to actual edge bounds\n    const clampedStart = fingerStartActual !== null ? fingerStartActual : 0;\n    const clampedEnd = fingerEndActual !== null ? fingerEndActual : actualLength;\n\n    if (isEvenPosition) {\n      // Tab or slot position\n      const offsetX = isTabOut ? perpX * depth : -perpX * depth;\n      const offsetY = isTabOut ? perpY * depth : -perpY * depth;\n\n      const fStartPt: Point = {\n        x: start.x + unitX * clampedStart,\n        y: start.y + unitY * clampedStart,\n      };\n      const fEndPt: Point = {\n        x: start.x + unitX * clampedEnd,\n        y: start.y + unitY * clampedEnd,\n      };\n\n      // Check if finger start is visible (not clipped)\n      const startVisible = fingerStartActual !== null && fingerStartActual >= 0;\n      // Check if finger end is visible (not clipped)\n      const endVisible = fingerEndActual !== null && fingerEndActual <= actualLength;\n\n      if (startVisible) {\n        // Full finger start - step to the offset\n        const lastPt = points[points.length - 1];\n        if (Math.abs(fStartPt.x - lastPt.x) > 0.001 || Math.abs(fStartPt.y - lastPt.y) > 0.001) {\n          points.push(fStartPt);\n        }\n        points.push({ x: fStartPt.x + offsetX, y: fStartPt.y + offsetY });\n      } else {\n        // Finger is clipped at start - start already at offset level\n        points.push({ x: fStartPt.x + offsetX, y: fStartPt.y + offsetY });\n      }\n\n      if (endVisible) {\n        // Full finger end - step back from offset\n        points.push({ x: fEndPt.x + offsetX, y: fEndPt.y + offsetY });\n        points.push(fEndPt);\n      } else {\n        // Finger is clipped at end - stay at offset level\n        points.push({ x: fEndPt.x + offsetX, y: fEndPt.y + offsetY });\n      }\n    } else {\n      // Straight section (odd position)\n      const fEndPt: Point = {\n        x: start.x + unitX * clampedEnd,\n        y: start.y + unitY * clampedEnd,\n      };\n      const lastPt = points[points.length - 1];\n      if (Math.abs(fEndPt.x - lastPt.x) > 0.001 || Math.abs(fEndPt.y - lastPt.y) > 0.001) {\n        points.push(fEndPt);\n      }\n    }\n  }\n\n  // Corner gap at end - only if visible\n  const endGapPattern = patternLength - endCornerGap;\n  const endGapActual = patternToActual(endGapPattern);\n  if (endGapActual !== null && endGapActual < actualLength - 0.001) {\n    const lastPt = points[points.length - 1];\n    const gapPt = {\n      x: start.x + unitX * endGapActual,\n      y: start.y + unitY * endGapActual,\n    };\n    if (Math.abs(gapPt.x - lastPt.x) > 0.001 || Math.abs(gapPt.y - lastPt.y) > 0.001) {\n      points.push(gapPt);\n    }\n  }\n\n  // End point\n  const lastPt = points[points.length - 1];\n  if (Math.abs(end.x - lastPt.x) > 0.001 || Math.abs(end.y - lastPt.y) > 0.001) {\n    points.push(end);\n  }\n\n  return points;\n};\n\nexport const generateStraightEdge = (start: Point, end: Point): Point[] => {\n  return [start, end];\n};\n\nexport type EdgeType = 'finger-out' | 'finger-in' | 'straight';\n\nexport const getEdgePath = (\n  start: Point,\n  end: Point,\n  edgeType: EdgeType,\n  config: Omit<FingerJointConfig, 'isTabOut'>\n): Point[] => {\n  const edgeLength = Math.sqrt(\n    Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)\n  );\n\n  switch (edgeType) {\n    case 'finger-out':\n      return generateFingerJointPath(start, end, {\n        ...config,\n        edgeLength,\n        isTabOut: true,\n      });\n    case 'finger-in':\n      return generateFingerJointPath(start, end, {\n        ...config,\n        edgeLength,\n        isTabOut: false,\n      });\n    case 'straight':\n    default:\n      return generateStraightEdge(start, end);\n  }\n};\n\n// =============================================================================\n// V2: Assembly-level finger point based path generation\n// =============================================================================\n\nimport { AxisFingerPoints, JointGender } from '../types';\n\nexport interface FingerJointConfigV2 {\n  fingerPoints: AxisFingerPoints;   // Pre-calculated finger points for this axis\n  gender: JointGender;              // 'male' (tabs out) or 'female' (slots in)\n  materialThickness: number;\n  edgeStartPos: number;             // Start position of this edge along the axis\n  edgeEndPos: number;               // End position of this edge along the axis\n  yUp?: boolean;                    // Coordinate system (default: true for Three.js)\n  outwardDirection?: Point;         // Explicit outward direction for tabs (normalized vector)\n}\n\n/**\n * Generate finger joint path using pre-calculated assembly finger points.\n *\n * This is the V2 implementation that uses centralized finger point data\n * to ensure all parallel edges have aligned finger positions.\n *\n * @param start - Start point of the edge in 2D panel coordinates\n * @param end - End point of the edge in 2D panel coordinates\n * @param config - Configuration with pre-calculated finger points\n * @returns Array of points forming the finger joint path\n */\nexport const generateFingerJointPathV2 = (\n  start: Point,\n  end: Point,\n  config: FingerJointConfigV2\n): Point[] => {\n  const { fingerPoints, gender, materialThickness } = config;\n  const { points: transitionPoints, innerOffset, fingerLength, maxJointLength } = fingerPoints;\n\n  // Edge direction\n  const dx = end.x - start.x;\n  const dy = end.y - start.y;\n  const actualLength = Math.sqrt(dx * dx + dy * dy);\n\n  if (actualLength < 0.001) return [start, end];\n\n  const unitX = dx / actualLength;\n  const unitY = dy / actualLength;\n\n  // Perpendicular direction (for tab/slot depth)\n  // If outwardDirection is provided, use it; otherwise compute from edge direction\n  let perpX: number;\n  let perpY: number;\n\n  if (config.outwardDirection) {\n    // Use explicit outward direction\n    perpX = config.outwardDirection.x;\n    perpY = config.outwardDirection.y;\n  } else {\n    // Compute from edge direction (default behavior)\n    const yUp = config.yUp ?? true;\n    perpX = yUp ? -unitY : unitY;\n    perpY = yUp ? unitX : -unitX;\n  }\n\n  // Tab depth direction based on gender\n  // Male (tabs out): positive offset (tabs extend outward)\n  // Female (slots in): negative offset (slots go inward)\n  const depth = materialThickness;\n  const depthSign = gender === 'male' ? 1 : -1;\n\n  // If no finger points, return straight edge\n  if (transitionPoints.length === 0 || fingerLength <= 0) {\n    return [start, end];\n  }\n\n  // Map edge positions to axis positions\n  // edgeStartPos/edgeEndPos are positions along the axis\n  // We need to map axis positions to positions along this edge\n  const { edgeStartPos, edgeEndPos } = config;\n  const edgeAxisLength = Math.abs(edgeEndPos - edgeStartPos);\n\n  // Direction: is edgeEndPos > edgeStartPos (positive direction)?\n  const isPositiveDirection = edgeEndPos > edgeStartPos;\n\n  // Helper: Convert axis position to edge position (0 to actualLength)\n  const axisToEdge = (axisPos: number): number => {\n    if (isPositiveDirection) {\n      return ((axisPos - edgeStartPos) / edgeAxisLength) * actualLength;\n    } else {\n      return ((edgeStartPos - axisPos) / edgeAxisLength) * actualLength;\n    }\n  };\n\n  // Helper: Get point at edge position\n  const pointAtEdge = (edgePos: number, offset: number = 0): Point => {\n    const clampedPos = Math.max(0, Math.min(actualLength, edgePos));\n    return {\n      x: start.x + unitX * clampedPos + perpX * offset,\n      y: start.y + unitY * clampedPos + perpY * offset,\n    };\n  };\n\n  // Filter transition points to those within this edge's range\n  const minAxisPos = Math.min(edgeStartPos, edgeEndPos);\n  const maxAxisPos = Math.max(edgeStartPos, edgeEndPos);\n\n  // Calculate the finger region boundaries (innerOffset gaps at both ends)\n  const fingerRegionStart = innerOffset;\n  const fingerRegionEnd = maxJointLength - innerOffset;\n\n  // Build all section boundaries in axis coordinates\n  // Sections alternate: finger (0), hole (1), finger (2), etc.\n  const allBoundaries = [fingerRegionStart, ...transitionPoints, fingerRegionEnd];\n\n  // Define sections with their axis positions and finger status\n  interface Section {\n    startAxis: number;\n    endAxis: number;\n    isFinger: boolean;\n  }\n\n  const allSections: Section[] = [];\n  for (let i = 0; i < allBoundaries.length - 1; i++) {\n    allSections.push({\n      startAxis: allBoundaries[i],\n      endAxis: allBoundaries[i + 1],\n      isFinger: i % 2 === 0,  // Even indices are finger sections\n    });\n  }\n\n  // Filter to sections that are COMPLETELY within the edge's axis range\n  // Partial fingers are not allowed - skip sections that extend beyond the edge\n  const validSections = allSections.filter(section =>\n    section.startAxis >= minAxisPos && section.endAxis <= maxAxisPos\n  );\n\n  // If no valid sections, return straight edge\n  const hasFingerSections = validSections.some(s => s.isFinger);\n  if (!hasFingerSections) {\n    return [start, end];\n  }\n\n  // Build the path\n  const pathPoints: Point[] = [];\n\n  // Start point\n  pathPoints.push(start);\n\n  // Sort valid sections by edge position for proper path generation\n  const sortedSections = validSections\n    .map(section => ({\n      ...section,\n      startEdge: axisToEdge(section.startAxis),\n      endEdge: axisToEdge(section.endAxis),\n    }))\n    .sort((a, b) => Math.min(a.startEdge, a.endEdge) - Math.min(b.startEdge, b.endEdge));\n\n  // Track where we need to draw\n  let currentEdgePos = 0;\n\n  for (const section of sortedSections) {\n    // Get edge positions (handle reversed edges)\n    const sectionStartEdge = Math.min(section.startEdge, section.endEdge);\n    const sectionEndEdge = Math.max(section.startEdge, section.endEdge);\n\n    // Skip sections with negligible length\n    if (sectionEndEdge - sectionStartEdge < 0.001) continue;\n\n    // Add straight segment from current position to section start if needed\n    if (sectionStartEdge > currentEdgePos + 0.001) {\n      pathPoints.push(pointAtEdge(sectionStartEdge));\n    }\n\n    if (section.isFinger) {\n      // Finger section: generate tab (male) or slot (female)\n      pathPoints.push(pointAtEdge(sectionStartEdge, depth * depthSign));\n      pathPoints.push(pointAtEdge(sectionEndEdge, depth * depthSign));\n      pathPoints.push(pointAtEdge(sectionEndEdge));\n    } else {\n      // Hole section: straight line\n      const endPt = pointAtEdge(sectionEndEdge);\n      const lastPt = pathPoints[pathPoints.length - 1];\n      if (Math.abs(endPt.x - lastPt.x) > 0.001 || Math.abs(endPt.y - lastPt.y) > 0.001) {\n        pathPoints.push(endPt);\n      }\n    }\n\n    currentEdgePos = sectionEndEdge;\n  }\n\n  // Ensure we end at the end point\n  const lastPt = pathPoints[pathPoints.length - 1];\n  if (Math.abs(end.x - lastPt.x) > 0.001 || Math.abs(end.y - lastPt.y) > 0.001) {\n    pathPoints.push(end);\n  }\n\n  // Remove duplicate consecutive points\n  const cleanedPoints: Point[] = [pathPoints[0]];\n  for (let i = 1; i < pathPoints.length; i++) {\n    const prev = cleanedPoints[cleanedPoints.length - 1];\n    const curr = pathPoints[i];\n    if (Math.abs(curr.x - prev.x) > 0.001 || Math.abs(curr.y - prev.y) > 0.001) {\n      cleanedPoints.push(curr);\n    }\n  }\n\n  return cleanedPoints;\n};\n","/**\n * Finger Point Calculator\n *\n * Calculates finger joint transition points at the assembly level.\n * All edges parallel to an axis share the same finger points, guaranteeing alignment.\n */\n\nimport {\n  AxisFingerPoints,\n  AssemblyFingerData,\n  FingerPointConfig,\n  BoxConfig,\n  getAxisDimension,\n} from '../types';\n\n/**\n * Calculate finger points for a single axis.\n *\n * @param axisLength - The dimension along this axis (width, height, or depth)\n * @param config - Finger point configuration\n * @returns Finger points for this axis\n */\nexport const calculateAxisFingerPoints = (\n  axis: 'x' | 'y' | 'z',\n  axisLength: number,\n  config: FingerPointConfig\n): AxisFingerPoints => {\n  const { materialThickness, fingerLength, minDistance } = config;\n\n  // Maximum joint length accounts for perpendicular panels at each end\n  const maxJointLength = axisLength - (2 * materialThickness);\n\n  // If maxJointLength is too small, return empty points (straight edge)\n  if (maxJointLength <= 0) {\n    return {\n      axis,\n      points: [],\n      innerOffset: 0,\n      fingerLength: 0,\n      maxJointLength: 0,\n    };\n  }\n\n  // Usable length after reserving minimum gap at both ends\n  const usableLength = maxJointLength - (2 * minDistance);\n\n  // If usable length is too small for even one finger, return empty\n  if (usableLength < fingerLength) {\n    return {\n      axis,\n      points: [],\n      innerOffset: minDistance,\n      fingerLength: 0,\n      maxJointLength,\n    };\n  }\n\n  // Calculate how many sections fit\n  let numSections = Math.floor(usableLength / fingerLength);\n\n  // Ensure odd number of sections for symmetry (OUT-IN-OUT pattern)\n  if (numSections % 2 === 0) {\n    numSections = numSections - 1;\n  }\n\n  // Ensure at least 1 section\n  if (numSections < 1) {\n    numSections = 1;\n  }\n\n  // Calculate actual finger length to use (may be slightly larger than config)\n  const actualFingerLength = usableLength / numSections;\n\n  // Calculate remainder and distribute to both ends\n  // Note: With the adjusted fingerLength, there's no remainder,\n  // but we keep innerOffset as the base minDistance\n  const innerOffset = minDistance;\n\n  // Generate transition points\n  // Points mark transitions between finger (OUT) and hole (IN) states\n  // Pattern: [gap] OUT [point] IN [point] OUT [point] IN [point] OUT [gap]\n  const points: number[] = [];\n  for (let i = 1; i < numSections; i++) {\n    // Each point is at innerOffset + i * actualFingerLength\n    points.push(innerOffset + (i * actualFingerLength));\n  }\n\n  return {\n    axis,\n    points,\n    innerOffset,\n    fingerLength: actualFingerLength,\n    maxJointLength,\n  };\n};\n\n/**\n * Calculate finger points for all 3 axes of an assembly.\n *\n * @param boxConfig - The box configuration\n * @returns Finger data for all axes\n */\nexport const calculateAssemblyFingerPoints = (\n  boxConfig: BoxConfig\n): AssemblyFingerData => {\n  const config: FingerPointConfig = {\n    materialThickness: boxConfig.materialThickness,\n    fingerLength: boxConfig.fingerWidth,\n    // Convert fingerGap (multiplier) to minDistance (absolute)\n    minDistance: boxConfig.fingerGap * boxConfig.fingerWidth,\n  };\n\n  return {\n    x: calculateAxisFingerPoints('x', boxConfig.width, config),\n    y: calculateAxisFingerPoints('y', boxConfig.height, config),\n    z: calculateAxisFingerPoints('z', boxConfig.depth, config),\n  };\n};\n\n/**\n * Calculate finger points for a sub-assembly based on its bounds.\n *\n * @param bounds - The sub-assembly bounding box\n * @param materialThickness - Material thickness\n * @param fingerWidth - Target finger width\n * @param fingerGap - Corner gap multiplier\n * @returns Finger data for all axes\n */\nexport const calculateSubAssemblyFingerPoints = (\n  bounds: { w: number; h: number; d: number },\n  materialThickness: number,\n  fingerWidth: number,\n  fingerGap: number\n): AssemblyFingerData => {\n  const config: FingerPointConfig = {\n    materialThickness,\n    fingerLength: fingerWidth,\n    minDistance: fingerGap * fingerWidth,\n  };\n\n  return {\n    x: calculateAxisFingerPoints('x', bounds.w, config),\n    y: calculateAxisFingerPoints('y', bounds.h, config),\n    z: calculateAxisFingerPoints('z', bounds.d, config),\n  };\n};\n\n/**\n * Get finger points that fall within a given range.\n * Used for inset panels where only part of the joint is valid.\n *\n * @param axisPoints - The full axis finger points\n * @param startPos - Start position along axis (relative to MT-inset edge)\n * @param endPos - End position along axis\n * @returns Filtered array of finger points within range\n */\nexport const getFingerPointsInRange = (\n  axisPoints: AxisFingerPoints,\n  startPos: number,\n  endPos: number\n): number[] => {\n  // Filter points to those within the range\n  return axisPoints.points.filter(p => p >= startPos && p <= endPos);\n};\n\n/**\n * Determine if the first section at a position is a finger (OUT) or hole (IN).\n *\n * The pattern always starts with OUT (finger) at the beginning of the joint.\n * - Position < first point: OUT\n * - Between points: alternates IN, OUT, IN, OUT, ...\n * - Position > last point: OUT (if odd number of transitions)\n *\n * @param position - Position along the axis to check\n * @param axisPoints - The axis finger points\n * @returns 'finger' or 'hole'\n */\nexport const getSectionTypeAtPosition = (\n  position: number,\n  axisPoints: AxisFingerPoints\n): 'finger' | 'hole' => {\n  const { points, innerOffset } = axisPoints;\n\n  // Before the first transition, it's always a finger\n  if (points.length === 0 || position < points[0]) {\n    return 'finger';\n  }\n\n  // Count how many transition points we've passed\n  let transitionsPassed = 0;\n  for (const p of points) {\n    if (position >= p) {\n      transitionsPassed++;\n    } else {\n      break;\n    }\n  }\n\n  // Even number of transitions passed = finger, odd = hole\n  return transitionsPassed % 2 === 0 ? 'finger' : 'hole';\n};\n\n/**\n * Generate extended finger points beyond the bounding box.\n * Used when panels extend past the normal assembly boundary.\n *\n * @param axisPoints - The base axis finger points\n * @param extensionAmount - How far beyond maxJointLength to extend\n * @returns Array of additional finger points beyond the normal range\n */\nexport const generateExtendedFingerPoints = (\n  axisPoints: AxisFingerPoints,\n  extensionAmount: number\n): number[] => {\n  if (extensionAmount <= 0 || axisPoints.fingerLength <= 0) {\n    return [];\n  }\n\n  const { maxJointLength, innerOffset, fingerLength, points } = axisPoints;\n\n  // The last normal section ends at maxJointLength - innerOffset\n  // Continue the pattern beyond that\n  const extendedPoints: number[] = [];\n\n  // Determine where the pattern would continue from\n  // The pattern continues at fingerLength intervals\n  const lastNormalPosition = maxJointLength - innerOffset;\n  let nextPosition = lastNormalPosition + fingerLength;\n\n  // Determine if the next point should maintain the alternating pattern\n  // At maxJointLength - innerOffset, we're at the end of the last finger section\n  // So the next transition would be to a hole, then finger, etc.\n\n  while (nextPosition <= maxJointLength + extensionAmount) {\n    extendedPoints.push(nextPosition);\n    nextPosition += fingerLength;\n  }\n\n  return extendedPoints;\n};\n","/**\n * Gender Rules for Finger Joints\n *\n * Determines whether an edge should have tabs (male) or slots (female).\n * The rules ensure that mating edges always have opposite genders.\n */\n\nimport {\n  FaceId,\n  AssemblyConfig,\n  JointGender,\n  Face,\n  getFaceRole,\n  getLidSide,\n  getWallPriority,\n} from '../types';\n\n/**\n * Get the adjacent face for a given edge position.\n */\nexport const getAdjacentFace = (\n  faceId: FaceId,\n  edgePosition: 'top' | 'bottom' | 'left' | 'right'\n): FaceId => {\n  // Map each face + edge position to its adjacent face\n  const adjacencyMap: Record<FaceId, Record<string, FaceId>> = {\n    front: { top: 'top', bottom: 'bottom', left: 'left', right: 'right' },\n    back: { top: 'top', bottom: 'bottom', left: 'right', right: 'left' },\n    left: { top: 'top', bottom: 'bottom', left: 'back', right: 'front' },\n    right: { top: 'top', bottom: 'bottom', left: 'front', right: 'back' },\n    top: { top: 'back', bottom: 'front', left: 'left', right: 'right' },\n    bottom: { top: 'front', bottom: 'back', left: 'left', right: 'right' },\n  };\n  return adjacencyMap[faceId][edgePosition];\n};\n\n/**\n * Get the gender of a lid face based on its tab direction config.\n * tabs-out = male (tabs protrude)\n * tabs-in = female (slots receive tabs)\n */\nexport const getLidGender = (\n  faceId: FaceId,\n  assembly: AssemblyConfig\n): JointGender | null => {\n  const side = getLidSide(faceId, assembly.assemblyAxis);\n  if (!side) return null; // Not a lid\n\n  const lidConfig = assembly.lids[side];\n  return lidConfig.tabDirection === 'tabs-out' ? 'male' : 'female';\n};\n\n/**\n * Determine the gender for an edge joint.\n *\n * Rules (in order of precedence):\n * 1. If adjacent face is not solid  null (straight edge, no joint)\n * 2. If this face is a lid  use lid's configured gender\n * 3. If adjacent face is a lid  opposite of lid's gender\n * 4. Wall-to-wall  lower priority face gets male, higher gets female\n *\n * @param faceId - The face this edge belongs to\n * @param edgePosition - Which edge on the face (top/bottom/left/right)\n * @param faces - All faces in the assembly (to check solid state)\n * @param assembly - Assembly configuration\n * @returns JointGender or null if no joint (straight edge)\n */\nexport const getEdgeGender = (\n  faceId: FaceId,\n  edgePosition: 'top' | 'bottom' | 'left' | 'right',\n  faces: Face[],\n  assembly: AssemblyConfig\n): JointGender | null => {\n  const adjacentFaceId = getAdjacentFace(faceId, edgePosition);\n  const adjacentFace = faces.find((f) => f.id === adjacentFaceId);\n\n  // Rule 1: If adjacent face is not solid, no joint needed\n  if (!adjacentFace?.solid) {\n    return null;\n  }\n\n  const thisRole = getFaceRole(faceId, assembly.assemblyAxis);\n  const adjacentRole = getFaceRole(adjacentFaceId, assembly.assemblyAxis);\n\n  // Rule 2: If this face is a lid, use its configured gender\n  if (thisRole === 'lid') {\n    return getLidGender(faceId, assembly);\n  }\n\n  // Rule 3: If adjacent face is a lid, use opposite of its gender\n  if (adjacentRole === 'lid') {\n    const lidGender = getLidGender(adjacentFaceId, assembly);\n    if (lidGender) {\n      return lidGender === 'male' ? 'female' : 'male';\n    }\n  }\n\n  // Rule 4: Wall-to-wall - lower priority = male, higher priority = female\n  const thisPriority = getWallPriority(faceId);\n  const adjacentPriority = getWallPriority(adjacentFaceId);\n\n  return thisPriority < adjacentPriority ? 'male' : 'female';\n};\n\n/**\n * Get the gender for a divider edge.\n * Dividers always have male joints (tabs) on edges that meet solid faces.\n *\n * @param meetsSolidFace - Whether this edge meets a solid outer face\n * @returns 'male' if it meets a solid face, null if edge meets open face\n */\nexport const getDividerEdgeGender = (\n  meetsSolidFace: boolean\n): JointGender | null => {\n  // Dividers always have male joints (tabs extending out)\n  // When meeting an open face, no joint needed (straight edge)\n  return meetsSolidFace ? 'male' : null;\n};\n\n/**\n * Get all edge genders for a face panel.\n * Useful for rendering the full panel outline.\n */\nexport const getAllEdgeGenders = (\n  faceId: FaceId,\n  faces: Face[],\n  assembly: AssemblyConfig\n): Record<'top' | 'bottom' | 'left' | 'right', JointGender | null> => {\n  return {\n    top: getEdgeGender(faceId, 'top', faces, assembly),\n    bottom: getEdgeGender(faceId, 'bottom', faces, assembly),\n    left: getEdgeGender(faceId, 'left', faces, assembly),\n    right: getEdgeGender(faceId, 'right', faces, assembly),\n  };\n};\n\n/**\n * Check if two faces should have opposing genders at their shared edge.\n * Used for validation/debugging to ensure joint compatibility.\n */\nexport const validateMatingGenders = (\n  face1: FaceId,\n  face1Edge: 'top' | 'bottom' | 'left' | 'right',\n  faces: Face[],\n  assembly: AssemblyConfig\n): boolean => {\n  const face2 = getAdjacentFace(face1, face1Edge);\n\n  // Check if both faces are solid (exist as panels)\n  const face1Solid = faces.find((f) => f.id === face1)?.solid ?? false;\n  const face2Solid = faces.find((f) => f.id === face2)?.solid ?? false;\n\n  // If either face is open, no validation needed (no mating edge exists)\n  if (!face1Solid || !face2Solid) return true;\n\n  const gender1 = getEdgeGender(face1, face1Edge, faces, assembly);\n\n  // Find which edge of face2 connects to face1\n  const face2Edge = findConnectingEdge(face2, face1);\n  const gender2 = getEdgeGender(face2, face2Edge, faces, assembly);\n\n  // Both should be null (no joint) or opposite genders\n  if (gender1 === null && gender2 === null) return true;\n  if (gender1 === null || gender2 === null) return false;\n  return gender1 !== gender2;\n};\n\n/**\n * Find which edge of targetFace connects to sourceFace.\n */\nconst findConnectingEdge = (\n  targetFace: FaceId,\n  sourceFace: FaceId\n): 'top' | 'bottom' | 'left' | 'right' => {\n  const edges: Array<'top' | 'bottom' | 'left' | 'right'> = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n  ];\n  for (const edge of edges) {\n    if (getAdjacentFace(targetFace, edge) === sourceFace) {\n      return edge;\n    }\n  }\n  // This shouldn't happen with valid face pairs\n  throw new Error(`No connecting edge found between ${targetFace} and ${sourceFace}`);\n};\n","// Panel Generator - Creates PanelPath objects from box configuration\n// These paths are the source of truth for both 3D rendering and SVG export\n\nimport {\n  BoxConfig,\n  Face,\n  FaceId,\n  Void,\n  PanelPath,\n  PanelHole,\n  PathPoint,\n  PanelCollection,\n  PanelSource,\n  AssemblyConfig,\n  AssemblyFingerData,\n  EdgeExtensions,\n  getFaceRole,\n  getLidSide,\n  getWallPriority,\n  getEdgeAxis,\n  defaultEdgeExtensions,\n} from '../types';\nimport { generateFingerJointPath, generateFingerJointPathV2, Point } from './fingerJoints';\nimport { calculateAssemblyFingerPoints } from './fingerPoints';\nimport { getEdgeGender, getAdjacentFace } from './genderRules';\nimport { getAllSubdivisions } from '../store/useBoxStore';\n\n// Helper to get edge axis position range for finger system\n// Returns [startPos, endPos] along the axis where:\n// - startPos corresponds to the 2D edge start point\n// - endPos corresponds to the 2D edge end point\n// This accounts for the fact that edges follow a clockwise pattern around each face,\n// so bottom/right edges run in the negative direction along their axis.\nconst getEdgeAxisPositions = (\n  faceId: FaceId,\n  edgePosition: 'top' | 'bottom' | 'left' | 'right',\n  config: BoxConfig,\n  lowHasTabs: boolean,   // Does the LOW end of the axis have tabs (left/bottom side)\n  highHasTabs: boolean   // Does the HIGH end of the axis have tabs (right/top side)\n): { startPos: number; endPos: number } => {\n  const { width, height, depth, materialThickness } = config;\n  const mt = materialThickness;\n\n  // Get the axis for this edge\n  const axis = getEdgeAxis(faceId, edgePosition);\n\n  // Calculate the low and high positions along the axis\n  // lowPos = left/bottom side of axis (negative direction)\n  // highPos = right/top side of axis (positive direction)\n  let lowPos: number;\n  let highPos: number;\n\n  switch (axis) {\n    case 'x': {\n      const maxJoint = width - 2 * mt;\n      lowPos = lowHasTabs ? 0 : -mt;\n      highPos = highHasTabs ? maxJoint : maxJoint + mt;\n      break;\n    }\n    case 'y': {\n      const maxJoint = height - 2 * mt;\n      lowPos = lowHasTabs ? 0 : -mt;\n      highPos = highHasTabs ? maxJoint : maxJoint + mt;\n      break;\n    }\n    case 'z': {\n      const maxJoint = depth - 2 * mt;\n      lowPos = lowHasTabs ? 0 : -mt;\n      highPos = highHasTabs ? maxJoint : maxJoint + mt;\n      break;\n    }\n  }\n\n  // Edges follow clockwise pattern in 2D:\n  // - top edge: left-to-right (low to high along axis)\n  // - right edge: top-to-bottom (high to low along axis)\n  // - bottom edge: right-to-left (high to low along axis)\n  // - left edge: bottom-to-top (low to high along axis)\n  // So for bottom/right edges, we need to swap the positions\n  const runsNegative = edgePosition === 'bottom' || edgePosition === 'right';\n\n  if (runsNegative) {\n    // 2D edge start is at high position, end is at low position\n    return { startPos: highPos, endPos: lowPos };\n  } else {\n    // 2D edge start is at low position, end is at high position\n    return { startPos: lowPos, endPos: highPos };\n  }\n};\n\n// Helper to get the outward direction for an edge\n// Outward means away from the panel center, in 2D panel space\nconst getEdgeOutwardDirection = (\n  edgePosition: 'top' | 'bottom' | 'left' | 'right'\n): Point => {\n  switch (edgePosition) {\n    case 'top': return { x: 0, y: 1 };\n    case 'bottom': return { x: 0, y: -1 };\n    case 'left': return { x: -1, y: 0 };\n    case 'right': return { x: 1, y: 0 };\n  }\n};\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\ninterface FaceDimensions {\n  width: number;\n  height: number;\n}\n\nexport const getFaceDimensions = (\n  faceId: FaceId,\n  config: BoxConfig\n): FaceDimensions => {\n  switch (faceId) {\n    case 'front':\n    case 'back':\n      return { width: config.width, height: config.height };\n    case 'left':\n    case 'right':\n      return { width: config.depth, height: config.height };\n    case 'top':\n    case 'bottom':\n      return { width: config.width, height: config.depth };\n  }\n};\n\nexport interface EdgeInfo {\n  adjacentFaceId: FaceId;\n  isHorizontal: boolean;\n  position: 'top' | 'bottom' | 'left' | 'right';\n}\n\nexport const getFaceEdges = (faceId: FaceId): EdgeInfo[] => {\n  switch (faceId) {\n    case 'front':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'right' },\n      ];\n    case 'back':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'right' },\n      ];\n    case 'left':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'back', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'front', isHorizontal: false, position: 'right' },\n      ];\n    case 'right':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'front', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'back', isHorizontal: false, position: 'right' },\n      ];\n    case 'top':\n      return [\n        { adjacentFaceId: 'back', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'front', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'right' },\n      ];\n    case 'bottom':\n      return [\n        { adjacentFaceId: 'front', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'back', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'right' },\n      ];\n  }\n};\n\n// Get which edge of the adjacent face corresponds to this face's edge\n// For example: top face's right edge connects to right face's top edge\nexport const getAdjacentEdgePosition = (\n  faceId: FaceId,\n  edgePosition: 'top' | 'bottom' | 'left' | 'right'\n): 'top' | 'bottom' | 'left' | 'right' => {\n  // This mapping defines which edge of the adjacent face connects back to this face\n  // Derived from getFaceEdges: if face A's edge X connects to face B,\n  // then face B's edge Y connects back to face A (found by looking up B in getFaceEdges)\n  const mapping: Record<FaceId, Record<string, 'top' | 'bottom' | 'left' | 'right'>> = {\n    front: { top: 'bottom', bottom: 'top', left: 'right', right: 'left' },\n    back: { top: 'top', bottom: 'bottom', left: 'right', right: 'left' },\n    left: { top: 'left', bottom: 'left', left: 'right', right: 'left' },\n    right: { top: 'right', bottom: 'right', left: 'right', right: 'left' },\n    top: { top: 'top', bottom: 'top', left: 'top', right: 'top' },\n    bottom: { top: 'bottom', bottom: 'bottom', left: 'bottom', right: 'bottom' },\n  };\n  return mapping[faceId][edgePosition];\n};\n\n// Get the extension value from an adjacent face's edge that connects to this face\nconst getAdjacentFaceExtension = (\n  faceId: FaceId,\n  edgePosition: 'top' | 'bottom' | 'left' | 'right',\n  existingPanels?: PanelPath[]\n): number => {\n  if (!existingPanels) return 0;\n\n  const edges = getFaceEdges(faceId);\n  const edgeInfo = edges.find(e => e.position === edgePosition);\n  if (!edgeInfo) return 0;\n\n  const adjacentFaceId = edgeInfo.adjacentFaceId;\n  const adjacentPanel = existingPanels.find(p => p.source.faceId === adjacentFaceId);\n  if (!adjacentPanel) return 0;\n\n  const adjacentEdgePosition = getAdjacentEdgePosition(faceId, edgePosition);\n  return adjacentPanel.edgeExtensions[adjacentEdgePosition] || 0;\n};\n\n// Get extensions from adjacent face that affect each end of this edge\n// When an adjacent face contracts its perpendicular edges, it affects the shared edge length\nconst getAdjacentFacePerpendicularExtensions = (\n  faceId: FaceId,\n  edgePosition: 'top' | 'bottom' | 'left' | 'right',\n  existingPanels?: PanelPath[]\n): { startExt: number; endExt: number } => {\n  if (!existingPanels) return { startExt: 0, endExt: 0 };\n\n  const edges = getFaceEdges(faceId);\n  const edgeInfo = edges.find(e => e.position === edgePosition);\n  if (!edgeInfo) return { startExt: 0, endExt: 0 };\n\n  const adjacentFaceId = edgeInfo.adjacentFaceId;\n  const adjacentPanel = existingPanels.find(p => p.source.faceId === adjacentFaceId);\n  if (!adjacentPanel) return { startExt: 0, endExt: 0 };\n\n  // Map which edges of the adjacent face affect the start/end of this edge\n  // This depends on the geometric relationship between the faces\n  const perpMapping: Record<FaceId, Record<string, { start: 'top' | 'bottom' | 'left' | 'right'; end: 'top' | 'bottom' | 'left' | 'right' }>> = {\n    // For front face edges, which adjacent face edges affect start/end\n    front: {\n      top: { start: 'left', end: 'right' },      // top edge: left corner to right corner\n      bottom: { start: 'left', end: 'right' },\n      left: { start: 'top', end: 'bottom' },     // left edge: top corner to bottom corner\n      right: { start: 'top', end: 'bottom' },\n    },\n    back: {\n      top: { start: 'right', end: 'left' },      // back is mirrored\n      bottom: { start: 'right', end: 'left' },\n      left: { start: 'top', end: 'bottom' },\n      right: { start: 'top', end: 'bottom' },\n    },\n    left: {\n      top: { start: 'left', end: 'right' },\n      bottom: { start: 'left', end: 'right' },\n      left: { start: 'top', end: 'bottom' },\n      right: { start: 'top', end: 'bottom' },\n    },\n    right: {\n      top: { start: 'right', end: 'left' },      // right face orientation\n      bottom: { start: 'right', end: 'left' },\n      left: { start: 'top', end: 'bottom' },\n      right: { start: 'top', end: 'bottom' },\n    },\n    top: {\n      top: { start: 'left', end: 'right' },\n      bottom: { start: 'left', end: 'right' },\n      left: { start: 'top', end: 'bottom' },\n      right: { start: 'top', end: 'bottom' },\n    },\n    bottom: {\n      top: { start: 'left', end: 'right' },\n      bottom: { start: 'left', end: 'right' },\n      left: { start: 'bottom', end: 'top' },     // bottom face is flipped\n      right: { start: 'bottom', end: 'top' },\n    },\n  };\n\n  const mapping = perpMapping[faceId]?.[edgePosition];\n  if (!mapping) return { startExt: 0, endExt: 0 };\n\n  return {\n    startExt: adjacentPanel.edgeExtensions[mapping.start] || 0,\n    endExt: adjacentPanel.edgeExtensions[mapping.end] || 0,\n  };\n};\n\n// =============================================================================\n// Edge Status Utilities - Determine which edges are locked (finger joints) vs unlocked (straight)\n// =============================================================================\n\nexport interface EdgeStatusInfo {\n  position: 'top' | 'bottom' | 'left' | 'right';\n  adjacentFaceId?: FaceId;\n  // locked = male joint (tabs out), cannot move\n  // outward-only = female joint (slots), can extend outward only\n  // unlocked = open face (straight edge), can move in or out\n  status: 'locked' | 'outward-only' | 'unlocked';\n}\n\n// For divider panels - dividers always have slots (female joints), never tabs\nexport const getDividerEdgeStatuses = (\n  meetsTop: boolean,    // meets solid top face\n  meetsBottom: boolean,\n  meetsLeft: boolean,\n  meetsRight: boolean\n): EdgeStatusInfo[] => {\n  // Dividers always have slots (female joints) where they meet solid faces\n  // They can always extend outward on those edges\n  // Edges meeting open faces are unlocked (straight edge)\n  return [\n    { position: 'top', status: meetsTop ? 'outward-only' : 'unlocked' },\n    { position: 'bottom', status: meetsBottom ? 'outward-only' : 'unlocked' },\n    { position: 'left', status: meetsLeft ? 'outward-only' : 'unlocked' },\n    { position: 'right', status: meetsRight ? 'outward-only' : 'unlocked' },\n  ];\n};\n\n// For face panels - determine edge status based on joint type\nexport const getFaceEdgeStatuses = (\n  faceId: FaceId,\n  faces: Face[],\n  assembly: AssemblyConfig\n): EdgeStatusInfo[] => {\n  const edges = getFaceEdges(faceId);\n\n  return edges.map((edge) => {\n    const adjacentFace = faces.find((f) => f.id === edge.adjacentFaceId);\n    const isSolidAdjacent = adjacentFace?.solid ?? false;\n\n    // If adjacent face is open, edge is unlocked (straight edge)\n    if (!isSolidAdjacent) {\n      return {\n        position: edge.position,\n        adjacentFaceId: edge.adjacentFaceId,\n        status: 'unlocked' as const,\n      };\n    }\n\n    // Adjacent face is solid - check if this edge has tabs (male) or slots (female)\n    const tabsOut = shouldTabOut(faceId, edge.adjacentFaceId, assembly);\n\n    // tabsOut === true: male joint (tabs extending out) - locked\n    // tabsOut === false: female joint (slots receiving tabs) - outward-only\n    // tabsOut === null: straight edge (e.g., inset lid) - unlocked\n    let status: 'locked' | 'outward-only' | 'unlocked';\n    if (tabsOut === true) {\n      status = 'locked';\n    } else if (tabsOut === false) {\n      status = 'outward-only';\n    } else {\n      status = 'unlocked';\n    }\n\n    return {\n      position: edge.position,\n      adjacentFaceId: edge.adjacentFaceId,\n      status,\n    };\n  });\n};\n\n// Dynamic tab direction logic based on assembly configuration\nconst shouldTabOut = (\n  faceId: FaceId,\n  adjacentFaceId: FaceId,\n  assembly: AssemblyConfig\n): boolean | null => {\n  const myRole = getFaceRole(faceId, assembly.assemblyAxis);\n  const adjRole = getFaceRole(adjacentFaceId, assembly.assemblyAxis);\n\n  // Wall-to-Wall: use priority system (lower priority tabs OUT)\n  if (myRole === 'wall' && adjRole === 'wall') {\n    return getWallPriority(faceId) < getWallPriority(adjacentFaceId);\n  }\n\n  // Lid-to-Wall interactions\n  if (myRole === 'lid') {\n    const side = getLidSide(faceId, assembly.assemblyAxis);\n    if (side) {\n      return assembly.lids[side].tabDirection === 'tabs-out';\n    }\n    return false;\n  }\n\n  // Wall-to-Lid interactions\n  if (adjRole === 'lid') {\n    const side = getLidSide(adjacentFaceId, assembly.assemblyAxis);\n    if (side) {\n      if (assembly.lids[side].inset > 0) {\n        return null; // Straight edge for inset lids\n      }\n      return assembly.lids[side].tabDirection === 'tabs-in';\n    }\n    return false;\n  }\n\n  return false;\n};\n\n// Get face 3D position and rotation for rendering\nconst getFaceTransform = (\n  faceId: FaceId,\n  config: BoxConfig,\n  scale: number\n): { position: [number, number, number]; rotation: [number, number, number] } => {\n  const { width, height, depth, materialThickness, assembly } = config;\n  const halfW = (width * scale) / 2;\n  const halfH = (height * scale) / 2;\n  const halfD = (depth * scale) / 2;\n  const mt = materialThickness * scale;\n\n  // Get lid insets for positioning lid faces\n  const getLidInset = (side: 'positive' | 'negative'): number => {\n    return (assembly.lids[side].inset || 0) * scale;\n  };\n\n  // Note: Wall panels with feet extend downward from their original position.\n  // The 2D panel geometry has feet extending below -halfH, with center at (0,0).\n  // No 3D position offset is needed - the panel is already correctly positioned\n  // with top at +halfH and bottom extending down with feet.\n\n  switch (faceId) {\n    case 'front':\n      return {\n        position: [0, 0, halfD - mt / 2],\n        rotation: [0, 0, 0],\n      };\n    case 'back':\n      return {\n        position: [0, 0, -halfD + mt / 2],\n        rotation: [0, Math.PI, 0],\n      };\n    case 'left':\n      return {\n        position: [-halfW + mt / 2, 0, 0],\n        rotation: [0, -Math.PI / 2, 0],\n      };\n    case 'right':\n      return {\n        position: [halfW - mt / 2, 0, 0],\n        rotation: [0, Math.PI / 2, 0],\n      };\n    case 'top':\n      // Adjust for lid inset (moves down into the box)\n      return {\n        position: [0, halfH - mt / 2 - getLidInset('positive'), 0],\n        rotation: [-Math.PI / 2, 0, 0],\n      };\n    case 'bottom':\n      // Adjust for lid inset (moves up into the box)\n      return {\n        position: [0, -halfH + mt / 2 + getLidInset('negative'), 0],\n        rotation: [Math.PI / 2, 0, 0],\n      };\n  }\n};\n\n// =============================================================================\n// Feet Path Generation\n// =============================================================================\n\n/**\n * Generate a feet path for an edge\n * Creates two feet at the corners with a gap in the middle\n *\n * The path goes (for bottom edge, right to left):\n * 1. Down from start corner by (materialThickness + feetHeight)\n * 2. Horizontal for foot width\n * 3. Up by feetHeight (back to materialThickness level)\n * 4. Horizontal across gap to other foot\n * 5. Down by feetHeight\n * 6. Horizontal for foot width\n * 7. Up to end corner\n */\nconst generateFeetPath = (\n  startX: number,      // X position of start corner (right side for bottom edge)\n  endX: number,        // X position of end corner (left side for bottom edge)\n  baseY: number,       // Y position of the finger joint edge (original panel bottom)\n  feetConfig: { height: number; width: number; inset: number },\n  materialThickness: number\n): Point[] => {\n  const { height: feetHeight, width: footWidth, inset } = feetConfig;\n\n  // The feet extend from baseY down\n  // First extend by materialThickness to clear the joint, then by feetHeight for the feet\n  const jointClearanceY = baseY - materialThickness;  // Level where joint is cleared\n  const feetBottomY = jointClearanceY - feetHeight;   // Bottom of feet\n\n  // Foot positions (accounting for inset from panel edges)\n  // For bottom edge going right to left: startX is positive (right), endX is negative (left)\n  const rightFootOuterX = startX - inset;\n  const rightFootInnerX = rightFootOuterX - footWidth;\n  const leftFootInnerX = endX + inset + footWidth;\n  const leftFootOuterX = endX + inset;\n\n  // Generate the path points\n  const points: Point[] = [];\n\n  // Start at right corner, at the joint level (finger pattern ends here)\n  // 1. Go down to feet bottom at right foot outer edge\n  points.push({ x: rightFootOuterX, y: baseY });\n  points.push({ x: rightFootOuterX, y: feetBottomY });\n\n  // 2. Go left along feet bottom for foot width\n  points.push({ x: rightFootInnerX, y: feetBottomY });\n\n  // 3. Go up to joint clearance level\n  points.push({ x: rightFootInnerX, y: jointClearanceY });\n\n  // 4. Go left across the gap to left foot inner edge\n  points.push({ x: leftFootInnerX, y: jointClearanceY });\n\n  // 5. Go down to feet bottom\n  points.push({ x: leftFootInnerX, y: feetBottomY });\n\n  // 6. Go left along feet bottom for foot width\n  points.push({ x: leftFootOuterX, y: feetBottomY });\n\n  // 7. Go up to joint level at left corner\n  points.push({ x: leftFootOuterX, y: baseY });\n\n  return points;\n};\n\n// =============================================================================\n// Face Panel Generation\n// =============================================================================\n\nconst generateFacePanelOutline = (\n  faceId: FaceId,\n  faces: Face[],\n  config: BoxConfig,\n  edgeExtensions: EdgeExtensions = defaultEdgeExtensions,\n  existingPanels?: PanelPath[],\n  fingerData?: AssemblyFingerData | null,\n  feetEdge?: 'top' | 'bottom' | 'left' | 'right' | null,  // Which edge has feet\n  feetConfig?: { height: number; width: number; inset: number } | null\n): PathPoint[] => {\n  const dims = getFaceDimensions(faceId, config);\n  const edges = getFaceEdges(faceId);\n  const { materialThickness, fingerWidth, fingerGap, assembly } = config;\n\n  const halfW = dims.width / 2;\n  const halfH = dims.height / 2;\n\n  // Check if adjacent face has any contraction that affects the shared edge\n  // This includes both the connecting edge AND perpendicular edges that shorten the overlap\n  const getAdjacentContractions = (position: 'top' | 'bottom' | 'left' | 'right'): { direct: number; startPerp: number; endPerp: number } => {\n    const directExt = getAdjacentFaceExtension(faceId, position, existingPanels);\n    const perpExts = getAdjacentFacePerpendicularExtensions(faceId, position, existingPanels);\n    return {\n      direct: directExt,\n      startPerp: perpExts.startExt,\n      endPerp: perpExts.endExt,\n    };\n  };\n\n  // Check if adjacent face has any contraction (direct or perpendicular)\n  const adjacentHasAnyContraction = (position: 'top' | 'bottom' | 'left' | 'right'): boolean => {\n    const contractions = getAdjacentContractions(position);\n    return contractions.direct < 0 || contractions.startPerp < 0 || contractions.endPerp < 0;\n  };\n\n  // Determine which edges have tabs extending outward (locked edges)\n  const edgeHasTabs = (position: 'top' | 'bottom' | 'left' | 'right'): boolean => {\n    const edgeInfo = edges.find(e => e.position === position)!;\n    const adjacentFace = faces.find(f => f.id === edgeInfo.adjacentFaceId);\n    const isSolidAdjacent = adjacentFace?.solid ?? false;\n    const tabOut = shouldTabOut(faceId, edgeInfo.adjacentFaceId, assembly);\n    return isSolidAdjacent && tabOut === true;\n  };\n\n  // Check if edge is unlocked (straight, no finger joints)\n  const edgeIsUnlocked = (position: 'top' | 'bottom' | 'left' | 'right'): boolean => {\n    const edgeInfo = edges.find(e => e.position === position)!;\n    const adjacentFace = faces.find(f => f.id === edgeInfo.adjacentFaceId);\n    return !(adjacentFace?.solid ?? false);\n  };\n\n  // Check if edge should have finger joints (may be partial if adjacent has perpendicular contraction)\n  const edgeHasFingers = (position: 'top' | 'bottom' | 'left' | 'right'): boolean => {\n    const edgeInfo = edges.find(e => e.position === position)!;\n    const adjacentFace = faces.find(f => f.id === edgeInfo.adjacentFaceId);\n    return adjacentFace?.solid ?? false;\n  };\n\n  const topHasTabs = edgeHasTabs('top');\n  const bottomHasTabs = edgeHasTabs('bottom');\n  const leftHasTabs = edgeHasTabs('left');\n  const rightHasTabs = edgeHasTabs('right');\n\n  // Check which adjacent faces are solid (for outline calculation)\n  const topIsSolid = edgeHasFingers('top');\n  const bottomIsSolid = edgeHasFingers('bottom');\n  const leftIsSolid = edgeHasFingers('left');\n  const rightIsSolid = edgeHasFingers('right');\n\n  // Calculate extension amounts based on edge type:\n  // - Open edge (no adjacent solid face): can extend in any direction\n  // - Female joint (has slots, not tabs): can extend outward only (positive extension)\n  // - Male joint (has tabs): cannot extend\n  const getExtension = (position: 'top' | 'bottom' | 'left' | 'right', ext: number): number => {\n    const isOpen = edgeIsUnlocked(position);\n    const hasTabs = edgeHasTabs(position);\n\n    // Open face - can extend in any direction\n    if (isOpen) return ext;\n\n    // Female joint (solid adjacent, but slots not tabs) - can extend outward only\n    // Positive extensions are outward for all edges\n    if (!hasTabs && ext > 0) return ext;\n\n    // Male joint or negative extension on female joint - no extension\n    return 0;\n  };\n\n  const extTop = getExtension('top', edgeExtensions.top);\n  const extBottom = getExtension('bottom', edgeExtensions.bottom);\n  const extLeft = getExtension('left', edgeExtensions.left);\n  const extRight = getExtension('right', edgeExtensions.right);\n\n  // Finger corners - ALWAYS use full insets for consistent finger alignment\n  // This ensures fingers on perpendicular edges don't shift when a face is removed\n  // NOTE: These must NOT include extensions - finger positions must be consistent\n  // across all panels for proper joint alignment\n  const fingerCorners: Record<string, Point> = {\n    topLeft: {\n      x: -halfW + (leftHasTabs ? materialThickness : 0),\n      y: halfH - (topHasTabs ? materialThickness : 0)\n    },\n    topRight: {\n      x: halfW - (rightHasTabs ? materialThickness : 0),\n      y: halfH - (topHasTabs ? materialThickness : 0)\n    },\n    bottomRight: {\n      x: halfW - (rightHasTabs ? materialThickness : 0),\n      y: -halfH + (bottomHasTabs ? materialThickness : 0)\n    },\n    bottomLeft: {\n      x: -halfW + (leftHasTabs ? materialThickness : 0),\n      y: -halfH + (bottomHasTabs ? materialThickness : 0)\n    },\n  };\n\n  // Outline corners - account for open faces (no inset where face is removed)\n  // When an adjacent face is removed, the edge extends to the full dimension\n  const outlineCorners: Record<string, Point> = {\n    topLeft: {\n      x: -halfW + (leftIsSolid && leftHasTabs ? materialThickness : 0) - extLeft,\n      y: halfH - (topIsSolid && topHasTabs ? materialThickness : 0) + extTop\n    },\n    topRight: {\n      x: halfW - (rightIsSolid && rightHasTabs ? materialThickness : 0) + extRight,\n      y: halfH - (topIsSolid && topHasTabs ? materialThickness : 0) + extTop\n    },\n    bottomRight: {\n      x: halfW - (rightIsSolid && rightHasTabs ? materialThickness : 0) + extRight,\n      y: -halfH + (bottomIsSolid && bottomHasTabs ? materialThickness : 0) - extBottom\n    },\n    bottomLeft: {\n      x: -halfW + (leftIsSolid && leftHasTabs ? materialThickness : 0) - extLeft,\n      y: -halfH + (bottomIsSolid && bottomHasTabs ? materialThickness : 0) - extBottom\n    },\n  };\n\n  // Edge configs with both outline corners (for panel shape) and finger corners (for finger calculation)\n  const edgeConfigs = [\n    {\n      start: outlineCorners.topLeft, end: outlineCorners.topRight,\n      fingerStart: fingerCorners.topLeft, fingerEnd: fingerCorners.topRight,\n      edgeInfo: edges.find((e) => e.position === 'top')!,\n      startExt: { perpendicular: extLeft, parallel: extTop },\n      endExt: { perpendicular: extRight, parallel: extTop }\n    },\n    {\n      start: outlineCorners.topRight, end: outlineCorners.bottomRight,\n      fingerStart: fingerCorners.topRight, fingerEnd: fingerCorners.bottomRight,\n      edgeInfo: edges.find((e) => e.position === 'right')!,\n      startExt: { perpendicular: extTop, parallel: extRight },\n      endExt: { perpendicular: extBottom, parallel: extRight }\n    },\n    {\n      start: outlineCorners.bottomRight, end: outlineCorners.bottomLeft,\n      fingerStart: fingerCorners.bottomRight, fingerEnd: fingerCorners.bottomLeft,\n      edgeInfo: edges.find((e) => e.position === 'bottom')!,\n      startExt: { perpendicular: extRight, parallel: extBottom },\n      endExt: { perpendicular: extLeft, parallel: extBottom }\n    },\n    {\n      start: outlineCorners.bottomLeft, end: outlineCorners.topLeft,\n      fingerStart: fingerCorners.bottomLeft, fingerEnd: fingerCorners.topLeft,\n      edgeInfo: edges.find((e) => e.position === 'left')!,\n      startExt: { perpendicular: extBottom, parallel: extLeft },\n      endExt: { perpendicular: extTop, parallel: extLeft }\n    },\n  ];\n\n  const outlinePoints: PathPoint[] = [];\n\n  for (const { start, end, fingerStart, fingerEnd, edgeInfo, startExt, endExt } of edgeConfigs) {\n    const adjacentFace = faces.find((f) => f.id === edgeInfo.adjacentFaceId);\n    const isSolidAdjacent = adjacentFace?.solid ?? false;\n    const hasFingers = edgeHasFingers(edgeInfo.position);\n\n    // Check if this edge has been extended outward (parallel extension > 0)\n    // When extended, the outline should be straight - finger joints become slot holes\n    const hasParallelExtension = (startExt.parallel > 0) || (endExt.parallel > 0);\n    const parallelExt = startExt.parallel > 0 ? startExt.parallel : endExt.parallel;\n\n    let points: Point[];\n\n    // Use pre-calculated assembly finger points for aligned finger joints\n    // BUT NOT if the edge has been extended (those get slot holes instead)\n    if (fingerData && isSolidAdjacent && hasFingers && !hasParallelExtension) {\n      const gender = getEdgeGender(faceId, edgeInfo.position, faces, assembly);\n\n      if (gender !== null) {\n        const axis = getEdgeAxis(faceId, edgeInfo.position);\n        const axisFingerPoints = fingerData[axis];\n        const outwardDirection = getEdgeOutwardDirection(edgeInfo.position);\n\n        // Determine which perpendicular edges have tabs at low/high ends of the axis\n        // This is independent of edge direction - it's about physical position on the axis:\n        // - Horizontal edges (X axis): low=left, high=right\n        // - Vertical edges (Y axis): low=bottom, high=top\n        const isHorizontalEdge = edgeInfo.position === 'top' || edgeInfo.position === 'bottom';\n        let lowHasTabs: boolean;\n        let highHasTabs: boolean;\n        if (isHorizontalEdge) {\n          lowHasTabs = leftHasTabs;   // Low end of X axis = left side\n          highHasTabs = rightHasTabs; // High end of X axis = right side\n        } else {\n          lowHasTabs = bottomHasTabs; // Low end of Y axis = bottom side\n          highHasTabs = topHasTabs;   // High end of Y axis = top side\n        }\n\n        const { startPos, endPos } = getEdgeAxisPositions(faceId, edgeInfo.position, config, lowHasTabs, highHasTabs);\n\n        // Use fingerStart/fingerEnd for finger pattern generation (consistent alignment)\n        // Then handle any difference from outline corners as straight segments\n        const fingerPathPoints = generateFingerJointPathV2(fingerStart, fingerEnd, {\n          fingerPoints: axisFingerPoints,\n          gender,\n          materialThickness,\n          edgeStartPos: startPos,\n          edgeEndPos: endPos,\n          yUp: true,\n          outwardDirection,\n        });\n\n        // If outline corners differ from finger corners, add straight segments\n        // When connecting to an extended edge, add step transitions to full width\n        const adjustedPoints: Point[] = [];\n\n        // Add segment from outline start to finger start if different\n        const startDiffX = Math.abs(start.x - fingerStart.x);\n        const startDiffY = Math.abs(start.y - fingerStart.y);\n        if (startDiffX > 0.01 || startDiffY > 0.01) {\n          adjustedPoints.push(start);\n        }\n\n        // Add all finger path points\n        adjustedPoints.push(...fingerPathPoints);\n\n        // Add segment from finger end to outline end if different\n        const endDiffX = Math.abs(end.x - fingerEnd.x);\n        const endDiffY = Math.abs(end.y - fingerEnd.y);\n        if (endDiffX > 0.01 || endDiffY > 0.01) {\n          adjustedPoints.push(end);\n        }\n\n        points = adjustedPoints;\n      } else {\n        // Gender is null = straight edge\n        points = [start, end];\n      }\n    } else if (hasParallelExtension) {\n      // Edge with extension - straight edge (finger joints become slot holes)\n      points = [start, end];\n    } else {\n      // No finger data or not a solid adjacent face - straight edge\n      points = [start, end];\n    }\n\n    // For first edge, add all points including start\n    // For subsequent edges, check if we need to add the corner point\n    if (outlinePoints.length === 0) {\n      // First edge: add all points\n      for (let i = 0; i < points.length; i++) {\n        outlinePoints.push(points[i]);\n      }\n    } else {\n      // Subsequent edges: ensure corner continuity\n      const lastOutlinePoint = outlinePoints[outlinePoints.length - 1];\n      const edgeStartPoint = points[0];\n\n      // Check if the last outline point matches the edge start point (the corner)\n      const tolerance = 0.001;\n      const cornerMatches =\n        Math.abs(lastOutlinePoint.x - edgeStartPoint.x) < tolerance &&\n        Math.abs(lastOutlinePoint.y - edgeStartPoint.y) < tolerance;\n\n      if (!cornerMatches) {\n        // Corner doesn't match - the previous edge didn't end at the corner\n        // Add the corner point explicitly\n        outlinePoints.push(edgeStartPoint);\n      }\n\n      // Skip the first point (corner) and add the rest\n      for (let i = 1; i < points.length; i++) {\n        outlinePoints.push(points[i]);\n      }\n    }\n  }\n\n  // Post-process: Insert feet path if needed\n  // The feet replace the bottom edge segment (from bottomRight to bottomLeft)\n  if (feetEdge === 'bottom' && feetConfig) {\n    // Find the bottom corners in the outline\n    // bottomRight is around index where right edge ends / bottom edge starts\n    // bottomLeft is around index where bottom edge ends / left edge starts\n    const baseY = fingerCorners.bottomRight.y;\n\n    // Find the approximate bottomRight and bottomLeft positions\n    const bottomRightX = fingerCorners.bottomRight.x;\n    const bottomLeftX = fingerCorners.bottomLeft.x;\n\n    // Find indices of points near bottom corners\n    let bottomRightIdx = -1;\n    let bottomLeftIdx = -1;\n    const tolerance = 0.1;\n\n    for (let i = 0; i < outlinePoints.length; i++) {\n      const p = outlinePoints[i];\n      // Look for points at the bottom Y level\n      if (Math.abs(p.y - baseY) < tolerance) {\n        if (Math.abs(p.x - bottomRightX) < tolerance && bottomRightIdx === -1) {\n          bottomRightIdx = i;\n        }\n        if (Math.abs(p.x - bottomLeftX) < tolerance) {\n          bottomLeftIdx = i;\n        }\n      }\n    }\n\n    // If we found both corners, replace the segment between them with feet path\n    if (bottomRightIdx !== -1 && bottomLeftIdx !== -1 && bottomRightIdx < bottomLeftIdx) {\n      const feetPath = generateFeetPath(\n        bottomRightX,\n        bottomLeftX,\n        baseY,\n        feetConfig,\n        materialThickness\n      );\n\n      // Remove the old bottom segment and insert feet path\n      const beforeBottom = outlinePoints.slice(0, bottomRightIdx);\n      const afterBottom = outlinePoints.slice(bottomLeftIdx + 1);\n\n      // Rebuild outline: before + feet path + after\n      outlinePoints.length = 0;\n      outlinePoints.push(...beforeBottom);\n      outlinePoints.push(...feetPath);\n      outlinePoints.push(...afterBottom);\n    }\n  }\n\n  return outlinePoints;\n};\n\n// Generate slot holes for dividers that meet this face\nconst generateDividerSlotHoles = (\n  faceId: FaceId,\n  faces: Face[],\n  rootVoid: Void,\n  config: BoxConfig,\n  existingPanels?: PanelPath[],\n  fingerData?: AssemblyFingerData | null\n): PanelHole[] => {\n  const holes: PanelHole[] = [];\n  const { materialThickness, fingerWidth, fingerGap, width, height, depth, assembly } = config;\n  const subdivisions = getAllSubdivisions(rootVoid);\n  const isFaceSolid = (id: FaceId) => faces.find(f => f.id === id)?.solid ?? false;\n  const tolerance = 0.01;\n\n  // Get lid inset values based on assembly axis\n  const getLidInset = (side: 'positive' | 'negative'): number => {\n    return assembly.lids[side].inset || 0;\n  };\n\n  // Calculate boundary thresholds accounting for lid insets\n  const topInset = assembly.assemblyAxis === 'y' ? getLidInset('positive') : 0;\n  const bottomInset = assembly.assemblyAxis === 'y' ? getLidInset('negative') : 0;\n  const leftInset = assembly.assemblyAxis === 'x' ? getLidInset('negative') : 0;\n  const rightInset = assembly.assemblyAxis === 'x' ? getLidInset('positive') : 0;\n  const frontInset = assembly.assemblyAxis === 'z' ? getLidInset('positive') : 0;\n  const backInset = assembly.assemblyAxis === 'z' ? getLidInset('negative') : 0;\n\n  // Helper to get divider's edge extensions\n  const getDividerExtensions = (subId: string): EdgeExtensions => {\n    if (!existingPanels) return defaultEdgeExtensions;\n    // Match the divider panel ID format\n    const dividerPanel = existingPanels.find(p => p.id === `divider-${subId}`);\n    return dividerPanel?.edgeExtensions ?? defaultEdgeExtensions;\n  };\n\n  for (const sub of subdivisions) {\n    let slotX: number | null = null;\n    let slotY: number | null = null;\n    let slotLength: number = 0;\n    let isHorizontal: boolean = false;\n    let startInset: number = 0;  // Inset at start of slot (mm)\n    let endInset: number = 0;    // Inset at end of slot (mm)\n    let extensionStart: number = 0;  // Extension at start of slot edge\n    let extensionEnd: number = 0;    // Extension at end of slot edge\n    let slotCenterOffset: number = 0;  // Offset to center slots within bounds\n\n    const { bounds, position, axis } = sub;\n    const extensions = getDividerExtensions(sub.id);\n\n    // Helper to check if divider meets an outer face (accounting for lid insets)\n    const meetsBottom = bounds.y <= bottomInset + tolerance;\n    const meetsTop = bounds.y + bounds.h >= height - topInset - tolerance;\n    const meetsLeft = bounds.x <= leftInset + tolerance;\n    const meetsRight = bounds.x + bounds.w >= width - rightInset - tolerance;\n    const meetsBack = bounds.z <= backInset + tolerance;\n    const meetsFront = bounds.z + bounds.d >= depth - frontInset - tolerance;\n\n    // For divider edges: determine which unlocked edges affect the slot endpoints\n    // The divider's edge meeting this face - extensions on perpendicular unlocked edges affect length\n    const getExtForEdge = (edgeName: 'top' | 'bottom' | 'left' | 'right', meetsCondition: boolean): number => {\n      // If the perpendicular face is solid, edge is locked, no extension applies\n      // If perpendicular face is open, edge is unlocked, extension applies\n      return meetsCondition ? 0 : extensions[edgeName];\n    };\n\n    // Check if this subdivision touches this face\n    // For each case, calculate slotCenterOffset to position slots within sub-void bounds\n    switch (faceId) {\n      case 'front':\n        if (meetsFront) {\n          if (axis === 'x') {\n            slotX = position - width / 2;\n            slotLength = bounds.h;\n            isHorizontal = false;\n            // Vertical slot runs in Y direction - offset based on bounds.y\n            slotCenterOffset = (bounds.y + bounds.h / 2) - height / 2;\n            // Vertical slot: start=bottom, end=top\n            startInset = meetsBottom && isFaceSolid('bottom') ? materialThickness : 0;\n            endInset = meetsTop && isFaceSolid('top') ? materialThickness : 0;\n            // For X-axis divider meeting front: right edge meets front face\n            // Slot runs vertically (bottom to top), extensions: bottom/top affect length\n            extensionStart = getExtForEdge('bottom', meetsBottom && isFaceSolid('bottom'));\n            extensionEnd = getExtForEdge('top', meetsTop && isFaceSolid('top'));\n          } else if (axis === 'y') {\n            slotY = position - height / 2;\n            slotLength = bounds.w;\n            isHorizontal = true;\n            // Horizontal slot runs in X direction - offset based on bounds.x\n            slotCenterOffset = (bounds.x + bounds.w / 2) - width / 2;\n            // Horizontal slot: start=left, end=right\n            startInset = meetsLeft && isFaceSolid('left') ? materialThickness : 0;\n            endInset = meetsRight && isFaceSolid('right') ? materialThickness : 0;\n            extensionStart = getExtForEdge('left', meetsLeft && isFaceSolid('left'));\n            extensionEnd = getExtForEdge('right', meetsRight && isFaceSolid('right'));\n          }\n        }\n        break;\n      case 'back':\n        if (meetsBack) {\n          if (axis === 'x') {\n            slotX = -(position - width / 2);\n            slotLength = bounds.h;\n            isHorizontal = false;\n            // Vertical slot runs in Y direction - offset based on bounds.y\n            slotCenterOffset = (bounds.y + bounds.h / 2) - height / 2;\n            startInset = meetsBottom && isFaceSolid('bottom') ? materialThickness : 0;\n            endInset = meetsTop && isFaceSolid('top') ? materialThickness : 0;\n            extensionStart = getExtForEdge('bottom', meetsBottom && isFaceSolid('bottom'));\n            extensionEnd = getExtForEdge('top', meetsTop && isFaceSolid('top'));\n          } else if (axis === 'y') {\n            slotY = position - height / 2;\n            slotLength = bounds.w;\n            isHorizontal = true;\n            // Horizontal slot runs in X direction (mirrored) - offset based on bounds.x\n            slotCenterOffset = -((bounds.x + bounds.w / 2) - width / 2);\n            startInset = meetsLeft && isFaceSolid('left') ? materialThickness : 0;\n            endInset = meetsRight && isFaceSolid('right') ? materialThickness : 0;\n            extensionStart = getExtForEdge('left', meetsLeft && isFaceSolid('left'));\n            extensionEnd = getExtForEdge('right', meetsRight && isFaceSolid('right'));\n          }\n        }\n        break;\n      case 'left':\n        if (meetsLeft) {\n          if (axis === 'z') {\n            slotX = position - depth / 2;\n            slotLength = bounds.h;\n            isHorizontal = false;\n            // Vertical slot runs in Y direction - offset based on bounds.y\n            slotCenterOffset = (bounds.y + bounds.h / 2) - height / 2;\n            startInset = meetsBottom && isFaceSolid('bottom') ? materialThickness : 0;\n            endInset = meetsTop && isFaceSolid('top') ? materialThickness : 0;\n            extensionStart = getExtForEdge('bottom', meetsBottom && isFaceSolid('bottom'));\n            extensionEnd = getExtForEdge('top', meetsTop && isFaceSolid('top'));\n          } else if (axis === 'y') {\n            slotY = position - height / 2;\n            slotLength = bounds.d;\n            isHorizontal = true;\n            // Horizontal slot runs in Z direction - offset based on bounds.z\n            slotCenterOffset = (bounds.z + bounds.d / 2) - depth / 2;\n            // Horizontal slot on left: start=back, end=front\n            startInset = meetsBack && isFaceSolid('back') ? materialThickness : 0;\n            endInset = meetsFront && isFaceSolid('front') ? materialThickness : 0;\n            // For Y-axis divider: left edge, slots run front-to-back\n            // In divider's 2D: \"left\" corresponds to back, \"right\" to front\n            extensionStart = getExtForEdge('left', meetsBack && isFaceSolid('back'));\n            extensionEnd = getExtForEdge('right', meetsFront && isFaceSolid('front'));\n          }\n        }\n        break;\n      case 'right':\n        if (meetsRight) {\n          if (axis === 'z') {\n            slotX = -(position - depth / 2);\n            slotLength = bounds.h;\n            isHorizontal = false;\n            // Vertical slot runs in Y direction - offset based on bounds.y\n            slotCenterOffset = (bounds.y + bounds.h / 2) - height / 2;\n            startInset = meetsBottom && isFaceSolid('bottom') ? materialThickness : 0;\n            endInset = meetsTop && isFaceSolid('top') ? materialThickness : 0;\n            extensionStart = getExtForEdge('bottom', meetsBottom && isFaceSolid('bottom'));\n            extensionEnd = getExtForEdge('top', meetsTop && isFaceSolid('top'));\n          } else if (axis === 'y') {\n            slotY = position - height / 2;\n            slotLength = bounds.d;\n            isHorizontal = true;\n            // Horizontal slot runs in Z direction (mirrored) - offset based on bounds.z\n            slotCenterOffset = -((bounds.z + bounds.d / 2) - depth / 2);\n            // Horizontal slot on right: start=front, end=back (mirrored from left)\n            startInset = meetsFront && isFaceSolid('front') ? materialThickness : 0;\n            endInset = meetsBack && isFaceSolid('back') ? materialThickness : 0;\n            extensionStart = getExtForEdge('right', meetsFront && isFaceSolid('front'));\n            extensionEnd = getExtForEdge('left', meetsBack && isFaceSolid('back'));\n          }\n        }\n        break;\n      case 'top':\n        if (meetsTop) {\n          if (axis === 'x') {\n            slotX = position - width / 2;\n            slotLength = bounds.d;\n            isHorizontal = false;\n            // Vertical slot runs in Z direction (mapped to local Y) - offset based on bounds.z\n            // Top face rotation [-/2, 0, 0]: local Y  world -Z\n            // So negative slotY = positive world Z (toward front)\n            slotCenterOffset = -((bounds.z + bounds.d / 2) - depth / 2);\n            // For top: start=front (positive local Y maps to back), end=back\n            startInset = meetsFront && isFaceSolid('front') ? materialThickness : 0;\n            endInset = meetsBack && isFaceSolid('back') ? materialThickness : 0;\n            extensionStart = getExtForEdge('right', meetsFront && isFaceSolid('front'));\n            extensionEnd = getExtForEdge('left', meetsBack && isFaceSolid('back'));\n          } else if (axis === 'z') {\n            // Top face rotation [-/2, 0, 0]: local Y  world -Z\n            // To place slot at world Z = position, need slotY = -(position - depth/2)\n            slotY = -(position - depth / 2);\n            slotLength = bounds.w;\n            isHorizontal = true;\n            // Horizontal slot runs in X direction - offset based on bounds.x\n            slotCenterOffset = (bounds.x + bounds.w / 2) - width / 2;\n            startInset = meetsLeft && isFaceSolid('left') ? materialThickness : 0;\n            endInset = meetsRight && isFaceSolid('right') ? materialThickness : 0;\n            extensionStart = getExtForEdge('left', meetsLeft && isFaceSolid('left'));\n            extensionEnd = getExtForEdge('right', meetsRight && isFaceSolid('right'));\n          }\n        }\n        break;\n      case 'bottom':\n        if (meetsBottom) {\n          if (axis === 'x') {\n            slotX = position - width / 2;\n            slotLength = bounds.d;\n            isHorizontal = false;\n            // Vertical slot runs in Z direction (mapped to local Y) - offset based on bounds.z\n            // Bottom face rotation [/2, 0, 0]: local Y  world +Z\n            // So positive slotY = positive world Z (toward front)\n            slotCenterOffset = (bounds.z + bounds.d / 2) - depth / 2;\n            // For bottom: start=back (negative local Y), end=front (positive local Y)\n            startInset = meetsBack && isFaceSolid('back') ? materialThickness : 0;\n            endInset = meetsFront && isFaceSolid('front') ? materialThickness : 0;\n            extensionStart = getExtForEdge('left', meetsBack && isFaceSolid('back'));\n            extensionEnd = getExtForEdge('right', meetsFront && isFaceSolid('front'));\n          } else if (axis === 'z') {\n            // Bottom face rotation [/2, 0, 0]: local Y  world +Z\n            // To place slot at world Z = position, need slotY = position - depth/2\n            slotY = position - depth / 2;\n            slotLength = bounds.w;\n            isHorizontal = true;\n            // Horizontal slot runs in X direction - offset based on bounds.x\n            slotCenterOffset = (bounds.x + bounds.w / 2) - width / 2;\n            startInset = meetsLeft && isFaceSolid('left') ? materialThickness : 0;\n            endInset = meetsRight && isFaceSolid('right') ? materialThickness : 0;\n            extensionStart = getExtForEdge('left', meetsLeft && isFaceSolid('left'));\n            extensionEnd = getExtForEdge('right', meetsRight && isFaceSolid('right'));\n          }\n        }\n        break;\n    }\n\n    // Generate finger slot holes using V2 finger points for alignment\n    if (slotX !== null || slotY !== null) {\n      // Determine which assembly axis the slot runs along\n      // This is based on face orientation and divider axis\n      let slotAxis: 'x' | 'y' | 'z';\n      let axisDim: number;\n\n      if (isHorizontal) {\n        // Horizontal slot - determine axis based on face\n        if (faceId === 'left' || faceId === 'right') {\n          slotAxis = 'z';  // Horizontal slots on left/right run along Z\n          axisDim = depth;\n        } else {\n          slotAxis = 'x';  // Horizontal slots on front/back/top/bottom run along X\n          axisDim = width;\n        }\n      } else {\n        // Vertical slot - determine axis based on face\n        if (faceId === 'top' || faceId === 'bottom') {\n          slotAxis = 'z';  // Vertical slots on top/bottom run along Z\n          axisDim = depth;\n        } else {\n          slotAxis = 'y';  // Vertical slots on front/back/left/right run along Y\n          axisDim = height;\n        }\n      }\n\n      const maxJoint = axisDim - 2 * materialThickness;\n      const halfPanelDim = (axisDim - 2 * materialThickness) / 2;\n\n      // Use V2 finger points if available\n      if (fingerData && fingerData[slotAxis]) {\n        const axisFingerPoints = fingerData[slotAxis];\n        const { points: transitionPoints, innerOffset, fingerLength } = axisFingerPoints;\n\n        if (fingerLength > 0 && maxJoint > 2 * innerOffset) {\n          // Calculate the axis position range for this slot based on divider bounds\n          // Void bounds are in absolute box coordinates (0 to dim)\n          // Finger points use 0-based coords where 0 = interior surface (at mt from outer wall)\n          //\n          // Key insight: Same logic as getEdgeAxisInfo for divider panels:\n          // - If at wall AND meets solid face: use 0 or maxJoint\n          // - If at wall AND open face: use -mt or maxJoint + mt\n          // - If not at wall: use actual position\n          const tolerance = 0.01;\n          let boundsStart: number;  // Low end of divider along slot axis\n          let boundsEnd: number;    // High end of divider along slot axis\n\n          if (slotAxis === 'x') {\n            const atLowWall = bounds.x <= materialThickness + tolerance;\n            const atHighWall = bounds.x + bounds.w >= width - materialThickness - tolerance;\n            // startInset > 0 means divider meets solid face at low end\n            boundsStart = atLowWall ? (startInset > 0 ? 0 : -materialThickness) : (bounds.x - materialThickness);\n            boundsEnd = atHighWall ? (endInset > 0 ? maxJoint : maxJoint + materialThickness) : (bounds.x + bounds.w - materialThickness);\n          } else if (slotAxis === 'y') {\n            const atLowWall = bounds.y <= materialThickness + tolerance;\n            const atHighWall = bounds.y + bounds.h >= height - materialThickness - tolerance;\n            boundsStart = atLowWall ? (startInset > 0 ? 0 : -materialThickness) : (bounds.y - materialThickness);\n            boundsEnd = atHighWall ? (endInset > 0 ? maxJoint : maxJoint + materialThickness) : (bounds.y + bounds.h - materialThickness);\n          } else {\n            const atLowWall = bounds.z <= materialThickness + tolerance;\n            const atHighWall = bounds.z + bounds.d >= depth - materialThickness + tolerance;\n            boundsStart = atLowWall ? (startInset > 0 ? 0 : -materialThickness) : (bounds.z - materialThickness);\n            boundsEnd = atHighWall ? (endInset > 0 ? maxJoint : maxJoint + materialThickness) : (bounds.z + bounds.d - materialThickness);\n          }\n\n          // Apply divider edge extensions to the bounds range\n          // Extensions: positive = outward (grow), negative = inward (shrink)\n          // If extensionStart < 0 (shrinking), boundsStart increases (slot starts later)\n          // If extensionEnd < 0 (shrinking), boundsEnd decreases (slot ends earlier)\n          boundsStart -= extensionStart;\n          boundsEnd += extensionEnd;\n\n          // The effective range accounts for corner insets\n          // When meeting solid face, start at 0 (not -mt + mt = 0)\n          const effectiveLow = startInset > 0 ? Math.max(0, boundsStart) : boundsStart;\n          const effectiveHigh = endInset > 0 ? Math.min(maxJoint, boundsEnd) : boundsEnd;\n\n          // Generate slots at finger positions (where divider tabs will be)\n          // Finger pattern: starts with finger (OUT) at innerOffset, alternates at each transition\n          // Slots go where fingers are (even-indexed sections: 0, 2, 4, ...)\n\n          // Create section boundaries including start/end\n          const allBoundaries = [innerOffset, ...transitionPoints, maxJoint - innerOffset];\n\n          let slotIndex = 0;\n          for (let i = 0; i < allBoundaries.length - 1; i++) {\n            if (i % 2 === 0) {  // Finger section (where divider tabs go)\n              const sectionStart = allBoundaries[i];\n              const sectionEnd = allBoundaries[i + 1];\n\n              // Only include COMPLETE finger sections fully within the effective range\n              // Partial fingers/slots are not allowed - skip if section extends beyond range\n              if (sectionStart < effectiveLow || sectionEnd > effectiveHigh) continue;\n\n              // No clipping - section is fully within range\n              const clippedStart = sectionStart;\n              const clippedEnd = sectionEnd;\n\n              // Convert from 0-based axis coords to 2D panel coords (centered)\n              // 0-based coords: 0 to maxJoint\n              // 2D panel coords: -halfPanelDim to +halfPanelDim\n              // Note: Do NOT apply slotCenterOffset here. The finger positions are already\n              // in absolute coordinates (0 to maxJoint), and the effectiveLow/effectiveHigh\n              // range already accounts for where the divider actually extends.\n              // Adding slotCenterOffset would double-count the offset, causing slots to\n              // appear outside the panel bounds for nested subdivisions.\n              const offsetStart = clippedStart - maxJoint / 2;\n              const offsetEnd = clippedEnd - maxJoint / 2;\n\n              let holePoints: PathPoint[];\n              if (isHorizontal) {\n                const y = slotY!;\n                holePoints = [\n                  { x: offsetStart, y: y - materialThickness / 2 },\n                  { x: offsetEnd, y: y - materialThickness / 2 },\n                  { x: offsetEnd, y: y + materialThickness / 2 },\n                  { x: offsetStart, y: y + materialThickness / 2 },\n                ];\n              } else {\n                const x = slotX!;\n                holePoints = [\n                  { x: x - materialThickness / 2, y: offsetStart },\n                  { x: x + materialThickness / 2, y: offsetStart },\n                  { x: x + materialThickness / 2, y: offsetEnd },\n                  { x: x - materialThickness / 2, y: offsetEnd },\n                ];\n              }\n\n              holes.push({\n                id: `divider-slot-${sub.id}-${slotIndex}`,\n                type: 'slot',\n                path: { points: holePoints, closed: true },\n                source: {\n                  type: 'divider-slot',\n                  sourceId: sub.id,\n                },\n              });\n              slotIndex++;\n            }\n          }\n        }\n      } else {\n        // Fallback to V1 calculation if no finger data\n        const effectiveLength = slotLength - startInset - endInset;\n        const halfSlotLength = slotLength / 2;\n        const cornerGapBase = fingerWidth * fingerGap;\n        const maxInset = Math.max(startInset, endInset);\n        const adjustedCornerGap = Math.max(0, cornerGapBase - maxInset);\n        const usableLength = effectiveLength - (adjustedCornerGap * 2);\n\n        if (usableLength < fingerWidth) continue;\n\n        let numFingers = Math.max(1, Math.floor(usableLength / fingerWidth));\n        if (numFingers % 2 === 0) numFingers++;\n\n        const actualFingerWidth = usableLength / numFingers;\n        const actualStart = -halfSlotLength - extensionStart;\n        const actualEnd = halfSlotLength + extensionEnd;\n        const fingerRegionStart = -halfSlotLength + startInset + adjustedCornerGap;\n\n        for (let i = 0; i < numFingers; i++) {\n          if (i % 2 === 0) {\n            const patternStart = fingerRegionStart + i * actualFingerWidth;\n            const patternEnd = patternStart + actualFingerWidth;\n\n            if (patternEnd < actualStart || patternStart > actualEnd) continue;\n\n            const clippedStart = Math.max(patternStart, actualStart);\n            const clippedEnd = Math.min(patternEnd, actualEnd);\n\n            if (clippedEnd - clippedStart < 0.1) continue;\n\n            const offsetStart = clippedStart + slotCenterOffset;\n            const offsetEnd = clippedEnd + slotCenterOffset;\n\n            let holePoints: PathPoint[];\n            if (isHorizontal) {\n              const y = slotY!;\n              holePoints = [\n                { x: offsetStart, y: y - materialThickness / 2 },\n                { x: offsetEnd, y: y - materialThickness / 2 },\n                { x: offsetEnd, y: y + materialThickness / 2 },\n                { x: offsetStart, y: y + materialThickness / 2 },\n              ];\n            } else {\n              const x = slotX!;\n              holePoints = [\n                { x: x - materialThickness / 2, y: offsetStart },\n                { x: x + materialThickness / 2, y: offsetStart },\n                { x: x + materialThickness / 2, y: offsetEnd },\n                { x: x - materialThickness / 2, y: offsetEnd },\n              ];\n            }\n\n            holes.push({\n              id: `divider-slot-${sub.id}-${i}`,\n              type: 'slot',\n              path: { points: holePoints, closed: true },\n              source: {\n                type: 'divider-slot',\n                sourceId: sub.id,\n              },\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return holes;\n};\n\n// Generate slot holes for lid tabs on wall faces\nconst generateLidSlotHoles = (\n  faceId: FaceId,\n  faces: Face[],\n  config: BoxConfig\n): PanelHole[] => {\n  const holes: PanelHole[] = [];\n  const { assembly, materialThickness, fingerWidth, fingerGap, width, height, depth } = config;\n  const isFaceSolid = (id: FaceId) => faces.find(f => f.id === id)?.solid ?? false;\n\n  // Only walls get slots for lid tabs\n  if (getFaceRole(faceId, assembly.assemblyAxis) !== 'wall') return [];\n\n  const dims = getFaceDimensions(faceId, config);\n\n  for (const side of ['positive', 'negative'] as const) {\n    const lidConfig = assembly.lids[side];\n\n    // Only process if lid has tabs-out AND is inset\n    // Non-inset lids have their tabs/slots handled by edge finger joints\n    // Inset lids need internal slot holes since the wall edge is straight\n    if (lidConfig.tabDirection !== 'tabs-out') continue;\n    if (lidConfig.inset <= 0) continue;  // Skip non-inset lids\n\n    let slotPosition: number;\n    let slotLength: number;\n    let isHorizontal: boolean;\n    let startInset: number = 0;\n    let endInset: number = 0;\n\n    switch (assembly.assemblyAxis) {\n      case 'y':\n        // Top/bottom are lids\n        if (side === 'positive') {\n          slotPosition = dims.height / 2 - materialThickness / 2 - lidConfig.inset;\n        } else {\n          slotPosition = -dims.height / 2 + materialThickness / 2 + lidConfig.inset;\n        }\n        isHorizontal = true;\n        if (faceId === 'front' || faceId === 'back') {\n          slotLength = width;\n          startInset = isFaceSolid('left') ? materialThickness : 0;\n          endInset = isFaceSolid('right') ? materialThickness : 0;\n        } else {\n          slotLength = depth;\n          if (faceId === 'left') {\n            startInset = isFaceSolid('back') ? materialThickness : 0;\n            endInset = isFaceSolid('front') ? materialThickness : 0;\n          } else {\n            startInset = isFaceSolid('front') ? materialThickness : 0;\n            endInset = isFaceSolid('back') ? materialThickness : 0;\n          }\n        }\n        break;\n\n      case 'x':\n        // Left/right are lids\n        if (side === 'positive') {\n          slotPosition = dims.width / 2 - materialThickness / 2 - lidConfig.inset;\n        } else {\n          slotPosition = -dims.width / 2 + materialThickness / 2 + lidConfig.inset;\n        }\n        isHorizontal = false;\n        slotLength = height;\n        startInset = isFaceSolid('bottom') ? materialThickness : 0;\n        endInset = isFaceSolid('top') ? materialThickness : 0;\n        break;\n\n      case 'z':\n        // Front/back are lids\n        if (faceId === 'left' || faceId === 'right') {\n          if (side === 'positive') {\n            slotPosition = dims.width / 2 - materialThickness / 2 - lidConfig.inset;\n          } else {\n            slotPosition = -dims.width / 2 + materialThickness / 2 + lidConfig.inset;\n          }\n          isHorizontal = false;\n          slotLength = height;\n          startInset = isFaceSolid('bottom') ? materialThickness : 0;\n          endInset = isFaceSolid('top') ? materialThickness : 0;\n        } else {\n          if (side === 'positive') {\n            slotPosition = dims.height / 2 - materialThickness / 2 - lidConfig.inset;\n          } else {\n            slotPosition = -dims.height / 2 + materialThickness / 2 + lidConfig.inset;\n          }\n          isHorizontal = true;\n          slotLength = width;\n          startInset = isFaceSolid('left') ? materialThickness : 0;\n          endInset = isFaceSolid('right') ? materialThickness : 0;\n        }\n        break;\n\n      default:\n        continue;\n    }\n\n    // Calculate effective length (after subtracting insets)\n    const effectiveLength = slotLength - startInset - endInset;\n    const halfSlotLength = slotLength / 2;\n\n    // Use Math.max of corner insets for gap adjustment\n    const cornerGapBase = fingerWidth * fingerGap;\n    const maxInset = Math.max(startInset, endInset);\n    const adjustedCornerGap = Math.max(0, cornerGapBase - maxInset);\n\n    // Usable length for fingers\n    const usableLength = effectiveLength - (adjustedCornerGap * 2);\n\n    if (usableLength < fingerWidth) continue;  // Too short for slots\n\n    let numFingers = Math.max(1, Math.floor(usableLength / fingerWidth));\n    if (numFingers % 2 === 0) numFingers++;  // Ensure odd for symmetry\n\n    const actualFingerWidth = usableLength / numFingers;\n\n    // Starting position for finger region\n    const fingerRegionStart = -halfSlotLength + startInset + adjustedCornerGap;\n\n    for (let i = 0; i < numFingers; i++) {\n      if (i % 2 === 0) {\n        const slotStart = fingerRegionStart + i * actualFingerWidth;\n        const slotEnd = slotStart + actualFingerWidth;\n\n        let holePoints: PathPoint[];\n        if (isHorizontal) {\n          holePoints = [\n            { x: slotStart, y: slotPosition - materialThickness / 2 },\n            { x: slotEnd, y: slotPosition - materialThickness / 2 },\n            { x: slotEnd, y: slotPosition + materialThickness / 2 },\n            { x: slotStart, y: slotPosition + materialThickness / 2 },\n          ];\n        } else {\n          holePoints = [\n            { x: slotPosition - materialThickness / 2, y: slotStart },\n            { x: slotPosition + materialThickness / 2, y: slotStart },\n            { x: slotPosition + materialThickness / 2, y: slotEnd },\n            { x: slotPosition - materialThickness / 2, y: slotEnd },\n          ];\n        }\n\n        holes.push({\n          id: `lid-slot-${side}-${i}`,\n          type: 'slot',\n          path: { points: holePoints, closed: true },\n          source: {\n            type: 'lid-slot',\n            sourceId: side,\n          },\n        });\n      }\n    }\n  }\n\n  return holes;\n};\n\n// Generate slot holes for edges that have been extended outward\n// When an edge is extended (e.g., for feet or via 2D editor), the finger pattern\n// becomes slot holes at the original edge position instead of being part of the outline\nconst generateExtensionSlotHoles = (\n  faceId: FaceId,\n  faces: Face[],\n  config: BoxConfig,\n  edgeExtensions: EdgeExtensions,\n  fingerData?: AssemblyFingerData | null\n): PanelHole[] => {\n  const holes: PanelHole[] = [];\n  if (!fingerData) return holes;\n\n  const { materialThickness, assembly } = config;\n  const dims = getFaceDimensions(faceId, config);\n  const edges = getFaceEdges(faceId);\n  const halfW = dims.width / 2;\n  const halfH = dims.height / 2;\n\n  // Get extensions\n  const extTop = edgeExtensions.top ?? 0;\n  const extBottom = edgeExtensions.bottom ?? 0;\n  const extLeft = edgeExtensions.left ?? 0;\n  const extRight = edgeExtensions.right ?? 0;\n\n  // Check which perpendicular edges have tabs\n  const edgeHasTabs = (position: 'top' | 'bottom' | 'left' | 'right'): boolean => {\n    const edgeInfo = edges.find(e => e.position === position)!;\n    const adjacentFace = faces.find(f => f.id === edgeInfo.adjacentFaceId);\n    const isSolidAdjacent = adjacentFace?.solid ?? false;\n    const tabOut = shouldTabOut(faceId, edgeInfo.adjacentFaceId, assembly);\n    return isSolidAdjacent && tabOut === true;\n  };\n\n  const topHasTabs = edgeHasTabs('top');\n  const bottomHasTabs = edgeHasTabs('bottom');\n  const leftHasTabs = edgeHasTabs('left');\n  const rightHasTabs = edgeHasTabs('right');\n\n  // Process each edge\n  for (const edgeInfo of edges) {\n    const position = edgeInfo.position;\n    const adjacentFace = faces.find(f => f.id === edgeInfo.adjacentFaceId);\n    const isSolidAdjacent = adjacentFace?.solid ?? false;\n\n    // Get extension for this edge\n    const extension = edgeExtensions[position] ?? 0;\n\n    // Check if this edge is male (tabs-out) or female (slots-in)\n    // We only need slot holes for female edges - male edges lose their tabs when extended\n    // and the connection breaks (the adjacent panel would need to change, not us)\n    const tabOut = shouldTabOut(faceId, edgeInfo.adjacentFaceId, assembly);\n    // Female edge: adjacent face is solid AND we're NOT tabbing out (we receive tabs)\n    // Also need to handle tabOut === null (inset lid case) - treat as needing holes if there's extension\n    const isFemaleEdge = isSolidAdjacent && (tabOut === false || tabOut === null);\n\n    // Only generate slot holes if:\n    // 1. The edge has a positive outward extension\n    // 2. The adjacent face is solid (there would have been finger joints)\n    // 3. The edge is female (receiving tabs from adjacent panel)\n    if (extension <= 0 || !isSolidAdjacent || !isFemaleEdge) continue;\n\n    // Get the axis and finger data for this edge\n    const axis = getEdgeAxis(faceId, position);\n    const axisFingerPoints = fingerData[axis];\n    if (!axisFingerPoints) continue;\n\n    const { points: transitionPoints, innerOffset, fingerLength } = axisFingerPoints;\n    if (fingerLength <= 0) continue;\n\n    // Determine which perpendicular edges have tabs\n    const isHorizontalEdge = position === 'top' || position === 'bottom';\n    let lowHasTabs: boolean;\n    let highHasTabs: boolean;\n    if (isHorizontalEdge) {\n      lowHasTabs = leftHasTabs;\n      highHasTabs = rightHasTabs;\n    } else {\n      lowHasTabs = bottomHasTabs;\n      highHasTabs = topHasTabs;\n    }\n\n    // Calculate the edge positions in axis coordinates\n    const { startPos, endPos } = getEdgeAxisPositions(faceId, position, config, lowHasTabs, highHasTabs);\n    // Normalize to minPos/maxPos since edge direction varies (bottom/right edges run in negative direction)\n    const minPos = Math.min(startPos, endPos);\n    const maxPos = Math.max(startPos, endPos);\n\n    // Calculate the slot position (perpendicular to the edge, at the original edge position)\n    // The original edge position is at halfW or halfH minus the extension\n    // But actually, slots should be inset by materialThickness/2 from the original edge\n    let slotPosition: number;\n    switch (position) {\n      case 'top':\n        // Original top edge was at halfH, now extended to halfH + extTop\n        // Slot center should be at the original edge position: halfH - mt/2 (for mt-wide slot centered on edge)\n        slotPosition = halfH - materialThickness / 2;\n        break;\n      case 'bottom':\n        slotPosition = -halfH + materialThickness / 2;\n        break;\n      case 'right':\n        slotPosition = halfW - materialThickness / 2;\n        break;\n      case 'left':\n        slotPosition = -halfW + materialThickness / 2;\n        break;\n    }\n\n    // Determine axis dimension for calculating maxJoint\n    let axisDim: number;\n    switch (axis) {\n      case 'x': axisDim = config.width; break;\n      case 'y': axisDim = config.height; break;\n      case 'z': axisDim = config.depth; break;\n    }\n    const maxJoint = axisDim - 2 * materialThickness;\n\n    // Create section boundaries\n    const allBoundaries = [innerOffset, ...transitionPoints, maxJoint - innerOffset];\n\n    // Generate slots at finger positions (even-indexed sections where tabs go)\n    let slotIndex = 0;\n    for (let i = 0; i < allBoundaries.length - 1; i++) {\n      if (i % 2 === 0) {  // Finger/tab section\n        const sectionStart = allBoundaries[i];\n        const sectionEnd = allBoundaries[i + 1];\n\n        // Check if section is within the edge range (using normalized min/max)\n        if (sectionStart < minPos || sectionEnd > maxPos) continue;\n\n        // Convert from axis coords (0 to maxJoint) to 2D panel coords (centered)\n        const halfPanelDim = isHorizontalEdge ? halfW - materialThickness : halfH - materialThickness;\n        const offsetStart = sectionStart - maxJoint / 2;\n        const offsetEnd = sectionEnd - maxJoint / 2;\n\n        let holePoints: PathPoint[];\n        if (isHorizontalEdge) {\n          // Horizontal edge (top/bottom): slot runs horizontally\n          holePoints = [\n            { x: offsetStart, y: slotPosition - materialThickness / 2 },\n            { x: offsetEnd, y: slotPosition - materialThickness / 2 },\n            { x: offsetEnd, y: slotPosition + materialThickness / 2 },\n            { x: offsetStart, y: slotPosition + materialThickness / 2 },\n          ];\n        } else {\n          // Vertical edge (left/right): slot runs vertically\n          holePoints = [\n            { x: slotPosition - materialThickness / 2, y: offsetStart },\n            { x: slotPosition + materialThickness / 2, y: offsetStart },\n            { x: slotPosition + materialThickness / 2, y: offsetEnd },\n            { x: slotPosition - materialThickness / 2, y: offsetEnd },\n          ];\n        }\n\n        holes.push({\n          id: `extension-slot-${faceId}-${position}-${slotIndex}`,\n          type: 'slot',\n          path: { points: holePoints, closed: true },\n          source: {\n            type: 'extension-slot',\n            sourceId: `${faceId}-${position}`,\n          },\n        });\n        slotIndex++;\n      }\n    }\n  }\n\n  return holes;\n};\n\nconst generateFacePanel = (\n  faceId: FaceId,\n  faces: Face[],\n  rootVoid: Void,\n  config: BoxConfig,\n  scale: number = 1,\n  existingExtensions?: EdgeExtensions,\n  existingPanels?: PanelPath[],\n  fingerData?: AssemblyFingerData | null\n): PanelPath | null => {\n  const face = faces.find((f) => f.id === faceId);\n  if (!face || !face.solid) return null;\n\n  const extensions = existingExtensions ?? defaultEdgeExtensions;\n\n  // Determine if this panel should have feet\n  const feetConfig = config.assembly.feet;\n  const isWall = getFaceRole(faceId, config.assembly.assemblyAxis) === 'wall';\n  const shouldHaveFeet = feetConfig?.enabled && feetConfig.height > 0 && isWall &&\n    (config.assembly.assemblyAxis === 'y' || config.assembly.assemblyAxis === 'x');\n\n  // Determine feet edge (bottom edge for Y and X axis assemblies)\n  const feetEdge = shouldHaveFeet ? 'bottom' as const : null;\n  const feetParams = shouldHaveFeet && feetConfig ? {\n    height: feetConfig.height,\n    width: feetConfig.width,\n    inset: feetConfig.inset,\n  } : null;\n\n  const dims = getFaceDimensions(faceId, config);\n\n  // Calculate feet extension FIRST so we can use it for slot hole generation\n  const feetExtension = shouldHaveFeet && feetConfig ? (config.materialThickness + feetConfig.height) : 0;\n\n  // Create extensions that include feet for slot hole generation\n  const extensionsWithFeet: EdgeExtensions = shouldHaveFeet ? {\n    ...extensions,\n    bottom: (extensions.bottom ?? 0) + feetExtension,\n  } : { ...extensions };\n\n  const outlinePoints = generateFacePanelOutline(\n    faceId, faces, config, extensions, existingPanels, fingerData,\n    feetEdge, feetParams\n  );\n  const dividerHoles = generateDividerSlotHoles(faceId, faces, rootVoid, config, existingPanels, fingerData);\n  const lidHoles = generateLidSlotHoles(faceId, faces, config, fingerData);\n  // Pass extensionsWithFeet so slot holes are generated for feet edge\n  const extensionHoles = generateExtensionSlotHoles(faceId, faces, config, extensionsWithFeet, fingerData);\n  const { position, rotation } = getFaceTransform(faceId, config, scale);\n\n  const source: PanelSource = {\n    type: 'face',\n    faceId,\n  };\n\n  // Calculate actual dimensions including all extensions and feet\n  const actualWidth = dims.width + (extensions.left ?? 0) + (extensions.right ?? 0);\n  const actualHeight = dims.height + (extensions.top ?? 0) + (extensions.bottom ?? 0) + feetExtension;\n\n  return {\n    id: `face-${faceId}`,\n    source,\n    outline: { points: outlinePoints, closed: true },\n    holes: [...dividerHoles, ...lidHoles, ...extensionHoles],\n    width: actualWidth,\n    height: actualHeight,\n    thickness: config.materialThickness,\n    position,\n    rotation,\n    label: faceId.toUpperCase(),\n    visible: true,\n    edgeExtensions: extensionsWithFeet,\n  };\n};\n\n// =============================================================================\n// Divider Panel Generation\n// =============================================================================\n\n// Generate slot holes in a divider panel where child dividers connect\nconst generateDividerToSlotHoles = (\n  subdivision: { id: string; axis: 'x' | 'y' | 'z'; position: number; bounds: any },\n  allSubdivisions: { id: string; axis: 'x' | 'y' | 'z'; position: number; bounds: any }[],\n  config: BoxConfig,\n  faces: Face[]\n): PanelHole[] => {\n  const holes: PanelHole[] = [];\n  const { materialThickness, fingerWidth, fingerGap, width, height, depth } = config;\n  const mt = materialThickness;\n  const tolerance = 0.01;\n  const { bounds, axis, position } = subdivision;\n  const isFaceSolid = (faceId: FaceId) => faces.find(f => f.id === faceId)?.solid ?? false;\n\n  // Find child dividers that connect to this divider\n  // A child divider connects if:\n  // 1. It's on a perpendicular axis\n  // 2. One of its bounds edges (adjusted for mt/2) equals this divider's position\n  // 3. Its position falls within this divider's bounds on that axis\n\n  for (const child of allSubdivisions) {\n    if (child.id === subdivision.id) continue;\n    if (child.axis === axis) continue; // Must be perpendicular\n\n    let connectsToThis = false;\n    let slotPosition: number = 0; // Position along this divider's surface (in panel local coords)\n    let slotLength: number = 0;\n    let cornerInsetStart: number = 0; // Inset at start of slot (if child meets outer face)\n    let cornerInsetEnd: number = 0;   // Inset at end of slot (if child meets outer face)\n    let isHorizontal: boolean = false;\n\n    // Check if child's bounds edge (with mt/2 adjustment) matches this divider's position\n    // Child bounds are offset by mt/2 from the actual divider positions:\n    // - child.bounds start edge corresponds to divider at (bounds.start - mt/2)\n    // - child.bounds end edge corresponds to divider at (bounds.end + mt/2)\n\n    switch (axis) {\n      case 'y':\n        // This is a Y-axis divider (horizontal shelf) at `position` on Y-axis\n        // Panel dimensions: width = bounds.w (X), height = bounds.d (Z)\n        // Child X-axis dividers connect if their Y-bounds edge touches this Y position\n        if (child.axis === 'x') {\n          // Check if child's Y bounds edge (adjusted) matches this divider's Y position\n          const childYMin = child.bounds.y - mt / 2;\n          const childYMax = child.bounds.y + child.bounds.h + mt / 2;\n\n          if (Math.abs(childYMin - position) < tolerance || Math.abs(childYMax - position) < tolerance) {\n            if (bounds.x <= child.position && child.position <= bounds.x + bounds.w) {\n              connectsToThis = true;\n              slotPosition = child.position - (bounds.x + bounds.w / 2);\n              // Child X-divider's edge runs along Z; check if it meets back/front outer faces\n              slotLength = child.bounds.d;\n              // Child's \"left\" edge (in panel coords) is back face, \"right\" is front face\n              cornerInsetStart = (isFaceSolid('back') && child.bounds.z <= tolerance) ? mt : 0;\n              cornerInsetEnd = (isFaceSolid('front') && child.bounds.z + child.bounds.d >= depth - tolerance) ? mt : 0;\n              isHorizontal = false;\n            }\n          }\n        } else if (child.axis === 'z') {\n          const childYMin = child.bounds.y - mt / 2;\n          const childYMax = child.bounds.y + child.bounds.h + mt / 2;\n\n          if (Math.abs(childYMin - position) < tolerance || Math.abs(childYMax - position) < tolerance) {\n            if (bounds.z <= child.position && child.position <= bounds.z + bounds.d) {\n              connectsToThis = true;\n              slotPosition = child.position - (bounds.z + bounds.d / 2);\n              slotLength = child.bounds.w;\n              // Child Z-divider's edge runs along X; check if it meets left/right outer faces\n              cornerInsetStart = (isFaceSolid('left') && child.bounds.x <= tolerance) ? mt : 0;\n              cornerInsetEnd = (isFaceSolid('right') && child.bounds.x + child.bounds.w >= width - tolerance) ? mt : 0;\n              isHorizontal = true;\n            }\n          }\n        }\n        break;\n\n      case 'x':\n        // This is an X-axis divider (vertical partition) at `position` on X-axis\n        // Panel dimensions: width = bounds.d (Z), height = bounds.h (Y)\n        if (child.axis === 'y') {\n          const childXMin = child.bounds.x - mt / 2;\n          const childXMax = child.bounds.x + child.bounds.w + mt / 2;\n\n          if (Math.abs(childXMin - position) < tolerance || Math.abs(childXMax - position) < tolerance) {\n            if (bounds.y <= child.position && child.position <= bounds.y + bounds.h) {\n              connectsToThis = true;\n              slotPosition = child.position - (bounds.y + bounds.h / 2);\n              slotLength = child.bounds.d;\n              // Child Y-divider's edge runs along Z; check if it meets back/front outer faces\n              cornerInsetStart = (isFaceSolid('back') && child.bounds.z <= tolerance) ? mt : 0;\n              cornerInsetEnd = (isFaceSolid('front') && child.bounds.z + child.bounds.d >= depth - tolerance) ? mt : 0;\n              isHorizontal = true;\n            }\n          }\n        } else if (child.axis === 'z') {\n          const childXMin = child.bounds.x - mt / 2;\n          const childXMax = child.bounds.x + child.bounds.w + mt / 2;\n\n          if (Math.abs(childXMin - position) < tolerance || Math.abs(childXMax - position) < tolerance) {\n            if (bounds.z <= child.position && child.position <= bounds.z + bounds.d) {\n              connectsToThis = true;\n              slotPosition = child.position - (bounds.z + bounds.d / 2);\n              slotLength = child.bounds.h;\n              // Child Z-divider's edge runs along Y; check if it meets top/bottom outer faces\n              cornerInsetStart = (isFaceSolid('bottom') && child.bounds.y <= tolerance) ? mt : 0;\n              cornerInsetEnd = (isFaceSolid('top') && child.bounds.y + child.bounds.h >= height - tolerance) ? mt : 0;\n              isHorizontal = false;\n            }\n          }\n        }\n        break;\n\n      case 'z':\n        // This is a Z-axis divider at `position` on Z-axis\n        // Panel dimensions: width = bounds.w (X), height = bounds.h (Y)\n        if (child.axis === 'x') {\n          const childZMin = child.bounds.z - mt / 2;\n          const childZMax = child.bounds.z + child.bounds.d + mt / 2;\n\n          if (Math.abs(childZMin - position) < tolerance || Math.abs(childZMax - position) < tolerance) {\n            if (bounds.x <= child.position && child.position <= bounds.x + bounds.w) {\n              connectsToThis = true;\n              slotPosition = child.position - (bounds.x + bounds.w / 2);\n              slotLength = child.bounds.h;\n              // Child X-divider's edge runs along Y; check if it meets top/bottom outer faces\n              cornerInsetStart = (isFaceSolid('bottom') && child.bounds.y <= tolerance) ? mt : 0;\n              cornerInsetEnd = (isFaceSolid('top') && child.bounds.y + child.bounds.h >= height - tolerance) ? mt : 0;\n              isHorizontal = false;\n            }\n          }\n        } else if (child.axis === 'y') {\n          const childZMin = child.bounds.z - mt / 2;\n          const childZMax = child.bounds.z + child.bounds.d + mt / 2;\n\n          if (Math.abs(childZMin - position) < tolerance || Math.abs(childZMax - position) < tolerance) {\n            if (bounds.y <= child.position && child.position <= bounds.y + bounds.h) {\n              connectsToThis = true;\n              slotPosition = child.position - (bounds.y + bounds.h / 2);\n              slotLength = child.bounds.w;\n              // Child Y-divider's edge runs along X; check if it meets left/right outer faces\n              cornerInsetStart = (isFaceSolid('left') && child.bounds.x <= tolerance) ? mt : 0;\n              cornerInsetEnd = (isFaceSolid('right') && child.bounds.x + child.bounds.w >= width - tolerance) ? mt : 0;\n              isHorizontal = true;\n            }\n          }\n        }\n        break;\n    }\n\n    if (connectsToThis && slotLength > 0) {\n      // Calculate effective edge length (same as child's finger pattern)\n      // Account for corner insets where child meets outer faces\n      const effectiveLength = slotLength - cornerInsetStart - cornerInsetEnd;\n      const halfEffectiveLength = effectiveLength / 2;\n\n      // Use the same corner gap adjustment as the finger pattern\n      const maxCornerInset = Math.max(cornerInsetStart, cornerInsetEnd);\n      const adjustedGapMultiplier = Math.max(0, fingerGap - maxCornerInset / fingerWidth);\n      const cornerGap = adjustedGapMultiplier * fingerWidth;\n      const usableLength = effectiveLength - cornerGap * 2;\n\n      if (usableLength < fingerWidth) continue;\n\n      let numFingers = Math.max(1, Math.floor(usableLength / fingerWidth));\n      if (numFingers % 2 === 0) numFingers++;\n\n      const actualFingerWidth = usableLength / numFingers;\n\n      // Center offset: the effective region is shifted by (cornerInsetStart - cornerInsetEnd) / 2\n      const centerOffset = (cornerInsetStart - cornerInsetEnd) / 2;\n      const fingerRegionStart = -halfEffectiveLength + cornerGap + centerOffset;\n\n      for (let i = 0; i < numFingers; i++) {\n        if (i % 2 === 0) {\n          const slotStart = fingerRegionStart + i * actualFingerWidth;\n          const slotEnd = slotStart + actualFingerWidth;\n\n          let holePoints: PathPoint[];\n          if (isHorizontal) {\n            holePoints = [\n              { x: slotStart, y: slotPosition - materialThickness / 2 },\n              { x: slotEnd, y: slotPosition - materialThickness / 2 },\n              { x: slotEnd, y: slotPosition + materialThickness / 2 },\n              { x: slotStart, y: slotPosition + materialThickness / 2 },\n            ];\n          } else {\n            holePoints = [\n              { x: slotPosition - materialThickness / 2, y: slotStart },\n              { x: slotPosition + materialThickness / 2, y: slotStart },\n              { x: slotPosition + materialThickness / 2, y: slotEnd },\n              { x: slotPosition - materialThickness / 2, y: slotEnd },\n            ];\n          }\n\n          holes.push({\n            id: `divider-slot-${subdivision.id}-${child.id}-${i}`,\n            type: 'slot',\n            path: { points: holePoints, closed: true },\n            source: {\n              type: 'divider-slot',\n              sourceId: child.id,\n            },\n          });\n        }\n      }\n    }\n  }\n\n  return holes;\n};\n\nconst generateDividerPanel = (\n  subdivision: { id: string; axis: 'x' | 'y' | 'z'; position: number; bounds: any },\n  faces: Face[],\n  config: BoxConfig,\n  scale: number = 1,\n  existingExtensions?: EdgeExtensions,\n  allSubdivisions?: { id: string; axis: 'x' | 'y' | 'z'; position: number; bounds: any }[],\n  fingerData?: AssemblyFingerData | null\n): PanelPath => {\n  const { materialThickness, fingerWidth, fingerGap, width, height, depth, assembly } = config;\n  const { bounds, axis, position } = subdivision;\n  const isFaceSolid = (faceId: FaceId) => faces.find(f => f.id === faceId)?.solid ?? false;\n  const tolerance = 0.01;\n  const extensions = existingExtensions ?? defaultEdgeExtensions;\n\n  // Get lid inset values based on assembly axis\n  // These affect where the divider \"meets\" a lid face\n  const getLidInset = (side: 'positive' | 'negative'): number => {\n    return assembly.lids[side].inset || 0;\n  };\n\n  // Calculate boundary thresholds accounting for lid insets\n  // For Y-axis assembly: top/bottom are lids\n  // For X-axis assembly: left/right are lids\n  // For Z-axis assembly: front/back are lids\n  const topInset = assembly.assemblyAxis === 'y' ? getLidInset('positive') : 0;\n  const bottomInset = assembly.assemblyAxis === 'y' ? getLidInset('negative') : 0;\n  const leftInset = assembly.assemblyAxis === 'x' ? getLidInset('negative') : 0;\n  const rightInset = assembly.assemblyAxis === 'x' ? getLidInset('positive') : 0;\n  const frontInset = assembly.assemblyAxis === 'z' ? getLidInset('positive') : 0;\n  const backInset = assembly.assemblyAxis === 'z' ? getLidInset('negative') : 0;\n\n  // Check if an edge meets another divider panel\n  // edgeAxis: the axis perpendicular to the edge (the axis another divider would need to be on)\n  // edgePosition: the position along that axis where this edge is\n  // thisPosition: this divider's position on its own axis (for checking bounds overlap)\n  // thisAxis: this divider's axis\n  const meetsOtherDivider = (\n    edgeAxis: 'x' | 'y' | 'z',\n    edgePosition: number,\n    thisPosition: number,\n    thisAxis: 'x' | 'y' | 'z'\n  ): boolean => {\n    if (!allSubdivisions) return false;\n\n    for (const other of allSubdivisions) {\n      if (other.id === subdivision.id) continue; // Skip self\n      if (other.axis !== edgeAxis) continue; // Must be on the perpendicular axis\n\n      // Check if other divider's position matches this edge's position\n      if (Math.abs(other.position - edgePosition) > tolerance) continue;\n\n      // Check if other divider's bounds contain this divider's position\n      // The other divider's bounds define where it exists, and this divider\n      // must pass through that space\n      let containsThis = false;\n      switch (thisAxis) {\n        case 'x':\n          // This is an X-axis divider at position `thisPosition` on X\n          // Other divider must have bounds that span this X position\n          containsThis = other.bounds.x <= thisPosition && thisPosition <= other.bounds.x + other.bounds.w;\n          break;\n        case 'y':\n          // This is a Y-axis divider at position `thisPosition` on Y\n          containsThis = other.bounds.y <= thisPosition && thisPosition <= other.bounds.y + other.bounds.h;\n          break;\n        case 'z':\n          // This is a Z-axis divider at position `thisPosition` on Z\n          containsThis = other.bounds.z <= thisPosition && thisPosition <= other.bounds.z + other.bounds.d;\n          break;\n      }\n\n      if (containsThis) return true;\n    }\n    return false;\n  };\n\n  // Calculate panel dimensions based on axis\n  let panelWidth: number;\n  let panelHeight: number;\n\n  // Track outer face contacts separately from divider contacts\n  // - meetsFace*: edge meets a solid outer face (panel corners should be inset)\n  // - meetsDivider*: edge meets another divider (no corner inset, but has finger joints)\n  // - meetsTop/Bottom/Left/Right: combined (has finger joints)\n  let meetsFaceTop: boolean;\n  let meetsFaceBottom: boolean;\n  let meetsFaceLeft: boolean;\n  let meetsFaceRight: boolean;\n  let meetsDividerTop: boolean;\n  let meetsDividerBottom: boolean;\n  let meetsDividerLeft: boolean;\n  let meetsDividerRight: boolean;\n\n  // When checking if an edge meets another divider, we need to account for material thickness.\n  // The bounds are offset from split positions by mt/2:\n  // - For \"start\" edges (bounds.x, bounds.y, bounds.z): the divider is at edge - mt/2\n  // - For \"end\" edges (bounds.x + bounds.w, etc.): the divider is at edge + mt/2\n  const mt = materialThickness;\n\n  switch (axis) {\n    case 'x':\n      panelWidth = bounds.d;\n      panelHeight = bounds.h;\n      // Check outer faces separately from other dividers\n      // Account for lid insets: divider meets lid if it reaches the inset position\n      meetsFaceTop = isFaceSolid('top') && bounds.y + bounds.h >= height - topInset - tolerance;\n      meetsFaceBottom = isFaceSolid('bottom') && bounds.y <= bottomInset + tolerance;\n      meetsFaceLeft = isFaceSolid('back') && bounds.z <= backInset + tolerance;\n      meetsFaceRight = isFaceSolid('front') && bounds.z + bounds.d >= depth - frontInset - tolerance;\n      // For divider checks, adjust edge positions by mt/2 to match divider positions\n      meetsDividerTop = meetsOtherDivider('y', bounds.y + bounds.h + mt / 2, position, axis);\n      meetsDividerBottom = meetsOtherDivider('y', bounds.y - mt / 2, position, axis);\n      meetsDividerLeft = meetsOtherDivider('z', bounds.z - mt / 2, position, axis);\n      meetsDividerRight = meetsOtherDivider('z', bounds.z + bounds.d + mt / 2, position, axis);\n      break;\n    case 'y':\n      panelWidth = bounds.w;\n      panelHeight = bounds.d;\n      // Y-axis dividers: top/bottom mapped to back/front, left/right mapped to left/right\n      meetsFaceTop = isFaceSolid('back') && bounds.z <= backInset + tolerance;\n      meetsFaceBottom = isFaceSolid('front') && bounds.z + bounds.d >= depth - frontInset - tolerance;\n      meetsFaceLeft = isFaceSolid('left') && bounds.x <= leftInset + tolerance;\n      meetsFaceRight = isFaceSolid('right') && bounds.x + bounds.w >= width - rightInset - tolerance;\n      meetsDividerTop = meetsOtherDivider('z', bounds.z - mt / 2, position, axis);\n      meetsDividerBottom = meetsOtherDivider('z', bounds.z + bounds.d + mt / 2, position, axis);\n      meetsDividerLeft = meetsOtherDivider('x', bounds.x - mt / 2, position, axis);\n      meetsDividerRight = meetsOtherDivider('x', bounds.x + bounds.w + mt / 2, position, axis);\n      break;\n    case 'z':\n    default:\n      panelWidth = bounds.w;\n      panelHeight = bounds.h;\n      // Account for lid insets\n      meetsFaceTop = isFaceSolid('top') && bounds.y + bounds.h >= height - topInset - tolerance;\n      meetsFaceBottom = isFaceSolid('bottom') && bounds.y <= bottomInset + tolerance;\n      meetsFaceLeft = isFaceSolid('left') && bounds.x <= leftInset + tolerance;\n      meetsFaceRight = isFaceSolid('right') && bounds.x + bounds.w >= width - rightInset - tolerance;\n      meetsDividerTop = meetsOtherDivider('y', bounds.y + bounds.h + mt / 2, position, axis);\n      meetsDividerBottom = meetsOtherDivider('y', bounds.y - mt / 2, position, axis);\n      meetsDividerLeft = meetsOtherDivider('x', bounds.x - mt / 2, position, axis);\n      meetsDividerRight = meetsOtherDivider('x', bounds.x + bounds.w + mt / 2, position, axis);\n      break;\n  }\n\n  // Combined: has finger joints if meets either face or divider\n  const meetsTop = meetsFaceTop || meetsDividerTop;\n  const meetsBottom = meetsFaceBottom || meetsDividerBottom;\n  const meetsLeft = meetsFaceLeft || meetsDividerLeft;\n  const meetsRight = meetsFaceRight || meetsDividerRight;\n\n  const halfW = panelWidth / 2;\n  const halfH = panelHeight / 2;\n\n  // Calculate extension amounts (only apply to unlocked/straight edges)\n  const extTop = !meetsTop ? extensions.top : 0;\n  const extBottom = !meetsBottom ? extensions.bottom : 0;\n  const extLeft = !meetsLeft ? extensions.left : 0;\n  const extRight = !meetsRight ? extensions.right : 0;\n\n  // Original corners (without extensions) - used for finger pattern calculation\n  // Corner insets only apply when meeting OUTER FACES (not other dividers)\n  // When meeting another divider, the panel extends to its full size\n  const origCorners: Record<string, Point> = {\n    topLeft: {\n      x: -halfW + (meetsFaceLeft ? materialThickness : 0),\n      y: halfH - (meetsFaceTop ? materialThickness : 0),\n    },\n    topRight: {\n      x: halfW - (meetsFaceRight ? materialThickness : 0),\n      y: halfH - (meetsFaceTop ? materialThickness : 0),\n    },\n    bottomRight: {\n      x: halfW - (meetsFaceRight ? materialThickness : 0),\n      y: -halfH + (meetsFaceBottom ? materialThickness : 0),\n    },\n    bottomLeft: {\n      x: -halfW + (meetsFaceLeft ? materialThickness : 0),\n      y: -halfH + (meetsFaceBottom ? materialThickness : 0),\n    },\n  };\n\n  // Actual corners with extensions applied\n  const corners: Record<string, Point> = {\n    topLeft: {\n      x: origCorners.topLeft.x - extLeft,\n      y: origCorners.topLeft.y + extTop,\n    },\n    topRight: {\n      x: origCorners.topRight.x + extRight,\n      y: origCorners.topRight.y + extTop,\n    },\n    bottomRight: {\n      x: origCorners.bottomRight.x + extRight,\n      y: origCorners.bottomRight.y - extBottom,\n    },\n    bottomLeft: {\n      x: origCorners.bottomLeft.x - extLeft,\n      y: origCorners.bottomLeft.y - extBottom,\n    },\n  };\n\n  // Calculate original edge lengths (for finger pattern generation)\n  const origTopLength = Math.abs(origCorners.topRight.x - origCorners.topLeft.x);\n  const origBottomLength = Math.abs(origCorners.bottomRight.x - origCorners.bottomLeft.x);\n  const origLeftLength = Math.abs(origCorners.topLeft.y - origCorners.bottomLeft.y);\n  const origRightLength = Math.abs(origCorners.topRight.y - origCorners.bottomRight.y);\n\n  // For each edge, calculate the patternOffset (how far into the original pattern to start)\n  // When an edge shrinks (negative extension), the start moves inward, so patternOffset is positive\n  // patternOffset = -extension (convert negative shrink to positive offset)\n  //\n  // Top edge: goes leftright. If left is unlocked, left extension affects start\n  // Right edge: goes topbottom. If top is unlocked, top extension affects start\n  // Bottom edge: goes rightleft. If right is unlocked, right extension affects start\n  // Left edge: goes bottomtop. If bottom is unlocked, bottom extension affects start\n\n  // Determine which axis finger points to use for each edge based on divider orientation\n  // and calculate axis positions for V2 finger generation.\n  //\n  // IMPORTANT: Axis positions use a 0-based coordinate system matching face panels:\n  // - 0 = start of finger region (at interior wall, after corner inset)\n  // - maxJoint = end of finger region\n  // - -mt or maxJoint + mt when perpendicular edge is open (extends beyond finger region)\n  //\n  // The perpendicular meetsFace flags determine whether corners are inset (same as face panels).\n  const getEdgeAxisInfo = (edgePos: 'top' | 'bottom' | 'left' | 'right'): {\n    axis: 'x' | 'y' | 'z';\n    startPos: number;\n    endPos: number;\n  } => {\n    const isHorizontal = edgePos === 'top' || edgePos === 'bottom';\n    const mt = materialThickness;\n    const tolerance = 0.001;\n\n    // Calculate maxJoint for each axis\n    const maxJointX = width - 2 * mt;\n    const maxJointY = height - 2 * mt;\n    const maxJointZ = depth - 2 * mt;\n\n    // Helper to calculate axis positions using the same 0-based system as face panels\n    const calcAxisPositions = (\n      boundsLow: number,      // bounds.x/y/z (in box coords)\n      boundsSize: number,     // bounds.w/h/d\n      maxJoint: number,       // maxJoint for this axis\n      axisDim: number,        // width/height/depth\n      meetsLow: boolean,      // meetsFace at low end (left/bottom/back)\n      meetsHigh: boolean      // meetsFace at high end (right/top/front)\n    ): { startPos: number; endPos: number } => {\n      // Check if divider reaches each wall (interior surface at mt from outer edge)\n      const atLowWall = boundsLow <= mt + tolerance;\n      const atHighWall = boundsLow + boundsSize >= axisDim - mt - tolerance;\n\n      let startPos: number;\n      let endPos: number;\n\n      // Low end (left/bottom side of axis) - same logic as face panels\n      if (atLowWall) {\n        // Divider is at the wall - use face panel logic\n        // meetsLow = true means perpendicular face is solid, corner is inset, use 0\n        // meetsLow = false means perpendicular face is open, panel extends to edge, use -mt\n        startPos = meetsLow ? 0 : -mt;\n      } else {\n        // Divider doesn't reach the wall - use actual position in 0-based coords\n        startPos = boundsLow - mt;\n      }\n\n      // High end (right/top side of axis) - same logic as face panels\n      if (atHighWall) {\n        // Divider is at the wall - use face panel logic\n        endPos = meetsHigh ? maxJoint : maxJoint + mt;\n      } else {\n        // Divider doesn't reach the wall - use actual position in 0-based coords\n        endPos = boundsLow + boundsSize - mt;\n      }\n\n      return { startPos, endPos };\n    };\n\n    // Map divider axis + edge position to assembly axis and bounds positions\n    switch (axis) {\n      case 'x': // YZ plane divider - width=depth(Z), height=height(Y)\n        if (isHorizontal) {\n          // Horizontal edges run along Z axis\n          const { startPos, endPos } = calcAxisPositions(\n            bounds.z, bounds.d, maxJointZ, depth,\n            meetsFaceLeft, meetsFaceRight  // \"left/right\" in 2D = back/front in Z\n          );\n          return { axis: 'z', startPos, endPos };\n        } else {\n          // Vertical edges run along Y axis\n          const { startPos, endPos } = calcAxisPositions(\n            bounds.y, bounds.h, maxJointY, height,\n            meetsFaceBottom, meetsFaceTop  // bottom/top in 2D = bottom/top in Y\n          );\n          return { axis: 'y', startPos, endPos };\n        }\n      case 'y': // XZ plane divider - width=width(X), height=depth(Z)\n        if (isHorizontal) {\n          // Horizontal edges run along X axis\n          const { startPos, endPos } = calcAxisPositions(\n            bounds.x, bounds.w, maxJointX, width,\n            meetsFaceLeft, meetsFaceRight  // left/right in 2D = left/right in X\n          );\n          return { axis: 'x', startPos, endPos };\n        } else {\n          // Vertical edges run along Z axis\n          const { startPos, endPos } = calcAxisPositions(\n            bounds.z, bounds.d, maxJointZ, depth,\n            meetsFaceBottom, meetsFaceTop  // bottom/top in 2D = back/front in Z\n          );\n          return { axis: 'z', startPos, endPos };\n        }\n      case 'z': // XY plane divider - width=width(X), height=height(Y)\n      default:\n        if (isHorizontal) {\n          // Horizontal edges run along X axis\n          const { startPos, endPos } = calcAxisPositions(\n            bounds.x, bounds.w, maxJointX, width,\n            meetsFaceLeft, meetsFaceRight  // left/right in 2D = left/right in X\n          );\n          return { axis: 'x', startPos, endPos };\n        } else {\n          // Vertical edges run along Y axis\n          const { startPos, endPos } = calcAxisPositions(\n            bounds.y, bounds.h, maxJointY, height,\n            meetsFaceBottom, meetsFaceTop  // bottom/top in 2D = bottom/top in Y\n          );\n          return { axis: 'y', startPos, endPos };\n        }\n    }\n  };\n\n  const edgeConfigs = [\n    {\n      start: corners.topLeft, end: corners.topRight,\n      hasTabs: meetsTop, position: 'top' as const,\n      meetsFace: meetsFaceTop,\n      originalLength: origTopLength,\n      // Top edge goes leftright, left extension affects start\n      // Negative extension = shrink = positive offset\n      patternOffset: !meetsLeft ? -extLeft : 0,\n      axisInfo: getEdgeAxisInfo('top'),\n    },\n    {\n      start: corners.topRight, end: corners.bottomRight,\n      hasTabs: meetsRight, position: 'right' as const,\n      meetsFace: meetsFaceRight,\n      originalLength: origRightLength,\n      // Right edge goes topbottom, top extension affects start\n      patternOffset: !meetsTop ? -extTop : 0,\n      axisInfo: getEdgeAxisInfo('right'),\n    },\n    {\n      start: corners.bottomRight, end: corners.bottomLeft,\n      hasTabs: meetsBottom, position: 'bottom' as const,\n      meetsFace: meetsFaceBottom,\n      originalLength: origBottomLength,\n      // Bottom edge goes rightleft, right extension affects start\n      patternOffset: !meetsRight ? -extRight : 0,\n      axisInfo: getEdgeAxisInfo('bottom'),\n    },\n    {\n      start: corners.bottomLeft, end: corners.topLeft,\n      hasTabs: meetsLeft, position: 'left' as const,\n      meetsFace: meetsFaceLeft,\n      originalLength: origLeftLength,\n      // Left edge goes bottomtop, bottom extension affects start\n      patternOffset: !meetsBottom ? -extBottom : 0,\n      axisInfo: getEdgeAxisInfo('left'),\n    },\n  ];\n\n  const outlinePoints: PathPoint[] = [];\n\n  for (const { start, end, hasTabs, position: edgePosition, meetsFace, originalLength, patternOffset, axisInfo } of edgeConfigs) {\n    let points: Point[];\n\n    if (hasTabs) {\n      // Use V2 finger generation for edges meeting outer faces (for alignment with face slots)\n      if (meetsFace && fingerData) {\n        const axisFingerPoints = fingerData[axisInfo.axis];\n        const outwardDirection = getEdgeOutwardDirection(edgePosition);\n\n        // For bottom/right edges, the 2D path runs in the negative direction\n        // so we need to swap start/end positions\n        const runsNegative = edgePosition === 'bottom' || edgePosition === 'right';\n\n        // Adjust axis positions for edge extensions\n        // Extensions on perpendicular edges affect where this edge starts/ends along its axis\n        // The axis positions are in the 0-based finger coordinate system\n        let axisLowAdjust = 0;   // Adjustment to low end of axis (bottom/left/back)\n        let axisHighAdjust = 0;  // Adjustment to high end of axis (top/right/front)\n\n        // Determine which perpendicular extensions affect this edge based on divider orientation\n        // and which axis the edge runs along\n        if (axis === 'x') {\n          // X-axis divider (YZ plane): horizontal=Z, vertical=Y\n          if (edgePosition === 'top' || edgePosition === 'bottom') {\n            // Horizontal edge runs along Z: left/right extensions affect Z range\n            axisLowAdjust = extLeft;   // Left in 2D = back in Z\n            axisHighAdjust = extRight; // Right in 2D = front in Z\n          } else {\n            // Vertical edge runs along Y: top/bottom extensions affect Y range\n            axisLowAdjust = extBottom;\n            axisHighAdjust = extTop;\n          }\n        } else if (axis === 'y') {\n          // Y-axis divider (XZ plane): horizontal=X, vertical=Z\n          if (edgePosition === 'top' || edgePosition === 'bottom') {\n            // Horizontal edge runs along X: left/right extensions affect X range\n            axisLowAdjust = extLeft;\n            axisHighAdjust = extRight;\n          } else {\n            // Vertical edge runs along Z: top/bottom extensions affect Z range\n            axisLowAdjust = extBottom; // Bottom in 2D = back in Z\n            axisHighAdjust = extTop;   // Top in 2D = front in Z\n          }\n        } else {\n          // Z-axis divider (XY plane): horizontal=X, vertical=Y\n          if (edgePosition === 'top' || edgePosition === 'bottom') {\n            // Horizontal edge runs along X: left/right extensions affect X range\n            axisLowAdjust = extLeft;\n            axisHighAdjust = extRight;\n          } else {\n            // Vertical edge runs along Y: top/bottom extensions affect Y range\n            axisLowAdjust = extBottom;\n            axisHighAdjust = extTop;\n          }\n        }\n\n        // Apply adjustments to axis positions\n        // Positive extension = edge extends further = axis range increases\n        const adjustedStartPos = axisInfo.startPos - axisLowAdjust;\n        const adjustedEndPos = axisInfo.endPos + axisHighAdjust;\n\n        const edgeStartPos = runsNegative ? adjustedEndPos : adjustedStartPos;\n        const edgeEndPos = runsNegative ? adjustedStartPos : adjustedEndPos;\n\n        points = generateFingerJointPathV2(start, end, {\n          fingerPoints: axisFingerPoints,\n          gender: 'male', // Dividers always have tabs (male) going into face slots\n          materialThickness,\n          edgeStartPos,\n          edgeEndPos,\n          yUp: true,\n          outwardDirection,\n        });\n      } else {\n        // Use V1 for edges meeting other dividers (no alignment requirement)\n        const actualLength = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n        const isHorizontalEdge = edgePosition === 'top' || edgePosition === 'bottom';\n        const cornerInset = isHorizontalEdge\n          ? Math.max(meetsLeft ? materialThickness : 0, meetsRight ? materialThickness : 0)\n          : Math.max(meetsTop ? materialThickness : 0, meetsBottom ? materialThickness : 0);\n        const adjustedGapMultiplier = Math.max(0, fingerGap - cornerInset / fingerWidth);\n\n        points = generateFingerJointPath(start, end, {\n          edgeLength: actualLength,\n          fingerWidth,\n          materialThickness,\n          isTabOut: true,\n          kerf: 0,\n          yUp: true,\n          cornerGapMultiplier: adjustedGapMultiplier,\n          originalLength: originalLength,\n          patternOffset: patternOffset,\n        });\n      }\n    } else {\n      points = [start, end];\n    }\n\n    const startIndex = outlinePoints.length === 0 ? 0 : 1;\n    for (let i = startIndex; i < points.length; i++) {\n      outlinePoints.push(points[i]);\n    }\n  }\n\n  // Calculate 3D position\n  // The divider must be positioned at the split position on its axis,\n  // and centered within its parent void's bounds on the other two axes.\n  let panelPosition: [number, number, number];\n  let panelRotation: [number, number, number];\n\n  const scaledPos = position * scale;\n  const halfWidth = (width * scale) / 2;\n  const halfHeight = (height * scale) / 2;\n  const halfDepth = (depth * scale) / 2;\n\n  // Calculate the center of the parent bounds in box-centered coordinates\n  const boundsCenterX = (bounds.x + bounds.w / 2) * scale - halfWidth;\n  const boundsCenterY = (bounds.y + bounds.h / 2) * scale - halfHeight;\n  const boundsCenterZ = (bounds.z + bounds.d / 2) * scale - halfDepth;\n\n  switch (axis) {\n    case 'x':\n      // X-axis divider: positioned at splitPosition on X, centered on Y and Z within bounds\n      panelPosition = [scaledPos - halfWidth, boundsCenterY, boundsCenterZ];\n      panelRotation = [0, Math.PI / 2, 0];\n      break;\n    case 'y':\n      // Y-axis divider: positioned at splitPosition on Y, centered on X and Z within bounds\n      panelPosition = [boundsCenterX, scaledPos - halfHeight, boundsCenterZ];\n      panelRotation = [Math.PI / 2, 0, 0];\n      break;\n    case 'z':\n      // Z-axis divider: positioned at splitPosition on Z, centered on X and Y within bounds\n      panelPosition = [boundsCenterX, boundsCenterY, scaledPos - halfDepth];\n      panelRotation = [0, 0, 0];\n      break;\n  }\n\n  const source: PanelSource = {\n    type: 'divider',\n    subdivisionId: subdivision.id,\n    axis,\n  };\n\n  // Generate slot holes for child dividers that connect to this divider\n  const dividerSlots = allSubdivisions\n    ? generateDividerToSlotHoles(subdivision, allSubdivisions, config, faces)\n    : [];\n\n  return {\n    id: `divider-${subdivision.id}`,\n    source,\n    outline: { points: outlinePoints, closed: true },\n    holes: dividerSlots,\n    width: panelWidth,\n    height: panelHeight,\n    thickness: materialThickness,\n    position: panelPosition,\n    rotation: panelRotation,\n    label: `DIV-${axis.toUpperCase()}@${position.toFixed(1)}mm`,\n    visible: true,\n    edgeExtensions: { ...extensions },\n  };\n};\n\n// =============================================================================\n// Main Generation Function\n// =============================================================================\n\nexport const generatePanelCollection = (\n  faces: Face[],\n  rootVoid: Void,\n  config: BoxConfig,\n  scale: number = 1,\n  existingPanels?: PanelPath[]\n): PanelCollection => {\n  const panels: PanelPath[] = [];\n\n  // Calculate assembly-level finger points for aligned finger joints\n  const fingerData = calculateAssemblyFingerPoints(config);\n\n  // Helper to get existing extensions for a panel\n  const getExistingExtensions = (panelId: string): EdgeExtensions | undefined => {\n    if (!existingPanels) return undefined;\n    const existing = existingPanels.find(p => p.id === panelId);\n    return existing?.edgeExtensions;\n  };\n\n  // Generate face panels\n  // First pass: generate divider panels to get their extensions\n  const dividerPanels: PanelPath[] = [];\n  const subdivisions = getAllSubdivisions(rootVoid);\n  for (const sub of subdivisions) {\n    const panelId = `divider-${sub.id}`;\n    const panel = generateDividerPanel(sub, faces, config, scale, getExistingExtensions(panelId), subdivisions, fingerData);\n    dividerPanels.push(panel);\n  }\n\n  // Second pass: generate face panels with divider extension info\n  const faceIds: FaceId[] = ['front', 'back', 'left', 'right', 'top', 'bottom'];\n  for (const faceId of faceIds) {\n    const panelId = `face-${faceId}`;\n    const panel = generateFacePanel(faceId, faces, rootVoid, config, scale, getExistingExtensions(panelId), dividerPanels, fingerData);\n    if (panel) {\n      panels.push(panel);\n    }\n  }\n\n  // Add divider panels (already generated above)\n  for (const dividerPanel of dividerPanels) {\n    panels.push(dividerPanel);\n  }\n\n  return {\n    panels,\n    augmentations: [],\n    generatedAt: Date.now(),\n  };\n};\n","import { create } from 'zustand';\nimport { BoxState, BoxActions, FaceId, Void, Bounds, Subdivision, SubdivisionPreview, SelectionMode, SubAssembly, Face, AssemblyAxis, LidTabDirection, defaultAssemblyConfig, AssemblyConfig, PanelCollection, PanelPath, PanelHole, PanelAugmentation, defaultEdgeExtensions, EdgeExtensions, CreateSubAssemblyOptions, FaceOffsets, SplitPositionMode, ViewMode } from '../types';\nimport { loadFromUrl, saveToUrl as saveStateToUrl, getShareableUrl as getShareUrl, ProjectState } from '../utils/urlState';\nimport { generatePanelCollection } from '../utils/panelGenerator';\n\nconst generateId = () => Math.random().toString(36).substr(2, 9);\n\n// Create a simple root void without lid inset considerations\nconst createSimpleRootVoid = (width: number, height: number, depth: number): Void => ({\n  id: 'root',\n  bounds: { x: 0, y: 0, z: 0, w: width, h: height, d: depth },\n  children: [],\n});\n\n// Create root void with lid inset structure\n// When lids are inset, creates children: lid cap voids + main interior void\nconst createRootVoidWithInsets = (\n  width: number,\n  height: number,\n  depth: number,\n  assembly: AssemblyConfig,\n  existingChildren?: Void[]\n): Void => {\n  const positiveInset = assembly.lids.positive.inset;\n  const negativeInset = assembly.lids.negative.inset;\n\n  // If no insets, return simple root void (preserving existing children)\n  if (positiveInset === 0 && negativeInset === 0) {\n    return {\n      id: 'root',\n      bounds: { x: 0, y: 0, z: 0, w: width, h: height, d: depth },\n      children: existingChildren || [],\n    };\n  }\n\n  // Calculate main interior bounds based on assembly axis\n  let mainBounds: Bounds;\n  let positiveCapBounds: Bounds | null = null;\n  let negativeCapBounds: Bounds | null = null;\n\n  switch (assembly.assemblyAxis) {\n    case 'y':\n      // Top/bottom are lids\n      mainBounds = {\n        x: 0,\n        y: negativeInset,\n        z: 0,\n        w: width,\n        h: height - positiveInset - negativeInset,\n        d: depth,\n      };\n      if (positiveInset > 0) {\n        positiveCapBounds = {\n          x: 0,\n          y: height - positiveInset,\n          z: 0,\n          w: width,\n          h: positiveInset,\n          d: depth,\n        };\n      }\n      if (negativeInset > 0) {\n        negativeCapBounds = {\n          x: 0,\n          y: 0,\n          z: 0,\n          w: width,\n          h: negativeInset,\n          d: depth,\n        };\n      }\n      break;\n\n    case 'x':\n      // Left/right are lids\n      mainBounds = {\n        x: negativeInset,\n        y: 0,\n        z: 0,\n        w: width - positiveInset - negativeInset,\n        h: height,\n        d: depth,\n      };\n      if (positiveInset > 0) {\n        positiveCapBounds = {\n          x: width - positiveInset,\n          y: 0,\n          z: 0,\n          w: positiveInset,\n          h: height,\n          d: depth,\n        };\n      }\n      if (negativeInset > 0) {\n        negativeCapBounds = {\n          x: 0,\n          y: 0,\n          z: 0,\n          w: negativeInset,\n          h: height,\n          d: depth,\n        };\n      }\n      break;\n\n    case 'z':\n      // Front/back are lids\n      mainBounds = {\n        x: 0,\n        y: 0,\n        z: negativeInset,\n        w: width,\n        h: height,\n        d: depth - positiveInset - negativeInset,\n      };\n      if (positiveInset > 0) {\n        positiveCapBounds = {\n          x: 0,\n          y: 0,\n          z: depth - positiveInset,\n          w: width,\n          h: height,\n          d: positiveInset,\n        };\n      }\n      if (negativeInset > 0) {\n        negativeCapBounds = {\n          x: 0,\n          y: 0,\n          z: 0,\n          w: width,\n          h: height,\n          d: negativeInset,\n        };\n      }\n      break;\n  }\n\n  // Build children array\n  // Note: We do NOT set splitAxis/splitPosition on lid inset voids because\n  // they are not physical divider panels - they're just the space between\n  // the inset lid and the outer box edge.\n  const children: Void[] = [];\n\n  // Add negative cap void first (at lower position)\n  if (negativeCapBounds) {\n    children.push({\n      id: 'lid-inset-negative',\n      bounds: negativeCapBounds,\n      children: [],\n      lidInsetSide: 'negative',\n    });\n  }\n\n  // Add main interior void (contains existing user subdivisions)\n  children.push({\n    id: 'main-interior',\n    bounds: mainBounds,\n    children: existingChildren || [],\n    isMainInterior: true,\n  });\n\n  // Add positive cap void last (at higher position)\n  if (positiveCapBounds) {\n    children.push({\n      id: 'lid-inset-positive',\n      bounds: positiveCapBounds,\n      children: [],\n      lidInsetSide: 'positive',\n    });\n  }\n\n  return {\n    id: 'root',\n    bounds: { x: 0, y: 0, z: 0, w: width, h: height, d: depth },\n    children,\n  };\n};\n\n// Get the main interior void (either root or the main-interior child if insets exist)\nexport const getMainInteriorVoid = (root: Void): Void => {\n  const mainInterior = root.children.find(c => c.isMainInterior);\n  return mainInterior || root;\n};\n\n// Helper to get existing user subdivisions (excludes lid inset voids)\nconst getUserSubdivisions = (root: Void): Void[] => {\n  // If root has a main-interior child, return its children\n  const mainInterior = root.children.find(c => c.isMainInterior);\n  if (mainInterior) {\n    return mainInterior.children;\n  }\n  // Otherwise, return root's children (filtering out any lid inset voids just in case)\n  return root.children.filter(c => !c.lidInsetSide);\n};\n\nconst initialFaces = (): { id: FaceId; solid: boolean }[] => [\n  { id: 'front', solid: true },\n  { id: 'back', solid: true },\n  { id: 'left', solid: true },\n  { id: 'right', solid: true },\n  { id: 'top', solid: true },\n  { id: 'bottom', solid: true },\n];\n\n// Find a void by ID in the tree (including inside sub-assemblies)\nconst findVoid = (root: Void, id: string): Void | null => {\n  if (root.id === id) return root;\n  for (const child of root.children) {\n    const found = findVoid(child, id);\n    if (found) return found;\n  }\n  // Also search inside sub-assembly's void structure\n  if (root.subAssembly) {\n    const found = findVoid(root.subAssembly.rootVoid, id);\n    if (found) return found;\n  }\n  return null;\n};\n\n// Find parent of a void (including inside sub-assemblies)\nconst findParent = (root: Void, id: string): Void | null => {\n  for (const child of root.children) {\n    if (child.id === id) return root;\n    const found = findParent(child, id);\n    if (found) return found;\n  }\n  // Also search inside sub-assembly's void structure\n  if (root.subAssembly) {\n    if (root.subAssembly.rootVoid.id === id) return root.subAssembly.rootVoid;\n    const found = findParent(root.subAssembly.rootVoid, id);\n    if (found) return found;\n  }\n  return null;\n};\n\n// Recalculate void bounds when dimensions change\n// For percentage-based subdivisions, recalculates splitPosition from splitPercentage\n// For absolute subdivisions, clamps position to valid range\nconst recalculateVoidBounds = (\n  node: Void,\n  parentBounds: Bounds,\n  materialThickness: number\n): Void => {\n  // If this node has no children, just update its bounds to match parent\n  if (node.children.length === 0) {\n    return {\n      ...node,\n      bounds: { ...parentBounds },\n    };\n  }\n\n  // This node has children - they were created by subdivisions\n  // Find the split axis from the first child that has one\n  const firstChildWithSplit = node.children.find(c => c.splitAxis);\n  if (!firstChildWithSplit || !firstChildWithSplit.splitAxis) {\n    // Children exist but no split info (e.g., lid inset children) - preserve structure\n    return {\n      ...node,\n      bounds: { ...parentBounds },\n      children: node.children.map(child => {\n        // For lid inset voids, recalculate their bounds based on position\n        if (child.lidInsetSide || child.isMainInterior) {\n          // These are handled separately, just preserve them\n          return child;\n        }\n        return recalculateVoidBounds(child, child.bounds, materialThickness);\n      }),\n    };\n  }\n\n  const axis = firstChildWithSplit.splitAxis;\n  const mt = materialThickness;\n\n  // Get dimension info for this axis\n  const parentStart = axis === 'x' ? parentBounds.x : axis === 'y' ? parentBounds.y : parentBounds.z;\n  const parentSize = axis === 'x' ? parentBounds.w : axis === 'y' ? parentBounds.h : parentBounds.d;\n  const parentEnd = parentStart + parentSize;\n\n  // Recalculate split positions for children\n  // Children are ordered from low to high along the split axis\n  // Only children after the first have splitPosition (child 0 doesn't have a divider before it)\n  const newChildren: Void[] = [];\n  const splitPositions: number[] = [];\n\n  for (let i = 0; i < node.children.length; i++) {\n    const child = node.children[i];\n\n    if (child.splitAxis && child.splitPosition !== undefined) {\n      let newPosition: number;\n\n      if (child.splitPositionMode === 'percentage' && child.splitPercentage !== undefined) {\n        // Calculate new position from percentage\n        newPosition = parentStart + child.splitPercentage * parentSize;\n      } else {\n        // Absolute mode - keep the position but clamp to valid range\n        // Calculate valid range: after previous divider + mt, before end - mt\n        const minPos = (splitPositions.length > 0 ? splitPositions[splitPositions.length - 1] : parentStart) + mt;\n        const maxPos = parentEnd - mt;\n        newPosition = Math.max(minPos, Math.min(maxPos, child.splitPosition));\n      }\n\n      splitPositions.push(newPosition);\n    }\n  }\n\n  // Now create new children with updated bounds\n  for (let i = 0; i < node.children.length; i++) {\n    const child = node.children[i];\n\n    // Calculate region bounds for this child\n    const regionStart = i === 0\n      ? parentStart\n      : splitPositions[i - 1] + mt / 2;\n\n    const regionEnd = i === node.children.length - 1\n      ? parentEnd\n      : splitPositions[i] - mt / 2;\n\n    const regionSize = regionEnd - regionStart;\n\n    let childBounds: Bounds;\n    switch (axis) {\n      case 'x':\n        childBounds = { ...parentBounds, x: regionStart, w: regionSize };\n        break;\n      case 'y':\n        childBounds = { ...parentBounds, y: regionStart, h: regionSize };\n        break;\n      case 'z':\n        childBounds = { ...parentBounds, z: regionStart, d: regionSize };\n        break;\n    }\n\n    // Recursively update this child\n    const updatedChild = recalculateVoidBounds(\n      {\n        ...child,\n        splitPosition: i > 0 ? splitPositions[i - 1] : child.splitPosition,\n      },\n      childBounds,\n      materialThickness\n    );\n\n    newChildren.push(updatedChild);\n  }\n\n  return {\n    ...node,\n    bounds: { ...parentBounds },\n    children: newChildren,\n  };\n};\n\n// Get all leaf voids (voids with no children - these are selectable)\nexport const getLeafVoids = (root: Void): Void[] => {\n  if (root.children.length === 0) {\n    return [root];\n  }\n  return root.children.flatMap(getLeafVoids);\n};\n\n// Get all void IDs in a subtree (including the root)\nexport const getVoidSubtreeIds = (root: Void): string[] => {\n  const ids = [root.id];\n  for (const child of root.children) {\n    ids.push(...getVoidSubtreeIds(child));\n  }\n  return ids;\n};\n\n// Get ancestor IDs of a void (path from root to the void, excluding the void itself)\nexport const getVoidAncestorIds = (root: Void, targetId: string): string[] => {\n  const path: string[] = [];\n\n  const findPath = (node: Void, target: string): boolean => {\n    if (node.id === target) return true;\n    for (const child of node.children) {\n      if (findPath(child, target)) {\n        path.unshift(node.id);\n        return true;\n      }\n    }\n    return false;\n  };\n\n  findPath(root, targetId);\n  return path;\n};\n\n// Check if a void should be visible given the visibility settings\n// Visibility is now managed by adding/removing from hiddenVoidIds during isolate\nexport const isVoidVisible = (\n  voidId: string,\n  _rootVoid: Void,\n  hiddenVoidIds: Set<string>,\n  _isolatedVoidId: string | null\n): boolean => {\n  return !hiddenVoidIds.has(voidId);\n};\n\n// Check if a sub-assembly should be visible given the visibility settings\n// Visibility is now managed by adding/removing from hiddenSubAssemblyIds during isolate\nexport const isSubAssemblyVisible = (\n  subAssemblyId: string,\n  hiddenSubAssemblyIds: Set<string>,\n  _isolatedSubAssemblyId: string | null\n): boolean => {\n  return !hiddenSubAssemblyIds.has(subAssemblyId);\n};\n\n// Get all subdivisions (non-leaf voids have split info)\nexport const getAllSubdivisions = (root: Void): Subdivision[] => {\n  const subdivisions: Subdivision[] = [];\n\n  const traverse = (node: Void, parentBounds: Bounds) => {\n    if (node.splitAxis && node.splitPosition !== undefined) {\n      subdivisions.push({\n        id: node.id + '-split',\n        axis: node.splitAxis,\n        position: node.splitPosition,\n        bounds: parentBounds,  // Bounds of the parent void (where the divider can move)\n        positionMode: node.splitPositionMode,\n        percentage: node.splitPercentage,\n      });\n    }\n\n    for (const child of node.children) {\n      traverse(child, node.bounds);\n    }\n  };\n\n  for (const child of root.children) {\n    traverse(child, root.bounds);\n  }\n\n  return subdivisions;\n};\n\n// Calculate preview positions for a given axis and count\nexport const calculatePreviewPositions = (\n  bounds: Bounds,\n  axis: 'x' | 'y' | 'z',\n  count: number\n): number[] => {\n  const positions: number[] = [];\n\n  for (let i = 1; i <= count; i++) {\n    const fraction = i / (count + 1);\n    switch (axis) {\n      case 'x':\n        positions.push(bounds.x + fraction * bounds.w);\n        break;\n      case 'y':\n        positions.push(bounds.y + fraction * bounds.h);\n        break;\n      case 'z':\n        positions.push(bounds.z + fraction * bounds.d);\n        break;\n    }\n  }\n\n  return positions;\n};\n\n// Deep clone a void tree (including sub-assemblies)\nconst cloneVoid = (v: Void): Void => ({\n  ...v,\n  bounds: { ...v.bounds },\n  children: v.children.map(cloneVoid),\n  subAssembly: v.subAssembly ? {\n    ...v.subAssembly,\n    faces: v.subAssembly.faces.map(f => ({ ...f })),\n    rootVoid: cloneVoid(v.subAssembly.rootVoid),\n  } : undefined,\n});\n\n// Find a sub-assembly by ID in the void tree\nconst findSubAssembly = (root: Void, subAssemblyId: string): { void: Void; subAssembly: SubAssembly } | null => {\n  if (root.subAssembly?.id === subAssemblyId) {\n    return { void: root, subAssembly: root.subAssembly };\n  }\n  for (const child of root.children) {\n    const found = findSubAssembly(child, subAssemblyId);\n    if (found) return found;\n  }\n  // Also search within sub-assembly's own voids\n  if (root.subAssembly) {\n    const found = findSubAssembly(root.subAssembly.rootVoid, subAssemblyId);\n    if (found) return found;\n  }\n  return null;\n};\n\n// Get all sub-assemblies from the void tree\nexport const getAllSubAssemblies = (root: Void): { voidId: string; subAssembly: SubAssembly; bounds: Bounds }[] => {\n  const result: { voidId: string; subAssembly: SubAssembly; bounds: Bounds }[] = [];\n\n  const traverse = (node: Void) => {\n    if (node.subAssembly) {\n      result.push({\n        voidId: node.id,\n        subAssembly: node.subAssembly,\n        bounds: node.bounds,\n      });\n      // Also traverse the sub-assembly's internal structure\n      traverse(node.subAssembly.rootVoid);\n    }\n    for (const child of node.children) {\n      traverse(child);\n    }\n  };\n\n  traverse(root);\n  return result;\n};\n\n// Update a void in the tree immutably (including inside sub-assemblies)\nconst updateVoidInTree = (root: Void, id: string, updater: (v: Void) => Void): Void => {\n  if (root.id === id) {\n    return updater(cloneVoid(root));\n  }\n  return {\n    ...root,\n    bounds: { ...root.bounds },\n    children: root.children.map(child => updateVoidInTree(child, id, updater)),\n    // Also update inside sub-assembly's void structure\n    subAssembly: root.subAssembly ? {\n      ...root.subAssembly,\n      rootVoid: updateVoidInTree(root.subAssembly.rootVoid, id, updater),\n    } : undefined,\n  };\n};\n\nexport const useBoxStore = create<BoxState & BoxActions>((set, get) => ({\n  config: {\n    width: 100,\n    height: 100,\n    depth: 100,\n    materialThickness: 3,\n    fingerWidth: 10,\n    fingerGap: 1.5,  // Corner gap as multiplier of fingerWidth\n    assembly: defaultAssemblyConfig,\n  },\n  faces: initialFaces(),\n  rootVoid: createSimpleRootVoid(100, 100, 100),\n  selectionMode: null as SelectionMode,\n  selectedVoidIds: new Set<string>(),\n  selectedSubAssemblyIds: new Set<string>(),\n  selectedPanelIds: new Set<string>(),\n  selectedAssemblyId: 'main',  // Default to main assembly selected\n  // Hover state\n  hoveredVoidId: null,\n  hoveredPanelId: null,\n  hoveredAssemblyId: null,\n  subdivisionPreview: null,\n  subAssemblyPreview: null,\n  hiddenVoidIds: new Set<string>(),\n  isolatedVoidId: null,\n  isolateHiddenVoidIds: new Set<string>(),\n  hiddenSubAssemblyIds: new Set<string>(),\n  isolatedSubAssemblyId: null,\n  isolateHiddenSubAssemblyIds: new Set<string>(),\n  hiddenFaceIds: new Set<string>(),\n  isolatedPanelId: null,\n  isolateHiddenFaceIds: new Set<string>(),\n  panelCollection: null,\n  panelsDirty: true,  // Start dirty so panels get generated on first use\n  showDebugAnchors: false,\n  // 2D Sketch View state\n  viewMode: '3d',\n  sketchPanelId: null,\n\n  setConfig: (newConfig) =>\n    set((state) => {\n      const config = { ...state.config, ...newConfig };\n      const oldConfig = state.config;\n\n      // Check if assembly structure changes (requires reset)\n      const assemblyStructureChanged =\n        config.assembly.assemblyAxis !== oldConfig.assembly.assemblyAxis ||\n        config.assembly.lids.positive.inset !== oldConfig.assembly.lids.positive.inset ||\n        config.assembly.lids.negative.inset !== oldConfig.assembly.lids.negative.inset;\n\n      // Check if dimensions changed\n      const dimensionsChanged =\n        config.width !== oldConfig.width ||\n        config.height !== oldConfig.height ||\n        config.depth !== oldConfig.depth;\n\n      // If assembly structure changes, reset everything\n      if (assemblyStructureChanged) {\n        return {\n          config,\n          rootVoid: createRootVoidWithInsets(config.width, config.height, config.depth, config.assembly),\n          selectedVoidIds: new Set<string>(),\n          selectedSubAssemblyIds: new Set<string>(),\n          selectedPanelIds: new Set<string>(),\n          selectedAssemblyId: null,\n          subdivisionPreview: null,\n          hiddenVoidIds: new Set<string>(),\n          isolatedVoidId: null,\n          isolateHiddenVoidIds: new Set<string>(),\n          hiddenSubAssemblyIds: new Set<string>(),\n          isolatedSubAssemblyId: null,\n          isolateHiddenSubAssemblyIds: new Set<string>(),\n          hiddenFaceIds: new Set<string>(),\n          isolatedPanelId: null,\n          isolateHiddenFaceIds: new Set<string>(),\n          panelsDirty: true,\n        };\n      }\n\n      // If dimensions changed, preserve subdivisions and recalculate bounds\n      if (dimensionsChanged) {\n        const newRootBounds: Bounds = { x: 0, y: 0, z: 0, w: config.width, h: config.height, d: config.depth };\n\n        // Get the main interior void (where user subdivisions live)\n        const mainInterior = getMainInteriorVoid(state.rootVoid);\n        const hasInsets = mainInterior.id !== state.rootVoid.id;\n\n        let newRootVoid: Void;\n\n        if (hasInsets) {\n          // Has lid insets - need to rebuild root structure with new dimensions\n          // but preserve the children of the main interior void\n          const positiveInset = config.assembly.lids.positive.inset;\n          const negativeInset = config.assembly.lids.negative.inset;\n          const axis = config.assembly.assemblyAxis;\n\n          // Calculate new main interior bounds\n          let mainBounds: Bounds;\n          switch (axis) {\n            case 'y':\n              mainBounds = {\n                x: 0, y: negativeInset, z: 0,\n                w: config.width, h: config.height - positiveInset - negativeInset, d: config.depth,\n              };\n              break;\n            case 'x':\n              mainBounds = {\n                x: negativeInset, y: 0, z: 0,\n                w: config.width - positiveInset - negativeInset, h: config.height, d: config.depth,\n              };\n              break;\n            case 'z':\n              mainBounds = {\n                x: 0, y: 0, z: negativeInset,\n                w: config.width, h: config.height, d: config.depth - positiveInset - negativeInset,\n              };\n              break;\n          }\n\n          // Recalculate the main interior's children\n          const recalculatedMainInterior = recalculateVoidBounds(\n            { ...mainInterior, bounds: mainBounds },\n            mainBounds,\n            config.materialThickness\n          );\n\n          // Rebuild the root with lid caps and recalculated main interior\n          newRootVoid = createRootVoidWithInsets(\n            config.width, config.height, config.depth, config.assembly\n          );\n          // Replace the main interior's children with the recalculated ones\n          const newMainInterior = newRootVoid.children.find(c => c.isMainInterior);\n          if (newMainInterior) {\n            newMainInterior.children = recalculatedMainInterior.children;\n          }\n        } else {\n          // No lid insets - recalculate directly from root\n          newRootVoid = recalculateVoidBounds(\n            { ...state.rootVoid, bounds: newRootBounds },\n            newRootBounds,\n            config.materialThickness\n          );\n        }\n\n        return {\n          config,\n          rootVoid: newRootVoid,\n          subdivisionPreview: null,\n          panelsDirty: true,\n        };\n      }\n\n      // Only non-structural config changes (materialThickness, fingerWidth, etc.)\n      return {\n        config,\n        panelsDirty: true,\n      };\n    }),\n\n  toggleFace: (faceId) =>\n    set((state) => ({\n      faces: state.faces.map((face) =>\n        face.id === faceId ? { ...face, solid: !face.solid } : face\n      ),\n      subdivisionPreview: null,  // Clear preview when faces change\n      panelsDirty: true,  // Mark panels as needing regeneration\n    })),\n\n  setSelectionMode: (mode) =>\n    set({\n      selectionMode: mode,\n      selectedVoidIds: new Set<string>(),\n      selectedSubAssemblyIds: new Set<string>(),\n      selectedPanelIds: new Set<string>(),\n      selectedAssemblyId: null,\n      subdivisionPreview: null,\n    }),\n\n  selectVoid: (voidId, additive = false) =>\n    set((state) => {\n      if (voidId === null) {\n        return {\n          selectedVoidIds: new Set<string>(),\n          selectedSubAssemblyIds: new Set<string>(),\n          selectedPanelIds: new Set<string>(),\n          selectedAssemblyId: null,\n        };\n      }\n      const newSet = new Set(additive ? state.selectedVoidIds : []);\n      if (newSet.has(voidId)) {\n        newSet.delete(voidId);\n      } else {\n        newSet.add(voidId);\n      }\n      // When selecting a void (not additive), clear all other selection types\n      if (additive) {\n        return { selectedVoidIds: newSet };\n      }\n      return {\n        selectedVoidIds: newSet,\n        selectedSubAssemblyIds: new Set<string>(),\n        selectedPanelIds: new Set<string>(),\n        selectedAssemblyId: null,\n      };\n    }),\n\n  selectPanel: (panelId, additive = false) =>\n    set((state) => {\n      if (panelId === null) {\n        return {\n          selectedPanelIds: new Set<string>(),\n          selectedVoidIds: new Set<string>(),\n          selectedSubAssemblyIds: new Set<string>(),\n          selectedAssemblyId: null,\n        };\n      }\n      const newSet = new Set(additive ? state.selectedPanelIds : []);\n      if (newSet.has(panelId)) {\n        newSet.delete(panelId);\n      } else {\n        newSet.add(panelId);\n      }\n      // When selecting a panel (not additive), clear all other selection types\n      if (additive) {\n        return { selectedPanelIds: newSet };\n      }\n      return {\n        selectedPanelIds: newSet,\n        selectedVoidIds: new Set<string>(),\n        selectedSubAssemblyIds: new Set<string>(),\n        selectedAssemblyId: null,\n      };\n    }),\n\n  selectAssembly: (assemblyId) =>\n    set({\n      selectedAssemblyId: assemblyId,\n      selectedVoidIds: new Set<string>(),\n      selectedSubAssemblyIds: new Set<string>(),\n      selectedPanelIds: new Set<string>(),\n      // Keep subdivisionPreview - don't clear on selection change\n    }),\n\n  selectSubAssembly: (subAssemblyId, additive = false) =>\n    set((state) => {\n      if (subAssemblyId === null) {\n        return {\n          selectedSubAssemblyIds: new Set<string>(),\n          selectedVoidIds: new Set<string>(),\n          selectedPanelIds: new Set<string>(),\n          selectedAssemblyId: null,\n        };\n      }\n      const newSet = new Set(additive ? state.selectedSubAssemblyIds : []);\n      if (newSet.has(subAssemblyId)) {\n        newSet.delete(subAssemblyId);\n      } else {\n        newSet.add(subAssemblyId);\n      }\n      // When selecting a sub-assembly (not additive), clear all other selection types\n      if (additive) {\n        return { selectedSubAssemblyIds: newSet };\n      }\n      return {\n        selectedSubAssemblyIds: newSet,\n        selectedVoidIds: new Set<string>(),\n        selectedPanelIds: new Set<string>(),\n        selectedAssemblyId: null,\n      };\n    }),\n\n  clearSelection: () =>\n    set({\n      selectedVoidIds: new Set<string>(),\n      selectedSubAssemblyIds: new Set<string>(),\n      selectedPanelIds: new Set<string>(),\n      selectedAssemblyId: null,\n    }),\n\n  setHoveredVoid: (voidId) =>\n    set({ hoveredVoidId: voidId }),\n\n  setHoveredPanel: (panelId) =>\n    set({ hoveredPanelId: panelId }),\n\n  setHoveredAssembly: (assemblyId) =>\n    set({ hoveredAssemblyId: assemblyId }),\n\n  setSubdivisionPreview: (preview) =>\n    set({ subdivisionPreview: preview }),\n\n  setSubAssemblyPreview: (preview) =>\n    set({ subAssemblyPreview: preview }),\n\n  applySubdivision: () =>\n    set((state) => {\n      const preview = state.subdivisionPreview;\n      if (!preview) return state;\n\n      const targetVoid = findVoid(state.rootVoid, preview.voidId);\n      if (!targetVoid || targetVoid.children.length > 0) return state;\n\n      const { bounds } = targetVoid;\n      const { axis, count, positions } = preview;\n      const mt = state.config.materialThickness;\n\n      // Create N+1 child voids for N divisions\n      // Account for material thickness of dividers\n      const children: Void[] = [];\n\n      // Get the dimension size along the split axis\n      const dimSize = axis === 'x' ? bounds.w : axis === 'y' ? bounds.h : bounds.d;\n      const dimStart = axis === 'x' ? bounds.x : axis === 'y' ? bounds.y : bounds.z;\n\n      // Calculate void boundaries accounting for divider thickness\n      // Each divider is centered at its position and takes up materialThickness\n      for (let i = 0; i <= count; i++) {\n        // Start of this void region\n        const regionStart = i === 0\n          ? dimStart\n          : positions[i - 1] + mt / 2;  // After previous divider\n\n        // End of this void region\n        const regionEnd = i === count\n          ? dimStart + dimSize\n          : positions[i] - mt / 2;  // Before next divider\n\n        const regionSize = regionEnd - regionStart;\n\n        let childBounds: Bounds;\n        let splitPos: number | undefined;\n        let splitAxis: 'x' | 'y' | 'z' | undefined;\n\n        switch (axis) {\n          case 'x':\n            childBounds = {\n              ...bounds,\n              x: regionStart,\n              w: regionSize,\n            };\n            if (i > 0) {\n              splitPos = positions[i - 1];\n              splitAxis = axis;\n            }\n            break;\n          case 'y':\n            childBounds = {\n              ...bounds,\n              y: regionStart,\n              h: regionSize,\n            };\n            if (i > 0) {\n              splitPos = positions[i - 1];\n              splitAxis = axis;\n            }\n            break;\n          case 'z':\n            childBounds = {\n              ...bounds,\n              z: regionStart,\n              d: regionSize,\n            };\n            if (i > 0) {\n              splitPos = positions[i - 1];\n              splitAxis = axis;\n            }\n            break;\n        }\n\n        // Calculate percentage for this split position\n        let splitPercentage: number | undefined;\n        if (splitPos !== undefined) {\n          splitPercentage = (splitPos - dimStart) / dimSize;\n        }\n\n        children.push({\n          id: generateId(),\n          bounds: childBounds,\n          children: [],\n          splitAxis,\n          splitPosition: splitPos,\n          splitPositionMode: splitPos !== undefined ? 'percentage' : undefined,\n          splitPercentage,\n        });\n      }\n\n      const newRootVoid = updateVoidInTree(state.rootVoid, preview.voidId, (v) => ({\n        ...v,\n        children,\n      }));\n\n      return {\n        rootVoid: newRootVoid,\n        selectedVoidIds: new Set<string>(),\n        selectedPanelIds: new Set<string>(),\n        subdivisionPreview: null,\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  removeVoid: (voidId) =>\n    set((state) => {\n      const parent = findParent(state.rootVoid, voidId);\n      if (!parent) return state;\n\n      const newRootVoid = updateVoidInTree(state.rootVoid, parent.id, (v) => ({\n        ...v,\n        children: [],\n      }));\n\n      return {\n        rootVoid: newRootVoid,\n        selectedVoidIds: new Set<string>(),\n        selectedPanelIds: new Set<string>(),\n        subdivisionPreview: null,\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  resetVoids: () =>\n    set((state) => ({\n      rootVoid: createRootVoidWithInsets(state.config.width, state.config.height, state.config.depth, state.config.assembly),\n      selectedVoidIds: new Set<string>(),\n      selectedSubAssemblyIds: new Set<string>(),\n      selectedPanelIds: new Set<string>(),\n      selectedAssemblyId: null,\n      subdivisionPreview: null,\n      hiddenVoidIds: new Set<string>(),\n      isolatedVoidId: null,\n      isolateHiddenVoidIds: new Set<string>(),\n      hiddenSubAssemblyIds: new Set<string>(),\n      isolatedSubAssemblyId: null,\n      isolateHiddenSubAssemblyIds: new Set<string>(),\n      hiddenFaceIds: new Set<string>(),\n      isolatedPanelId: null,\n      isolateHiddenFaceIds: new Set<string>(),\n      panelsDirty: true,  // Mark panels as needing regeneration\n    })),\n\n  // Sub-assembly actions\n  createSubAssembly: (voidId, options) =>\n    set((state) => {\n      const targetVoid = findVoid(state.rootVoid, voidId);\n      if (!targetVoid || targetVoid.children.length > 0 || targetVoid.subAssembly) {\n        return state; // Can't create sub-assembly in non-leaf void or if one already exists\n      }\n\n      const clearance = options?.clearance ?? 2; // Default 2mm clearance\n      const assemblyAxis = options?.assemblyAxis ?? 'y'; // Default Y axis\n      const faceOffsets = options?.faceOffsets ?? { front: 0, back: 0, left: 0, right: 0, top: 0, bottom: 0 };\n      const { bounds } = targetVoid;\n      const mt = state.config.materialThickness;\n\n      // Calculate outer dimensions (space available after clearance + face offsets)\n      // Face offsets adjust individual sides: positive = outset, negative = inset\n      const outerWidth = bounds.w - (clearance * 2) + faceOffsets.left + faceOffsets.right;\n      const outerHeight = bounds.h - (clearance * 2) + faceOffsets.top + faceOffsets.bottom;\n      const outerDepth = bounds.d - (clearance * 2) + faceOffsets.front + faceOffsets.back;\n\n      // Calculate interior dimensions (outer minus walls on each side)\n      const interiorWidth = outerWidth - (2 * mt);\n      const interiorHeight = outerHeight - (2 * mt);\n      const interiorDepth = outerDepth - (2 * mt);\n\n      if (interiorWidth <= 0 || interiorHeight <= 0 || interiorDepth <= 0) {\n        return state; // Void too small for sub-assembly\n      }\n\n      // Create sub-assembly with all faces solid by default (like main box)\n      const defaultFaces: Face[] = [\n        { id: 'front', solid: true },\n        { id: 'back', solid: true },\n        { id: 'left', solid: true },\n        { id: 'right', solid: true },\n        { id: 'top', solid: true },\n        { id: 'bottom', solid: true },\n      ];\n\n      const subAssembly: SubAssembly = {\n        id: generateId(),\n        clearance,\n        faceOffsets,\n        faces: defaultFaces,\n        materialThickness: mt,\n        rootVoid: {\n          id: 'sub-root-' + generateId(),\n          // rootVoid stores INTERIOR dimensions (outer - 2*materialThickness)\n          bounds: { x: 0, y: 0, z: 0, w: interiorWidth, h: interiorHeight, d: interiorDepth },\n          children: [],\n        },\n        // Assembly config with provided axis\n        assembly: {\n          assemblyAxis,\n          lids: {\n            positive: { enabled: true, tabDirection: 'tabs-out', inset: 0 },\n            negative: { enabled: true, tabDirection: 'tabs-out', inset: 0 },\n          },\n        },\n      };\n\n      const newRootVoid = updateVoidInTree(state.rootVoid, voidId, (v) => ({\n        ...v,\n        subAssembly,\n      }));\n\n      return {\n        rootVoid: newRootVoid,\n        selectedVoidIds: new Set<string>(),\n        selectedSubAssemblyIds: new Set([subAssembly.id]),\n        subdivisionPreview: null,\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  purgeVoid: (voidId) =>\n    set((state) => {\n      const newRootVoid = updateVoidInTree(state.rootVoid, voidId, (v) => ({\n        ...v,\n        children: [],\n        subAssembly: undefined,\n      }));\n\n      return {\n        rootVoid: newRootVoid,\n        selectedVoidIds: new Set<string>(),\n        selectedSubAssemblyIds: new Set<string>(),\n        subdivisionPreview: null,\n        panelsDirty: true,\n      };\n    }),\n\n  toggleSubAssemblyFace: (subAssemblyId, faceId) =>\n    set((state) => {\n      const found = findSubAssembly(state.rootVoid, subAssemblyId);\n      if (!found) return state;\n\n      // We need to find the parent void and update it\n      const updateSubAssemblyInVoid = (v: Void): Void => {\n        if (v.subAssembly?.id === subAssemblyId) {\n          return {\n            ...v,\n            subAssembly: {\n              ...v.subAssembly,\n              faces: v.subAssembly.faces.map((f) =>\n                f.id === faceId ? { ...f, solid: !f.solid } : f\n              ),\n            },\n          };\n        }\n        return {\n          ...v,\n          children: v.children.map(updateSubAssemblyInVoid),\n          subAssembly: v.subAssembly ? {\n            ...v.subAssembly,\n            rootVoid: updateSubAssemblyInVoid(v.subAssembly.rootVoid),\n          } : undefined,\n        };\n      };\n\n      return {\n        rootVoid: updateSubAssemblyInVoid(state.rootVoid),\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  setSubAssemblyClearance: (subAssemblyId, clearance) =>\n    set((state) => {\n      const updateSubAssemblyInVoid = (v: Void): Void => {\n        if (v.subAssembly?.id === subAssemblyId) {\n          const newClearance = Math.max(0, clearance);\n          const mt = v.subAssembly.materialThickness;\n          const faceOffsets = v.subAssembly.faceOffsets || { left: 0, right: 0, top: 0, bottom: 0, front: 0, back: 0 };\n\n          // Calculate outer dimensions (space available after clearance + face offsets)\n          const outerWidth = v.bounds.w - (newClearance * 2) + faceOffsets.left + faceOffsets.right;\n          const outerHeight = v.bounds.h - (newClearance * 2) + faceOffsets.top + faceOffsets.bottom;\n          const outerDepth = v.bounds.d - (newClearance * 2) + faceOffsets.front + faceOffsets.back;\n\n          // Calculate interior dimensions (outer minus walls on each side)\n          const interiorWidth = outerWidth - (2 * mt);\n          const interiorHeight = outerHeight - (2 * mt);\n          const interiorDepth = outerDepth - (2 * mt);\n\n          if (interiorWidth <= 0 || interiorHeight <= 0 || interiorDepth <= 0) {\n            return v; // Invalid clearance\n          }\n\n          return {\n            ...v,\n            subAssembly: {\n              ...v.subAssembly,\n              clearance: newClearance,\n              rootVoid: {\n                ...v.subAssembly.rootVoid,\n                bounds: { x: 0, y: 0, z: 0, w: interiorWidth, h: interiorHeight, d: interiorDepth },\n                children: [], // Reset children when clearance changes\n              },\n            },\n          };\n        }\n        return {\n          ...v,\n          children: v.children.map(updateSubAssemblyInVoid),\n        };\n      };\n\n      return {\n        rootVoid: updateSubAssemblyInVoid(state.rootVoid),\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  removeSubAssembly: (voidId) =>\n    set((state) => {\n      const newRootVoid = updateVoidInTree(state.rootVoid, voidId, (v) => ({\n        ...v,\n        subAssembly: undefined,\n      }));\n\n      return {\n        rootVoid: newRootVoid,\n        selectedVoidIds: new Set<string>(),\n        selectedSubAssemblyIds: new Set<string>(),\n        subdivisionPreview: null,\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  // Visibility actions\n  toggleVoidVisibility: (voidId) =>\n    set((state) => {\n      const newHiddenVoidIds = new Set(state.hiddenVoidIds);\n      if (newHiddenVoidIds.has(voidId)) {\n        newHiddenVoidIds.delete(voidId);\n      } else {\n        newHiddenVoidIds.add(voidId);\n      }\n      return { hiddenVoidIds: newHiddenVoidIds };\n    }),\n\n  setIsolatedVoid: (voidId) =>\n    set((state) => {\n      // Un-isolating: restore visibility of elements hidden by isolate\n      if (voidId === null) {\n        const newHiddenVoidIds = new Set(state.hiddenVoidIds);\n        const newHiddenFaceIds = new Set(state.hiddenFaceIds);\n        const newHiddenSubAssemblyIds = new Set(state.hiddenSubAssemblyIds);\n\n        // Remove only the IDs that were hidden by the isolate action\n        for (const id of state.isolateHiddenVoidIds) {\n          newHiddenVoidIds.delete(id);\n        }\n        for (const id of state.isolateHiddenFaceIds) {\n          newHiddenFaceIds.delete(id);\n        }\n        for (const id of state.isolateHiddenSubAssemblyIds) {\n          newHiddenSubAssemblyIds.delete(id);\n        }\n\n        return {\n          isolatedVoidId: null,\n          hiddenVoidIds: newHiddenVoidIds,\n          isolateHiddenVoidIds: new Set<string>(),\n          hiddenFaceIds: newHiddenFaceIds,\n          isolateHiddenFaceIds: new Set<string>(),\n          hiddenSubAssemblyIds: newHiddenSubAssemblyIds,\n          isolateHiddenSubAssemblyIds: new Set<string>(),\n        };\n      }\n\n      // Isolating: hide everything except the isolated void and its descendants\n      const isolatedVoid = findVoid(state.rootVoid, voidId);\n      if (!isolatedVoid) return state;\n\n      // Get all void IDs that should remain visible (isolated + descendants)\n      const visibleVoidIds = new Set(getVoidSubtreeIds(isolatedVoid));\n\n      // Get all void IDs in the tree\n      const allVoidIds = getVoidSubtreeIds(state.rootVoid);\n\n      // Build new hidden sets\n      const newHiddenVoidIds = new Set(state.hiddenVoidIds);\n      const newIsolateHiddenVoidIds = new Set<string>();\n      const newHiddenFaceIds = new Set(state.hiddenFaceIds);\n      const newIsolateHiddenFaceIds = new Set<string>();\n      const newHiddenSubAssemblyIds = new Set(state.hiddenSubAssemblyIds);\n      const newIsolateHiddenSubAssemblyIds = new Set<string>();\n\n      // Hide voids that should not be visible, and their divider panels\n      for (const id of allVoidIds) {\n        if (!visibleVoidIds.has(id) && !state.hiddenVoidIds.has(id)) {\n          newHiddenVoidIds.add(id);\n          newIsolateHiddenVoidIds.add(id);\n          // Also hide the divider panel for this void (if it has one)\n          const dividerId = `divider-${id}-split`;\n          if (!state.hiddenFaceIds.has(dividerId)) {\n            newHiddenFaceIds.add(dividerId);\n            newIsolateHiddenFaceIds.add(dividerId);\n          }\n        }\n      }\n\n      // Hide face panels for main box (since we're isolating a void, not main box)\n      const mainFaceIds = ['face-front', 'face-back', 'face-left', 'face-right', 'face-top', 'face-bottom'];\n      for (const faceId of mainFaceIds) {\n        if (!state.hiddenFaceIds.has(faceId)) {\n          newHiddenFaceIds.add(faceId);\n          newIsolateHiddenFaceIds.add(faceId);\n        }\n      }\n\n      // Hide sub-assemblies that are not in the isolated subtree\n      const allSubAssemblies = getAllSubAssemblies(state.rootVoid);\n      for (const { subAssembly, voidId: parentVoidId } of allSubAssemblies) {\n        // Sub-assembly is visible only if its parent void is in the visible subtree\n        if (!visibleVoidIds.has(parentVoidId) && !state.hiddenSubAssemblyIds.has(subAssembly.id)) {\n          newHiddenSubAssemblyIds.add(subAssembly.id);\n          newIsolateHiddenSubAssemblyIds.add(subAssembly.id);\n        }\n      }\n\n      return {\n        isolatedVoidId: voidId,\n        hiddenVoidIds: newHiddenVoidIds,\n        isolateHiddenVoidIds: newIsolateHiddenVoidIds,\n        hiddenFaceIds: newHiddenFaceIds,\n        isolateHiddenFaceIds: newIsolateHiddenFaceIds,\n        hiddenSubAssemblyIds: newHiddenSubAssemblyIds,\n        isolateHiddenSubAssemblyIds: newIsolateHiddenSubAssemblyIds,\n      };\n    }),\n\n  // Sub-assembly visibility actions\n  toggleSubAssemblyVisibility: (subAssemblyId) =>\n    set((state) => {\n      const newHiddenSubAssemblyIds = new Set(state.hiddenSubAssemblyIds);\n      if (newHiddenSubAssemblyIds.has(subAssemblyId)) {\n        newHiddenSubAssemblyIds.delete(subAssemblyId);\n      } else {\n        newHiddenSubAssemblyIds.add(subAssemblyId);\n      }\n      return { hiddenSubAssemblyIds: newHiddenSubAssemblyIds };\n    }),\n\n  setIsolatedSubAssembly: (subAssemblyId) =>\n    set((state) => {\n      // Un-isolating: restore visibility of elements hidden by isolate\n      if (subAssemblyId === null) {\n        const newHiddenVoidIds = new Set(state.hiddenVoidIds);\n        const newHiddenFaceIds = new Set(state.hiddenFaceIds);\n        const newHiddenSubAssemblyIds = new Set(state.hiddenSubAssemblyIds);\n\n        // Remove only the IDs that were hidden by the isolate action\n        for (const id of state.isolateHiddenVoidIds) {\n          newHiddenVoidIds.delete(id);\n        }\n        for (const id of state.isolateHiddenFaceIds) {\n          newHiddenFaceIds.delete(id);\n        }\n        for (const id of state.isolateHiddenSubAssemblyIds) {\n          newHiddenSubAssemblyIds.delete(id);\n        }\n\n        return {\n          isolatedSubAssemblyId: null,\n          hiddenVoidIds: newHiddenVoidIds,\n          isolateHiddenVoidIds: new Set<string>(),\n          hiddenFaceIds: newHiddenFaceIds,\n          isolateHiddenFaceIds: new Set<string>(),\n          hiddenSubAssemblyIds: newHiddenSubAssemblyIds,\n          isolateHiddenSubAssemblyIds: new Set<string>(),\n        };\n      }\n\n      // Isolating: hide everything except the isolated sub-assembly\n      const newHiddenVoidIds = new Set(state.hiddenVoidIds);\n      const newIsolateHiddenVoidIds = new Set<string>();\n      const newHiddenFaceIds = new Set(state.hiddenFaceIds);\n      const newIsolateHiddenFaceIds = new Set<string>();\n      const newHiddenSubAssemblyIds = new Set(state.hiddenSubAssemblyIds);\n      const newIsolateHiddenSubAssemblyIds = new Set<string>();\n\n      // Hide all voids and their divider panels\n      const allVoidIds = getVoidSubtreeIds(state.rootVoid);\n      for (const id of allVoidIds) {\n        if (!state.hiddenVoidIds.has(id)) {\n          newHiddenVoidIds.add(id);\n          newIsolateHiddenVoidIds.add(id);\n          // Also hide the divider panel for this void (if it has one)\n          const dividerId = `divider-${id}-split`;\n          if (!state.hiddenFaceIds.has(dividerId)) {\n            newHiddenFaceIds.add(dividerId);\n            newIsolateHiddenFaceIds.add(dividerId);\n          }\n        }\n      }\n\n      // Hide all main box face panels\n      const mainFaceIds = ['face-front', 'face-back', 'face-left', 'face-right', 'face-top', 'face-bottom'];\n      for (const faceId of mainFaceIds) {\n        if (!state.hiddenFaceIds.has(faceId)) {\n          newHiddenFaceIds.add(faceId);\n          newIsolateHiddenFaceIds.add(faceId);\n        }\n      }\n\n      // Hide all other sub-assemblies\n      const allSubAssemblies = getAllSubAssemblies(state.rootVoid);\n      for (const { subAssembly } of allSubAssemblies) {\n        if (subAssembly.id !== subAssemblyId && !state.hiddenSubAssemblyIds.has(subAssembly.id)) {\n          newHiddenSubAssemblyIds.add(subAssembly.id);\n          newIsolateHiddenSubAssemblyIds.add(subAssembly.id);\n        }\n      }\n\n      return {\n        isolatedSubAssemblyId: subAssemblyId,\n        hiddenVoidIds: newHiddenVoidIds,\n        isolateHiddenVoidIds: newIsolateHiddenVoidIds,\n        hiddenFaceIds: newHiddenFaceIds,\n        isolateHiddenFaceIds: newIsolateHiddenFaceIds,\n        hiddenSubAssemblyIds: newHiddenSubAssemblyIds,\n        isolateHiddenSubAssemblyIds: newIsolateHiddenSubAssemblyIds,\n      };\n    }),\n\n  // Face panel visibility actions\n  toggleFaceVisibility: (faceId) =>\n    set((state) => {\n      const newHiddenFaceIds = new Set(state.hiddenFaceIds);\n      if (newHiddenFaceIds.has(faceId)) {\n        newHiddenFaceIds.delete(faceId);\n      } else {\n        newHiddenFaceIds.add(faceId);\n      }\n      return { hiddenFaceIds: newHiddenFaceIds };\n    }),\n\n  setIsolatedPanel: (panelId) =>\n    set((state) => {\n      // Un-isolating: restore visibility of elements hidden by isolate\n      if (panelId === null) {\n        const newHiddenVoidIds = new Set(state.hiddenVoidIds);\n        const newHiddenFaceIds = new Set(state.hiddenFaceIds);\n        const newHiddenSubAssemblyIds = new Set(state.hiddenSubAssemblyIds);\n\n        // Remove only the IDs that were hidden by the isolate action\n        for (const id of state.isolateHiddenVoidIds) {\n          newHiddenVoidIds.delete(id);\n        }\n        for (const id of state.isolateHiddenFaceIds) {\n          newHiddenFaceIds.delete(id);\n        }\n        for (const id of state.isolateHiddenSubAssemblyIds) {\n          newHiddenSubAssemblyIds.delete(id);\n        }\n\n        return {\n          isolatedPanelId: null,\n          hiddenVoidIds: newHiddenVoidIds,\n          isolateHiddenVoidIds: new Set<string>(),\n          hiddenFaceIds: newHiddenFaceIds,\n          isolateHiddenFaceIds: new Set<string>(),\n          hiddenSubAssemblyIds: newHiddenSubAssemblyIds,\n          isolateHiddenSubAssemblyIds: new Set<string>(),\n        };\n      }\n\n      // Isolating: hide everything except the isolated panel\n      const newHiddenVoidIds = new Set(state.hiddenVoidIds);\n      const newIsolateHiddenVoidIds = new Set<string>();\n      const newHiddenFaceIds = new Set(state.hiddenFaceIds);\n      const newIsolateHiddenFaceIds = new Set<string>();\n      const newHiddenSubAssemblyIds = new Set(state.hiddenSubAssemblyIds);\n      const newIsolateHiddenSubAssemblyIds = new Set<string>();\n\n      // Hide all voids\n      const allVoidIds = getVoidSubtreeIds(state.rootVoid);\n      for (const id of allVoidIds) {\n        if (!state.hiddenVoidIds.has(id)) {\n          newHiddenVoidIds.add(id);\n          newIsolateHiddenVoidIds.add(id);\n        }\n      }\n\n      // Hide all face panels except the isolated one\n      const mainFaceIds = ['face-front', 'face-back', 'face-left', 'face-right', 'face-top', 'face-bottom'];\n      for (const faceId of mainFaceIds) {\n        if (faceId !== panelId && !state.hiddenFaceIds.has(faceId)) {\n          newHiddenFaceIds.add(faceId);\n          newIsolateHiddenFaceIds.add(faceId);\n        }\n      }\n\n      // Hide all divider panels except the isolated one\n      const getAllDividerIds = (node: Void): string[] => {\n        const ids: string[] = [];\n        for (const child of node.children) {\n          if (child.splitAxis) {\n            ids.push(`divider-${child.id}-split`);\n          }\n          ids.push(...getAllDividerIds(child));\n        }\n        return ids;\n      };\n      const allDividerIds = getAllDividerIds(state.rootVoid);\n      for (const dividerId of allDividerIds) {\n        if (dividerId !== panelId && !state.hiddenFaceIds.has(dividerId)) {\n          newHiddenFaceIds.add(dividerId);\n          newIsolateHiddenFaceIds.add(dividerId);\n        }\n      }\n\n      // Hide all sub-assemblies and their panels\n      const allSubAssemblies = getAllSubAssemblies(state.rootVoid);\n      for (const { subAssembly } of allSubAssemblies) {\n        if (!state.hiddenSubAssemblyIds.has(subAssembly.id)) {\n          newHiddenSubAssemblyIds.add(subAssembly.id);\n          newIsolateHiddenSubAssemblyIds.add(subAssembly.id);\n        }\n        // Also hide sub-assembly face panels\n        for (const face of subAssembly.faces) {\n          const subFaceId = `subasm-${subAssembly.id}-face-${face.id}`;\n          if (subFaceId !== panelId && !state.hiddenFaceIds.has(subFaceId)) {\n            newHiddenFaceIds.add(subFaceId);\n            newIsolateHiddenFaceIds.add(subFaceId);\n          }\n        }\n      }\n\n      return {\n        isolatedPanelId: panelId,\n        hiddenVoidIds: newHiddenVoidIds,\n        isolateHiddenVoidIds: newIsolateHiddenVoidIds,\n        hiddenFaceIds: newHiddenFaceIds,\n        isolateHiddenFaceIds: newIsolateHiddenFaceIds,\n        hiddenSubAssemblyIds: newHiddenSubAssemblyIds,\n        isolateHiddenSubAssemblyIds: newIsolateHiddenSubAssemblyIds,\n      };\n    }),\n\n  // Assembly config actions for main box\n  setAssemblyAxis: (axis) =>\n    set((state) => {\n      const newAssembly: AssemblyConfig = {\n        ...state.config.assembly,\n        assemblyAxis: axis,\n      };\n\n      // Rebuild the void structure with the new axis\n      // Preserve user subdivisions from the main interior\n      const userSubdivisions = getUserSubdivisions(state.rootVoid);\n      const newRootVoid = createRootVoidWithInsets(\n        state.config.width,\n        state.config.height,\n        state.config.depth,\n        newAssembly,\n        userSubdivisions\n      );\n\n      return {\n        config: {\n          ...state.config,\n          assembly: newAssembly,\n        },\n        rootVoid: newRootVoid,\n        // Clear selection when void structure changes\n        selectedVoidIds: new Set<string>(),\n        selectedPanelIds: new Set<string>(),\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  setLidTabDirection: (side, direction) =>\n    set((state) => {\n      const newInset = direction === 'tabs-in' ? 0 : state.config.assembly.lids[side].inset;\n      const newAssembly: AssemblyConfig = {\n        ...state.config.assembly,\n        lids: {\n          ...state.config.assembly.lids,\n          [side]: {\n            ...state.config.assembly.lids[side],\n            tabDirection: direction,\n            // If setting tabs-in and there's an inset, reset inset to 0\n            // (tabs-in doesn't work with inset)\n            inset: newInset,\n          },\n        },\n      };\n\n      // Rebuild the void structure if inset changed\n      const userSubdivisions = getUserSubdivisions(state.rootVoid);\n      const newRootVoid = createRootVoidWithInsets(\n        state.config.width,\n        state.config.height,\n        state.config.depth,\n        newAssembly,\n        userSubdivisions\n      );\n\n      return {\n        config: {\n          ...state.config,\n          assembly: newAssembly,\n        },\n        rootVoid: newRootVoid,\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  setLidInset: (side, inset) =>\n    set((state) => {\n      const newInset = Math.max(0, inset);\n      const newAssembly: AssemblyConfig = {\n        ...state.config.assembly,\n        lids: {\n          ...state.config.assembly.lids,\n          [side]: {\n            ...state.config.assembly.lids[side],\n            inset: newInset,\n            // If setting inset > 0, force tabs-out (tabs-in doesn't work with inset)\n            tabDirection: newInset > 0 ? 'tabs-out' : state.config.assembly.lids[side].tabDirection,\n          },\n        },\n      };\n\n      // Rebuild the void structure with the new insets\n      // Preserve user subdivisions from the main interior\n      const userSubdivisions = getUserSubdivisions(state.rootVoid);\n      const newRootVoid = createRootVoidWithInsets(\n        state.config.width,\n        state.config.height,\n        state.config.depth,\n        newAssembly,\n        userSubdivisions\n      );\n\n      return {\n        config: {\n          ...state.config,\n          assembly: newAssembly,\n        },\n        rootVoid: newRootVoid,\n        // Clear selection when void structure changes\n        selectedVoidIds: new Set<string>(),\n        selectedPanelIds: new Set<string>(),\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  setFeetConfig: (feetConfig) =>\n    set((state) => ({\n      config: {\n        ...state.config,\n        assembly: {\n          ...state.config.assembly,\n          feet: feetConfig,\n        },\n      },\n      panelsDirty: true,\n    })),\n\n  // Assembly config actions for sub-assemblies\n  setSubAssemblyAxis: (subAssemblyId, axis) =>\n    set((state) => {\n      const updateSubAssemblyInVoid = (v: Void): Void => {\n        if (v.subAssembly?.id === subAssemblyId) {\n          return {\n            ...v,\n            subAssembly: {\n              ...v.subAssembly,\n              assembly: {\n                ...v.subAssembly.assembly,\n                assemblyAxis: axis,\n              },\n            },\n          };\n        }\n        return {\n          ...v,\n          children: v.children.map(updateSubAssemblyInVoid),\n          subAssembly: v.subAssembly ? {\n            ...v.subAssembly,\n            rootVoid: updateSubAssemblyInVoid(v.subAssembly.rootVoid),\n          } : undefined,\n        };\n      };\n\n      return {\n        rootVoid: updateSubAssemblyInVoid(state.rootVoid),\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  setSubAssemblyLidTabDirection: (subAssemblyId, side, direction) =>\n    set((state) => {\n      const updateSubAssemblyInVoid = (v: Void): Void => {\n        if (v.subAssembly?.id === subAssemblyId) {\n          return {\n            ...v,\n            subAssembly: {\n              ...v.subAssembly,\n              assembly: {\n                ...v.subAssembly.assembly,\n                lids: {\n                  ...v.subAssembly.assembly.lids,\n                  [side]: {\n                    ...v.subAssembly.assembly.lids[side],\n                    tabDirection: direction,\n                    inset: direction === 'tabs-in' ? 0 : v.subAssembly.assembly.lids[side].inset,\n                  },\n                },\n              },\n            },\n          };\n        }\n        return {\n          ...v,\n          children: v.children.map(updateSubAssemblyInVoid),\n          subAssembly: v.subAssembly ? {\n            ...v.subAssembly,\n            rootVoid: updateSubAssemblyInVoid(v.subAssembly.rootVoid),\n          } : undefined,\n        };\n      };\n\n      return {\n        rootVoid: updateSubAssemblyInVoid(state.rootVoid),\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  setSubAssemblyLidInset: (subAssemblyId, side, inset) =>\n    set((state) => {\n      const updateSubAssemblyInVoid = (v: Void): Void => {\n        if (v.subAssembly?.id === subAssemblyId) {\n          return {\n            ...v,\n            subAssembly: {\n              ...v.subAssembly,\n              assembly: {\n                ...v.subAssembly.assembly,\n                lids: {\n                  ...v.subAssembly.assembly.lids,\n                  [side]: {\n                    ...v.subAssembly.assembly.lids[side],\n                    inset: Math.max(0, inset),\n                    tabDirection: inset > 0 ? 'tabs-out' : v.subAssembly.assembly.lids[side].tabDirection,\n                  },\n                },\n              },\n            },\n          };\n        }\n        return {\n          ...v,\n          children: v.children.map(updateSubAssemblyInVoid),\n          subAssembly: v.subAssembly ? {\n            ...v.subAssembly,\n            rootVoid: updateSubAssemblyInVoid(v.subAssembly.rootVoid),\n          } : undefined,\n        };\n      };\n\n      return {\n        rootVoid: updateSubAssemblyInVoid(state.rootVoid),\n        panelsDirty: true,  // Mark panels as needing regeneration\n      };\n    }),\n\n  // Panel path actions\n  generatePanels: () =>\n    set((state) => {\n      // Generate panel paths from current configuration\n      // Pass existing panels to preserve edge extensions during regeneration\n      const collection = generatePanelCollection(\n        state.faces,\n        state.rootVoid,\n        state.config,\n        1,  // Scale factor (1 = mm)\n        state.panelCollection?.panels\n      );\n\n      // Generate panels for all sub-assemblies\n      const subAssemblies = getAllSubAssemblies(state.rootVoid);\n      for (const { subAssembly, bounds: parentBounds } of subAssemblies) {\n        // Create a BoxConfig for the sub-assembly\n        // Note: width/height/depth must be INTERIOR dimensions (like main box config)\n        // The panel generator positions faces based on interior dimensions\n        const subConfig = {\n          width: subAssembly.rootVoid.bounds.w,\n          height: subAssembly.rootVoid.bounds.h,\n          depth: subAssembly.rootVoid.bounds.d,\n          materialThickness: subAssembly.materialThickness,\n          fingerWidth: state.config.fingerWidth,\n          fingerGap: state.config.fingerGap,\n          assembly: subAssembly.assembly,\n        };\n\n        // Generate panels for this sub-assembly\n        const subCollection = generatePanelCollection(\n          subAssembly.faces,\n          subAssembly.rootVoid,\n          subConfig,\n          1\n        );\n\n        // Calculate sub-assembly center position relative to main box center\n        const mainCenterX = state.config.width / 2;\n        const mainCenterY = state.config.height / 2;\n        const mainCenterZ = state.config.depth / 2;\n\n        // Outer dimensions = interior + 2*materialThickness\n        const subOuterW = subConfig.width + 2 * subAssembly.materialThickness;\n        const subOuterH = subConfig.height + 2 * subAssembly.materialThickness;\n        const subOuterD = subConfig.depth + 2 * subAssembly.materialThickness;\n\n        // Get face offsets (default to 0 if not set)\n        const offsets = subAssembly.faceOffsets || { left: 0, right: 0, top: 0, bottom: 0, front: 0, back: 0 };\n\n        // Sub-assembly is positioned inside the parent void with clearance\n        // Face offsets shift the base position: positive offset extends outward from clearance boundary\n        // Bottom-left-back corner is at (clearance - offset) from parent origin\n        const subCenterX = parentBounds.x + subAssembly.clearance - offsets.left + subOuterW / 2;\n        const subCenterY = parentBounds.y + subAssembly.clearance - offsets.bottom + subOuterH / 2;\n        const subCenterZ = parentBounds.z + subAssembly.clearance - offsets.back + subOuterD / 2;\n\n        // Offset from main box center (panels are centered at origin)\n        const offsetX = subCenterX - mainCenterX;\n        const offsetY = subCenterY - mainCenterY;\n        const offsetZ = subCenterZ - mainCenterZ;\n\n        // Add sub-assembly panels to main collection with adjusted positions and IDs\n        for (const panel of subCollection.panels) {\n          const offsetPanel = {\n            ...panel,\n            id: `subasm-${subAssembly.id}-${panel.id}`,\n            source: {\n              ...panel.source,\n              subAssemblyId: subAssembly.id,\n            },\n            position: [\n              panel.position[0] + offsetX,\n              panel.position[1] + offsetY,\n              panel.position[2] + offsetZ,\n            ] as [number, number, number],\n          };\n          collection.panels.push(offsetPanel);\n        }\n      }\n\n      return {\n        panelCollection: collection,\n        panelsDirty: false,\n      };\n    }),\n\n  clearPanels: () =>\n    set({\n      panelCollection: null,\n      panelsDirty: true,\n    }),\n\n  updatePanelPath: (panelId, updates) =>\n    set((state) => {\n      if (!state.panelCollection) return state;\n\n      return {\n        panelCollection: {\n          ...state.panelCollection,\n          panels: state.panelCollection.panels.map((panel) =>\n            panel.id === panelId ? { ...panel, ...updates } : panel\n          ),\n        },\n      };\n    }),\n\n  addPanelHole: (panelId, hole) =>\n    set((state) => {\n      if (!state.panelCollection) return state;\n\n      return {\n        panelCollection: {\n          ...state.panelCollection,\n          panels: state.panelCollection.panels.map((panel) =>\n            panel.id === panelId\n              ? { ...panel, holes: [...panel.holes, hole] }\n              : panel\n          ),\n        },\n      };\n    }),\n\n  removePanelHole: (panelId, holeId) =>\n    set((state) => {\n      if (!state.panelCollection) return state;\n\n      return {\n        panelCollection: {\n          ...state.panelCollection,\n          panels: state.panelCollection.panels.map((panel) =>\n            panel.id === panelId\n              ? { ...panel, holes: panel.holes.filter((h) => h.id !== holeId) }\n              : panel\n          ),\n        },\n      };\n    }),\n\n  addAugmentation: (augmentation) =>\n    set((state) => {\n      if (!state.panelCollection) return state;\n\n      // Add augmentation to the collection\n      const newAugmentations = [...state.panelCollection.augmentations, augmentation];\n\n      // Also add the hole to the target panel\n      const newPanels = state.panelCollection.panels.map((panel) =>\n        panel.id === augmentation.panelId\n          ? { ...panel, holes: [...panel.holes, augmentation.hole] }\n          : panel\n      );\n\n      return {\n        panelCollection: {\n          ...state.panelCollection,\n          panels: newPanels,\n          augmentations: newAugmentations,\n        },\n      };\n    }),\n\n  removeAugmentation: (augmentationId) =>\n    set((state) => {\n      if (!state.panelCollection) return state;\n\n      const augmentation = state.panelCollection.augmentations.find(\n        (a) => a.id === augmentationId\n      );\n      if (!augmentation) return state;\n\n      // Remove augmentation from the collection\n      const newAugmentations = state.panelCollection.augmentations.filter(\n        (a) => a.id !== augmentationId\n      );\n\n      // Also remove the hole from the target panel\n      const newPanels = state.panelCollection.panels.map((panel) =>\n        panel.id === augmentation.panelId\n          ? { ...panel, holes: panel.holes.filter((h) => h.id !== augmentation.hole.id) }\n          : panel\n      );\n\n      return {\n        panelCollection: {\n          ...state.panelCollection,\n          panels: newPanels,\n          augmentations: newAugmentations,\n        },\n      };\n    }),\n\n  togglePanelVisibility: (panelId) =>\n    set((state) => {\n      if (!state.panelCollection) return state;\n\n      return {\n        panelCollection: {\n          ...state.panelCollection,\n          panels: state.panelCollection.panels.map((panel) =>\n            panel.id === panelId ? { ...panel, visible: !panel.visible } : panel\n          ),\n        },\n      };\n    }),\n\n  setEdgeExtension: (panelId, edge, value) =>\n    set((state) => {\n      if (!state.panelCollection) return state;\n\n      // First, update the extension value on the panel\n      const updatedPanels = state.panelCollection.panels.map((panel) =>\n        panel.id === panelId\n          ? {\n              ...panel,\n              edgeExtensions: {\n                ...(panel.edgeExtensions || defaultEdgeExtensions),\n                [edge]: value,\n              },\n            }\n          : panel\n      );\n\n      // Now regenerate panels with the updated extensions\n      const collection = generatePanelCollection(\n        state.faces,\n        state.rootVoid,\n        state.config,\n        1,\n        updatedPanels  // Pass updated panels to preserve new extensions\n      );\n\n      return {\n        panelCollection: collection,\n      };\n    }),\n\n  setDividerPosition: (subdivisionId, newPosition) =>\n    set((state) => {\n      const mt = state.config.materialThickness;\n\n      // The subdivision ID is like \"abc123-split\", the void ID is \"abc123\"\n      const voidId = subdivisionId.replace('-split', '');\n\n      // Find the void that has this split position\n      const targetVoid = findVoid(state.rootVoid, voidId);\n      if (!targetVoid || !targetVoid.splitPosition || !targetVoid.splitAxis) {\n        return state;\n      }\n\n      // Find the parent to get sibling voids\n      const parent = findParent(state.rootVoid, voidId);\n      if (!parent) return state;\n\n      const axis = targetVoid.splitAxis;\n\n      // Find the index of this void in the parent's children\n      const voidIndex = parent.children.findIndex(c => c.id === voidId);\n      if (voidIndex === -1) return state;\n\n      // Calculate bounds constraints\n      // Previous divider position (or parent start)\n      const parentStart = axis === 'x' ? parent.bounds.x :\n                          axis === 'y' ? parent.bounds.y : parent.bounds.z;\n      const parentEnd = axis === 'x' ? parent.bounds.x + parent.bounds.w :\n                        axis === 'y' ? parent.bounds.y + parent.bounds.h :\n                        parent.bounds.z + parent.bounds.d;\n\n      // Find min position (previous divider + material thickness, or parent start + min void size)\n      const prevVoid = voidIndex > 0 ? parent.children[voidIndex - 1] : null;\n      const minPos = prevVoid?.splitPosition\n        ? prevVoid.splitPosition + mt + 1  // At least 1mm void space\n        : parentStart + mt / 2 + 1;\n\n      // Find max position (next divider - material thickness, or parent end - min void size)\n      const nextVoid = voidIndex < parent.children.length - 1 ? parent.children[voidIndex + 1] : null;\n      const maxPos = nextVoid?.splitPosition\n        ? nextVoid.splitPosition - mt - 1\n        : parentEnd - mt / 2 - 1;\n\n      // Clamp new position to valid range\n      const clampedPosition = Math.max(minPos, Math.min(maxPos, newPosition));\n\n      // Update the void tree\n      const updateVoidPosition = (node: Void): Void => {\n        if (node.id === parent.id) {\n          // This is the parent - update its children\n          const parentSize = axis === 'x' ? parent.bounds.w :\n                             axis === 'y' ? parent.bounds.h : parent.bounds.d;\n\n          const newChildren = parent.children.map((child) => {\n            if (child.id === voidId) {\n              // Calculate new percentage from position\n              const newPercentage = (clampedPosition - parentStart) / parentSize;\n              // Update this void's splitPosition and percentage\n              return {\n                ...child,\n                splitPosition: clampedPosition,\n                splitPercentage: newPercentage,\n              };\n            }\n            return child;\n          });\n\n          // Recalculate bounds for all children\n          const recalculatedChildren = newChildren.map((child, idx) => {\n            // Calculate region start\n            const regionStart = idx === 0\n              ? parentStart\n              : (newChildren[idx - 1].splitPosition ?? parentStart) + mt / 2;\n\n            // Calculate region end\n            const regionEnd = child.splitPosition\n              ? child.splitPosition - mt / 2\n              : parentEnd;\n\n            const regionSize = regionEnd - regionStart;\n\n            let newBounds: Bounds;\n            switch (axis) {\n              case 'x':\n                newBounds = { ...child.bounds, x: regionStart, w: regionSize };\n                break;\n              case 'y':\n                newBounds = { ...child.bounds, y: regionStart, h: regionSize };\n                break;\n              case 'z':\n                newBounds = { ...child.bounds, z: regionStart, d: regionSize };\n                break;\n            }\n\n            // Recursively update nested children's bounds if they exist\n            let updatedChildren = child.children;\n            if (child.children.length > 0) {\n              // Recalculate nested children bounds based on the new parent bounds\n              updatedChildren = recalculateNestedBounds(child.children, newBounds, child.splitAxis);\n            }\n\n            return { ...child, bounds: newBounds, children: updatedChildren };\n          });\n\n          return { ...node, children: recalculatedChildren };\n        }\n\n        return {\n          ...node,\n          children: node.children.map(updateVoidPosition),\n        };\n      };\n\n      // Helper to recalculate nested void bounds when their parent's bounds change\n      const recalculateNestedBounds = (children: Void[], parentBounds: Bounds, splitAxis?: 'x' | 'y' | 'z'): Void[] => {\n        if (!splitAxis || children.length === 0) return children;\n\n        const dimStart = splitAxis === 'x' ? parentBounds.x : splitAxis === 'y' ? parentBounds.y : parentBounds.z;\n        const dimEnd = splitAxis === 'x' ? parentBounds.x + parentBounds.w :\n                       splitAxis === 'y' ? parentBounds.y + parentBounds.h :\n                       parentBounds.z + parentBounds.d;\n\n        return children.map((child, idx) => {\n          // Calculate region for this child\n          const regionStart = idx === 0\n            ? dimStart\n            : (children[idx - 1].splitPosition ?? dimStart) + mt / 2;\n\n          const regionEnd = child.splitPosition\n            ? child.splitPosition - mt / 2\n            : dimEnd;\n\n          const regionSize = regionEnd - regionStart;\n\n          let newBounds: Bounds;\n          switch (splitAxis) {\n            case 'x':\n              newBounds = { ...parentBounds, x: regionStart, w: regionSize };\n              break;\n            case 'y':\n              newBounds = { ...parentBounds, y: regionStart, h: regionSize };\n              break;\n            case 'z':\n              newBounds = { ...parentBounds, z: regionStart, d: regionSize };\n              break;\n          }\n\n          // Recursively update this child's children\n          const updatedChildren = child.children.length > 0\n            ? recalculateNestedBounds(child.children, newBounds, child.splitAxis)\n            : child.children;\n\n          return { ...child, bounds: newBounds, children: updatedChildren };\n        });\n      };\n\n      const newRootVoid = updateVoidPosition(state.rootVoid);\n\n      // Regenerate panels\n      const collection = generatePanelCollection(\n        state.faces,\n        newRootVoid,\n        state.config,\n        1,\n        state.panelCollection?.panels\n      );\n\n      return {\n        rootVoid: newRootVoid,\n        panelCollection: collection,\n      };\n    }),\n\n  setDividerPositionMode: (subdivisionId, mode) =>\n    set((state) => {\n      // The subdivision ID is like \"abc123-split\", the void ID is \"abc123\"\n      const voidId = subdivisionId.replace('-split', '');\n\n      // Find the void that has this split position\n      const targetVoid = findVoid(state.rootVoid, voidId);\n      if (!targetVoid || !targetVoid.splitPosition || !targetVoid.splitAxis) {\n        return state;\n      }\n\n      // Find the parent to calculate percentage if switching to percentage mode\n      const parent = findParent(state.rootVoid, voidId);\n      if (!parent) return state;\n\n      const axis = targetVoid.splitAxis;\n      const parentStart = axis === 'x' ? parent.bounds.x :\n                          axis === 'y' ? parent.bounds.y : parent.bounds.z;\n      const parentSize = axis === 'x' ? parent.bounds.w :\n                         axis === 'y' ? parent.bounds.h : parent.bounds.d;\n\n      // Calculate percentage from current position\n      const percentage = (targetVoid.splitPosition - parentStart) / parentSize;\n\n      // Update the void in the tree\n      const newRootVoid = updateVoidInTree(state.rootVoid, voidId, (v) => ({\n        ...v,\n        splitPositionMode: mode,\n        splitPercentage: percentage,\n      }));\n\n      return {\n        rootVoid: newRootVoid,\n        panelsDirty: true,\n      };\n    }),\n\n  // URL state management\n  loadFromUrl: () => {\n    const loaded = loadFromUrl();\n    if (!loaded) return false;\n\n    // Apply loaded state\n    const state = get();\n\n    // Collect edge extensions from loaded data\n    const edgeExtensionsMap = loaded.edgeExtensions;\n\n    // Create panels with loaded extensions\n    const panelsWithExtensions = state.panelCollection?.panels.map(panel => ({\n      ...panel,\n      edgeExtensions: edgeExtensionsMap[panel.id] ?? defaultEdgeExtensions,\n    }));\n\n    // Generate new panel collection with loaded config\n    const collection = generatePanelCollection(\n      loaded.faces,\n      loaded.rootVoid,\n      loaded.config,\n      1,\n      panelsWithExtensions\n    );\n\n    // Apply edge extensions to newly generated panels\n    if (collection && Object.keys(edgeExtensionsMap).length > 0) {\n      collection.panels = collection.panels.map(panel => ({\n        ...panel,\n        edgeExtensions: edgeExtensionsMap[panel.id] ?? panel.edgeExtensions,\n      }));\n    }\n\n    set({\n      config: loaded.config,\n      faces: loaded.faces,\n      rootVoid: loaded.rootVoid,\n      panelCollection: collection,\n      panelsDirty: false,\n      selectedVoidIds: new Set<string>(),\n      selectedPanelIds: new Set<string>(),\n      selectedAssemblyId: null,\n      selectedSubAssemblyIds: new Set<string>(),\n    });\n\n    return true;\n  },\n\n  saveToUrl: () => {\n    const state = get();\n\n    // Collect edge extensions from panels\n    const edgeExtensions: Record<string, EdgeExtensions> = {};\n    if (state.panelCollection) {\n      for (const panel of state.panelCollection.panels) {\n        if (panel.edgeExtensions &&\n            (panel.edgeExtensions.top !== 0 ||\n             panel.edgeExtensions.bottom !== 0 ||\n             panel.edgeExtensions.left !== 0 ||\n             panel.edgeExtensions.right !== 0)) {\n          edgeExtensions[panel.id] = panel.edgeExtensions;\n        }\n      }\n    }\n\n    const projectState: ProjectState = {\n      config: state.config,\n      faces: state.faces,\n      rootVoid: state.rootVoid,\n      edgeExtensions,\n    };\n\n    saveStateToUrl(projectState);\n  },\n\n  getShareableUrl: () => {\n    const state = get();\n\n    // Collect edge extensions from panels\n    const edgeExtensions: Record<string, EdgeExtensions> = {};\n    if (state.panelCollection) {\n      for (const panel of state.panelCollection.panels) {\n        if (panel.edgeExtensions &&\n            (panel.edgeExtensions.top !== 0 ||\n             panel.edgeExtensions.bottom !== 0 ||\n             panel.edgeExtensions.left !== 0 ||\n             panel.edgeExtensions.right !== 0)) {\n          edgeExtensions[panel.id] = panel.edgeExtensions;\n        }\n      }\n    }\n\n    const projectState: ProjectState = {\n      config: state.config,\n      faces: state.faces,\n      rootVoid: state.rootVoid,\n      edgeExtensions,\n    };\n\n    return getShareUrl(projectState);\n  },\n\n  toggleDebugAnchors: () =>\n    set((state) => ({\n      showDebugAnchors: !state.showDebugAnchors,\n    })),\n\n  // 2D Sketch View actions\n  setViewMode: (mode) =>\n    set({ viewMode: mode }),\n\n  enterSketchView: (panelId) =>\n    set({\n      viewMode: '2d',\n      sketchPanelId: panelId,\n      // Select the panel being edited\n      selectedPanelIds: new Set([panelId]),\n      selectedVoidIds: new Set<string>(),\n      selectedSubAssemblyIds: new Set<string>(),\n      selectedAssemblyId: null,\n    }),\n\n  exitSketchView: () =>\n    set({\n      viewMode: '3d',\n      sketchPanelId: null,\n    }),\n}));\n","import React from 'react';\n\ninterface PanelProps {\n  title: string;\n  children: React.ReactNode;\n  className?: string;\n}\n\nexport const Panel: React.FC<PanelProps> = ({ title, children, className = '' }) => {\n  return (\n    <div className={`panel ${className}`}>\n      <h3 className=\"panel-title\">{title}</h3>\n      <div className=\"panel-content\">{children}</div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { useBoxStore, getMainInteriorVoid } from '../store/useBoxStore';\nimport { Panel } from './UI/Panel';\nimport { Void, SubAssembly, Face, FaceId } from '../types';\n\n// Represents a divider panel created by a subdivision\ninterface DividerPanel {\n  id: string;\n  axis: 'x' | 'y' | 'z';\n  position: number;\n  width: number;\n  height: number;\n}\n\n// Represents an outer face panel\ninterface OuterFacePanel {\n  id: string;\n  faceId: FaceId;\n  label: string;\n  solid: boolean;\n}\n\nconst faceLabels: Record<FaceId, string> = {\n  front: 'Front',\n  back: 'Back',\n  left: 'Left',\n  right: 'Right',\n  top: 'Top',\n  bottom: 'Bottom',\n};\n\n// Extract divider panels from a void's children\nconst getDividerPanels = (parent: Void): DividerPanel[] => {\n  const panels: DividerPanel[] = [];\n  for (const child of parent.children) {\n    if (child.splitAxis && child.splitPosition !== undefined) {\n      let width: number, height: number;\n      switch (child.splitAxis) {\n        case 'x':\n          width = parent.bounds.d;\n          height = parent.bounds.h;\n          break;\n        case 'y':\n          width = parent.bounds.w;\n          height = parent.bounds.d;\n          break;\n        case 'z':\n          width = parent.bounds.w;\n          height = parent.bounds.h;\n          break;\n      }\n      panels.push({\n        id: `divider-${child.id}-split`,\n        axis: child.splitAxis,\n        position: child.splitPosition,\n        width,\n        height,\n      });\n    }\n  }\n  return panels;\n};\n\n// Common props for tree operations\ninterface TreeOpsProps {\n  selectedVoidIds: Set<string>;\n  selectedSubAssemblyIds: Set<string>;\n  selectedPanelIds: Set<string>;\n  selectedAssemblyId: string | null;\n  onSelectVoid: (id: string | null, additive?: boolean) => void;\n  onSelectSubAssembly: (id: string | null, additive?: boolean) => void;\n  onSelectPanel: (id: string | null, additive?: boolean) => void;\n  onSelectAssembly: (id: string | null) => void;\n  // Hover state\n  hoveredVoidId: string | null;\n  hoveredPanelId: string | null;\n  hoveredAssemblyId: string | null;\n  onHoverVoid: (id: string | null) => void;\n  onHoverPanel: (id: string | null) => void;\n  onHoverAssembly: (id: string | null) => void;\n  // Visibility\n  hiddenVoidIds: Set<string>;\n  isolatedVoidId: string | null;\n  onToggleVisibility: (id: string) => void;\n  onSetIsolated: (id: string | null) => void;\n  hiddenSubAssemblyIds: Set<string>;\n  isolatedSubAssemblyId: string | null;\n  onToggleSubAssemblyVisibility: (id: string) => void;\n  onSetIsolatedSubAssembly: (id: string | null) => void;\n  hiddenFaceIds: Set<string>;\n  isolatedPanelId: string | null;\n  onToggleFaceVisibility: (faceId: string) => void;\n  onSetIsolatedPanel: (panelId: string | null) => void;\n  onDeleteVoid: (voidId: string) => void;\n  onDeleteSubAssembly: (voidId: string) => void;\n}\n\n// Outer face panel node (for main box or sub-assembly)\nconst OuterPanelNode: React.FC<{\n  panel: OuterFacePanel;\n  depth: number;\n  selectedPanelIds: Set<string>;\n  onSelectPanel: (id: string | null, additive?: boolean) => void;\n  hoveredPanelId: string | null;\n  onHoverPanel: (id: string | null) => void;\n  hiddenFaceIds: Set<string>;\n  isolatedPanelId: string | null;\n  onToggleFaceVisibility: (faceId: string) => void;\n  onSetIsolatedPanel: (panelId: string | null) => void;\n}> = ({ panel, depth, selectedPanelIds, onSelectPanel, hoveredPanelId, onHoverPanel, hiddenFaceIds, isolatedPanelId, onToggleFaceVisibility, onSetIsolatedPanel }) => {\n  const isSelected = selectedPanelIds.has(panel.id);\n  const isHovered = hoveredPanelId === panel.id;\n  const isHidden = hiddenFaceIds.has(panel.id);\n  const isIsolated = isolatedPanelId === panel.id;\n\n  return (\n    <div className=\"tree-node\">\n      <div\n        className={`tree-node-content panel ${isSelected ? 'selected' : ''} ${isHovered ? 'hovered' : ''} ${!panel.solid ? 'open-face' : ''} ${isHidden ? 'hidden' : ''} ${isIsolated ? 'isolated' : ''}`}\n        style={{ paddingLeft: `${depth * 16 + 8}px` }}\n        onMouseEnter={() => onHoverPanel(panel.id)}\n        onMouseLeave={() => onHoverPanel(null)}\n      >\n        <span\n          className=\"tree-node-main\"\n          onClick={(e) => onSelectPanel(panel.id, e.shiftKey)}\n        >\n          <span className=\"tree-icon\">{panel.solid ? '' : ''}</span>\n          <span className=\"tree-label\">{panel.label}</span>\n          <span className=\"tree-status\">{panel.solid ? '' : '(open)'}</span>\n        </span>\n        {panel.solid && (\n          <span className=\"tree-controls\">\n            <button\n              className={`tree-btn ${isHidden ? 'active' : ''}`}\n              onClick={(e) => {\n                e.stopPropagation();\n                onToggleFaceVisibility(panel.id);\n              }}\n              title={isHidden ? 'Show' : 'Hide'}\n            >\n              {isHidden ? '' : ''}\n            </button>\n            <button\n              className={`tree-btn ${isIsolated ? 'active' : ''}`}\n              onClick={(e) => {\n                e.stopPropagation();\n                onSetIsolatedPanel(isIsolated ? null : panel.id);\n              }}\n              title={isIsolated ? 'Unisolate' : 'Isolate'}\n            >\n              \n            </button>\n          </span>\n        )}\n      </div>\n    </div>\n  );\n};\n\n// Divider panel node (created by subdivision)\nconst DividerPanelNode: React.FC<{\n  panel: DividerPanel;\n  depth: number;\n  selectedPanelIds: Set<string>;\n  onSelectPanel: (id: string | null, additive?: boolean) => void;\n  hoveredPanelId: string | null;\n  onHoverPanel: (id: string | null) => void;\n  hiddenFaceIds: Set<string>;\n  isolatedPanelId: string | null;\n  onToggleFaceVisibility: (faceId: string) => void;\n  onSetIsolatedPanel: (panelId: string | null) => void;\n  onDelete: (voidId: string) => void;\n}> = ({ panel, depth, selectedPanelIds, onSelectPanel, hoveredPanelId, onHoverPanel, hiddenFaceIds, isolatedPanelId, onToggleFaceVisibility, onSetIsolatedPanel, onDelete }) => {\n  const isSelected = selectedPanelIds.has(panel.id);\n  const isHovered = hoveredPanelId === panel.id;\n  const isHidden = hiddenFaceIds.has(panel.id);\n  const isIsolated = isolatedPanelId === panel.id;\n  const axisLabel = panel.axis.toUpperCase();\n  const voidId = panel.id.replace('divider-', '').replace('-split', '');\n\n  return (\n    <div className=\"tree-node\">\n      <div\n        className={`tree-node-content panel ${isSelected ? 'selected' : ''} ${isHovered ? 'hovered' : ''} ${isHidden ? 'hidden' : ''} ${isIsolated ? 'isolated' : ''}`}\n        style={{ paddingLeft: `${depth * 16 + 8}px` }}\n        onMouseEnter={() => onHoverPanel(panel.id)}\n        onMouseLeave={() => onHoverPanel(null)}\n      >\n        <span\n          className=\"tree-node-main\"\n          onClick={(e) => onSelectPanel(panel.id, e.shiftKey)}\n        >\n          <span className=\"tree-icon\"></span>\n          <span className=\"tree-label\">Divider @ {axisLabel}={panel.position.toFixed(0)}</span>\n          <span className=\"tree-dimensions\">{panel.width.toFixed(0)}{panel.height.toFixed(0)}</span>\n        </span>\n        <span className=\"tree-controls\">\n          <button\n            className={`tree-btn ${isHidden ? 'active' : ''}`}\n            onClick={(e) => {\n              e.stopPropagation();\n              onToggleFaceVisibility(panel.id);\n            }}\n            title={isHidden ? 'Show' : 'Hide'}\n          >\n            {isHidden ? '' : ''}\n          </button>\n          <button\n            className={`tree-btn ${isIsolated ? 'active' : ''}`}\n            onClick={(e) => {\n              e.stopPropagation();\n              onSetIsolatedPanel(isIsolated ? null : panel.id);\n            }}\n            title={isIsolated ? 'Unisolate' : 'Isolate'}\n          >\n            \n          </button>\n          <button\n            className=\"tree-btn delete\"\n            onClick={(e) => {\n              e.stopPropagation();\n              onDelete(voidId);\n            }}\n            title=\"Delete subdivision\"\n          >\n            \n          </button>\n        </span>\n      </div>\n    </div>\n  );\n};\n\n// Void node (interior space that can be subdivided or contain sub-assemblies)\ninterface VoidNodeProps extends TreeOpsProps {\n  node: Void;\n  depth: number;\n  label?: string;\n}\n\nconst VoidNode: React.FC<VoidNodeProps> = ({\n  node,\n  depth,\n  label,\n  selectedVoidIds,\n  selectedSubAssemblyIds,\n  selectedPanelIds,\n  selectedAssemblyId,\n  onSelectVoid,\n  onSelectSubAssembly,\n  onSelectPanel,\n  onSelectAssembly,\n  hoveredVoidId,\n  hoveredPanelId,\n  hoveredAssemblyId,\n  onHoverVoid,\n  onHoverPanel,\n  onHoverAssembly,\n  hiddenVoidIds,\n  isolatedVoidId,\n  onToggleVisibility,\n  onSetIsolated,\n  hiddenSubAssemblyIds,\n  isolatedSubAssemblyId,\n  onToggleSubAssemblyVisibility,\n  onSetIsolatedSubAssembly,\n  hiddenFaceIds,\n  isolatedPanelId,\n  onToggleFaceVisibility,\n  onSetIsolatedPanel,\n  onDeleteVoid,\n  onDeleteSubAssembly,\n}) => {\n  const isSelected = selectedVoidIds.has(node.id);\n  const isHovered = hoveredVoidId === node.id;\n  const isLeaf = node.children.length === 0 && !node.subAssembly;\n  const hasChildren = node.children.length > 0;\n  const hasSubAssembly = !!node.subAssembly;\n  const isHidden = hiddenVoidIds.has(node.id);\n  const isIsolated = isolatedVoidId === node.id;\n\n  const dividerPanels = hasChildren ? getDividerPanels(node) : [];\n\n  const getLabel = () => {\n    if (label) return label;\n    // Special labels for lid inset voids\n    if (node.lidInsetSide === 'positive') return 'Lid Cap (Top/Right/Front)';\n    if (node.lidInsetSide === 'negative') return 'Lid Cap (Bottom/Left/Back)';\n    if (node.isMainInterior) return 'Main Interior';\n    return 'Void';\n  };\n\n  const getDimensions = () => {\n    const { w, h, d } = node.bounds;\n    return `${w.toFixed(0)}${h.toFixed(0)}${d.toFixed(0)}`;\n  };\n\n  const getIcon = () => {\n    if (hasSubAssembly) return '';\n    if (node.lidInsetSide) return '';  // Lid cap icon\n    if (isLeaf) return '';\n    return '';\n  };\n\n  const treeOps: TreeOpsProps = {\n    selectedVoidIds,\n    selectedSubAssemblyIds,\n    selectedPanelIds,\n    selectedAssemblyId,\n    onSelectVoid,\n    onSelectSubAssembly,\n    onSelectPanel,\n    onSelectAssembly,\n    hoveredVoidId,\n    hoveredPanelId,\n    hoveredAssemblyId,\n    onHoverVoid,\n    onHoverPanel,\n    onHoverAssembly,\n    hiddenVoidIds,\n    isolatedVoidId,\n    onToggleVisibility,\n    onSetIsolated,\n    hiddenSubAssemblyIds,\n    isolatedSubAssemblyId,\n    onToggleSubAssemblyVisibility,\n    onSetIsolatedSubAssembly,\n    hiddenFaceIds,\n    isolatedPanelId,\n    onToggleFaceVisibility,\n    onSetIsolatedPanel,\n    onDeleteVoid,\n    onDeleteSubAssembly,\n  };\n\n  return (\n    <div className=\"tree-node\">\n      <div\n        className={`tree-node-content ${isSelected ? 'selected' : ''} ${isHovered ? 'hovered' : ''} ${isLeaf ? 'leaf' : 'branch'} ${isHidden ? 'hidden' : ''} ${isIsolated ? 'isolated' : ''}`}\n        style={{ paddingLeft: `${depth * 16 + 8}px` }}\n        onMouseEnter={() => onHoverVoid(node.id)}\n        onMouseLeave={() => onHoverVoid(null)}\n      >\n        <span\n          className=\"tree-node-main\"\n          onClick={(e) => onSelectVoid(node.id, e.shiftKey)}\n        >\n          <span className=\"tree-icon\">{getIcon()}</span>\n          <span className=\"tree-label\">{getLabel()}</span>\n          <span className=\"tree-dimensions\">{getDimensions()}</span>\n        </span>\n        <span className=\"tree-controls\">\n          <button\n            className={`tree-btn ${isHidden ? 'active' : ''}`}\n            onClick={(e) => {\n              e.stopPropagation();\n              onToggleVisibility(node.id);\n            }}\n            title={isHidden ? 'Show' : 'Hide'}\n          >\n            {isHidden ? '' : ''}\n          </button>\n          <button\n            className={`tree-btn ${isIsolated ? 'active' : ''}`}\n            onClick={(e) => {\n              e.stopPropagation();\n              onSetIsolated(isIsolated ? null : node.id);\n            }}\n            title={isIsolated ? 'Unisolate' : 'Isolate'}\n          >\n            \n          </button>\n        </span>\n      </div>\n\n      {/* Show sub-assembly if present */}\n      {hasSubAssembly && (\n        <div className=\"tree-children\">\n          <SubAssemblyNode\n            subAssembly={node.subAssembly!}\n            parentVoidId={node.id}\n            depth={depth + 1}\n            {...treeOps}\n          />\n        </div>\n      )}\n\n      {/* Show divider panels and child voids interleaved in spatial order */}\n      {hasChildren && (\n        <div className=\"tree-children\">\n          {node.children.map((child) => {\n            const panel = dividerPanels.find(p => p.id === `divider-${child.id}-split`);\n\n            return (\n              <React.Fragment key={child.id}>\n                {panel && (\n                  <DividerPanelNode\n                    panel={panel}\n                    depth={depth + 1}\n                    selectedPanelIds={selectedPanelIds}\n                    onSelectPanel={onSelectPanel}\n                    hoveredPanelId={hoveredPanelId}\n                    onHoverPanel={onHoverPanel}\n                    hiddenFaceIds={hiddenFaceIds}\n                    isolatedPanelId={isolatedPanelId}\n                    onToggleFaceVisibility={onToggleFaceVisibility}\n                    onSetIsolatedPanel={onSetIsolatedPanel}\n                    onDelete={onDeleteVoid}\n                  />\n                )}\n                <VoidNode\n                  node={child}\n                  depth={depth + 1}\n                  {...treeOps}\n                />\n              </React.Fragment>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Sub-assembly node (drawer, tray, insert)\ninterface SubAssemblyNodeProps extends TreeOpsProps {\n  subAssembly: SubAssembly;\n  parentVoidId: string;\n  depth: number;\n}\n\nconst SubAssemblyNode: React.FC<SubAssemblyNodeProps> = ({\n  subAssembly,\n  parentVoidId,\n  depth,\n  selectedVoidIds,\n  selectedSubAssemblyIds,\n  selectedPanelIds,\n  selectedAssemblyId,\n  onSelectVoid,\n  onSelectSubAssembly,\n  onSelectPanel,\n  onSelectAssembly,\n  hoveredVoidId,\n  hoveredPanelId,\n  hoveredAssemblyId,\n  onHoverVoid,\n  onHoverPanel,\n  onHoverAssembly,\n  hiddenVoidIds,\n  isolatedVoidId,\n  onToggleVisibility,\n  onSetIsolated,\n  hiddenSubAssemblyIds,\n  isolatedSubAssemblyId,\n  onToggleSubAssemblyVisibility,\n  onSetIsolatedSubAssembly,\n  hiddenFaceIds,\n  isolatedPanelId,\n  onToggleFaceVisibility,\n  onSetIsolatedPanel,\n  onDeleteVoid,\n  onDeleteSubAssembly,\n}) => {\n  const isSelected = selectedSubAssemblyIds.has(subAssembly.id);\n  const isAssemblySelected = selectedAssemblyId === subAssembly.id;\n  const isAssemblyHovered = hoveredAssemblyId === subAssembly.id;\n  const { rootVoid } = subAssembly;\n  const isHidden = hiddenSubAssemblyIds.has(subAssembly.id);\n  const isIsolated = isolatedSubAssemblyId === subAssembly.id;\n\n  const getTypeLabel = () => 'Nested Box';\n  const getTypeIcon = () => '';\n\n  const getDimensions = () => {\n    const { w, h, d } = rootVoid.bounds;\n    return `${w.toFixed(0)}${h.toFixed(0)}${d.toFixed(0)}`;\n  };\n\n  const outerFacePanels: OuterFacePanel[] = subAssembly.faces.map((face) => ({\n    id: `subasm-${subAssembly.id}-face-${face.id}`,\n    faceId: face.id,\n    label: faceLabels[face.id],\n    solid: face.solid,\n  }));\n\n  const treeOps: TreeOpsProps = {\n    selectedVoidIds,\n    selectedSubAssemblyIds,\n    selectedPanelIds,\n    selectedAssemblyId,\n    onSelectVoid,\n    onSelectSubAssembly,\n    onSelectPanel,\n    onSelectAssembly,\n    hoveredVoidId,\n    hoveredPanelId,\n    hoveredAssemblyId,\n    onHoverVoid,\n    onHoverPanel,\n    onHoverAssembly,\n    hiddenVoidIds,\n    isolatedVoidId,\n    onToggleVisibility,\n    onSetIsolated,\n    hiddenSubAssemblyIds,\n    isolatedSubAssemblyId,\n    onToggleSubAssemblyVisibility,\n    onSetIsolatedSubAssembly,\n    hiddenFaceIds,\n    isolatedPanelId,\n    onToggleFaceVisibility,\n    onSetIsolatedPanel,\n    onDeleteVoid,\n    onDeleteSubAssembly,\n  };\n\n  return (\n    <div className=\"tree-node\">\n      <div\n        className={`tree-node-content subassembly ${isSelected || isAssemblySelected ? 'selected' : ''} ${isAssemblyHovered ? 'hovered' : ''} ${isHidden ? 'hidden' : ''} ${isIsolated ? 'isolated' : ''}`}\n        style={{ paddingLeft: `${depth * 16 + 8}px` }}\n        onMouseEnter={() => onHoverAssembly(subAssembly.id)}\n        onMouseLeave={() => onHoverAssembly(null)}\n      >\n        <span\n          className=\"tree-node-main\"\n          onClick={(e) => onSelectSubAssembly(subAssembly.id, e.shiftKey)}\n        >\n          <span className=\"tree-icon\">{getTypeIcon()}</span>\n          <span className=\"tree-label\">{getTypeLabel()}</span>\n          <span className=\"tree-dimensions\">{getDimensions()}</span>\n        </span>\n        <span className=\"tree-controls\">\n          <button\n            className={`tree-btn ${isHidden ? 'active' : ''}`}\n            onClick={(e) => {\n              e.stopPropagation();\n              onToggleSubAssemblyVisibility(subAssembly.id);\n            }}\n            title={isHidden ? 'Show' : 'Hide'}\n          >\n            {isHidden ? '' : ''}\n          </button>\n          <button\n            className={`tree-btn ${isIsolated ? 'active' : ''}`}\n            onClick={(e) => {\n              e.stopPropagation();\n              onSetIsolatedSubAssembly(isIsolated ? null : subAssembly.id);\n            }}\n            title={isIsolated ? 'Unisolate' : 'Isolate'}\n          >\n            \n          </button>\n          <button\n            className=\"tree-btn delete\"\n            onClick={(e) => {\n              e.stopPropagation();\n              onDeleteSubAssembly(parentVoidId);\n            }}\n            title=\"Delete sub-assembly\"\n          >\n            \n          </button>\n        </span>\n      </div>\n\n      {/* Outer face panels */}\n      <div className=\"tree-children\">\n        {outerFacePanels.map((panel) => (\n          <OuterPanelNode\n            key={panel.id}\n            panel={panel}\n            depth={depth + 1}\n            selectedPanelIds={selectedPanelIds}\n            onSelectPanel={onSelectPanel}\n            hoveredPanelId={hoveredPanelId}\n            onHoverPanel={onHoverPanel}\n            hiddenFaceIds={hiddenFaceIds}\n            isolatedPanelId={isolatedPanelId}\n            onToggleFaceVisibility={onToggleFaceVisibility}\n            onSetIsolatedPanel={onSetIsolatedPanel}\n          />\n        ))}\n      </div>\n\n      {/* Interior void */}\n      <div className=\"tree-children\">\n        <VoidNode\n          node={rootVoid}\n          depth={depth + 1}\n          label=\"Interior\"\n          {...treeOps}\n        />\n      </div>\n    </div>\n  );\n};\n\n// Main box assembly node\ninterface MainBoxNodeProps extends TreeOpsProps {\n  rootVoid: Void;\n  faces: Face[];\n  depth: number;\n}\n\nconst MainBoxNode: React.FC<MainBoxNodeProps> = ({\n  rootVoid,\n  faces,\n  depth,\n  selectedVoidIds,\n  selectedSubAssemblyIds,\n  selectedPanelIds,\n  selectedAssemblyId,\n  onSelectVoid,\n  onSelectSubAssembly,\n  onSelectPanel,\n  onSelectAssembly,\n  hoveredVoidId,\n  hoveredPanelId,\n  hoveredAssemblyId,\n  onHoverVoid,\n  onHoverPanel,\n  onHoverAssembly,\n  hiddenVoidIds,\n  isolatedVoidId,\n  onToggleVisibility,\n  onSetIsolated,\n  hiddenSubAssemblyIds,\n  isolatedSubAssemblyId,\n  onToggleSubAssemblyVisibility,\n  onSetIsolatedSubAssembly,\n  hiddenFaceIds,\n  isolatedPanelId,\n  onToggleFaceVisibility,\n  onSetIsolatedPanel,\n  onDeleteVoid,\n  onDeleteSubAssembly,\n}) => {\n  const isSelected = selectedAssemblyId === 'main';\n  const isHovered = hoveredAssemblyId === 'main';\n  const { w, h, d } = rootVoid.bounds;\n\n  // Get the main interior void - this is where user subdivisions go\n  // When lid insets exist, this is the 'main-interior' child, otherwise it's rootVoid itself\n  const interiorVoid = getMainInteriorVoid(rootVoid);\n\n  const outerFacePanels: OuterFacePanel[] = faces.map((face) => ({\n    id: `face-${face.id}`,\n    faceId: face.id,\n    label: faceLabels[face.id],\n    solid: face.solid,\n  }));\n\n  const treeOps: TreeOpsProps = {\n    selectedVoidIds,\n    selectedSubAssemblyIds,\n    selectedPanelIds,\n    selectedAssemblyId,\n    onSelectVoid,\n    onSelectSubAssembly,\n    onSelectPanel,\n    onSelectAssembly,\n    hoveredVoidId,\n    hoveredPanelId,\n    hoveredAssemblyId,\n    onHoverVoid,\n    onHoverPanel,\n    onHoverAssembly,\n    hiddenVoidIds,\n    isolatedVoidId,\n    onToggleVisibility,\n    onSetIsolated,\n    hiddenSubAssemblyIds,\n    isolatedSubAssemblyId,\n    onToggleSubAssemblyVisibility,\n    onSetIsolatedSubAssembly,\n    hiddenFaceIds,\n    isolatedPanelId,\n    onToggleFaceVisibility,\n    onSetIsolatedPanel,\n    onDeleteVoid,\n    onDeleteSubAssembly,\n  };\n\n  return (\n    <div className=\"tree-node\">\n      <div\n        className={`tree-node-content assembly ${isSelected ? 'selected' : ''} ${isHovered ? 'hovered' : ''}`}\n        style={{ paddingLeft: `${depth * 16 + 8}px` }}\n        onClick={() => onSelectAssembly(isSelected ? null : 'main')}\n        onMouseEnter={() => onHoverAssembly('main')}\n        onMouseLeave={() => onHoverAssembly(null)}\n      >\n        <span className=\"tree-node-main\">\n          <span className=\"tree-icon\"></span>\n          <span className=\"tree-label\">Main Box</span>\n          <span className=\"tree-dimensions\">{w.toFixed(0)}{h.toFixed(0)}{d.toFixed(0)}</span>\n        </span>\n      </div>\n\n      {/* Outer face panels */}\n      <div className=\"tree-children\">\n        {outerFacePanels.map((panel) => (\n          <OuterPanelNode\n            key={panel.id}\n            panel={panel}\n            depth={depth + 1}\n            selectedPanelIds={selectedPanelIds}\n            onSelectPanel={onSelectPanel}\n            hoveredPanelId={hoveredPanelId}\n            onHoverPanel={onHoverPanel}\n            hiddenFaceIds={hiddenFaceIds}\n            isolatedPanelId={isolatedPanelId}\n            onToggleFaceVisibility={onToggleFaceVisibility}\n            onSetIsolatedPanel={onSetIsolatedPanel}\n          />\n        ))}\n      </div>\n\n      {/* Interior void - use the actual user-editable interior (main-interior when lid insets exist) */}\n      <div className=\"tree-children\">\n        <VoidNode\n          node={interiorVoid}\n          depth={depth + 1}\n          label=\"Interior\"\n          {...treeOps}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport const BoxTree: React.FC = () => {\n  const {\n    rootVoid,\n    faces,\n    selectedVoidIds,\n    selectedSubAssemblyIds,\n    selectedPanelIds,\n    selectedAssemblyId,\n    selectVoid,\n    selectSubAssembly,\n    selectPanel,\n    selectAssembly,\n    hoveredVoidId,\n    hoveredPanelId,\n    hoveredAssemblyId,\n    setHoveredVoid,\n    setHoveredPanel,\n    setHoveredAssembly,\n    hiddenVoidIds,\n    isolatedVoidId,\n    toggleVoidVisibility,\n    setIsolatedVoid,\n    hiddenSubAssemblyIds,\n    isolatedSubAssemblyId,\n    toggleSubAssemblyVisibility,\n    setIsolatedSubAssembly,\n    hiddenFaceIds,\n    isolatedPanelId,\n    toggleFaceVisibility,\n    setIsolatedPanel,\n    removeVoid,\n    removeSubAssembly,\n  } = useBoxStore();\n\n  const hasIsolation = isolatedVoidId || isolatedSubAssemblyId || isolatedPanelId;\n\n  const handleShowAll = () => {\n    setIsolatedVoid(null);\n    setIsolatedSubAssembly(null);\n    setIsolatedPanel(null);\n  };\n\n  return (\n    <Panel title=\"Structure\">\n      <div className=\"box-tree\">\n        <MainBoxNode\n          rootVoid={rootVoid}\n          faces={faces}\n          depth={0}\n          selectedVoidIds={selectedVoidIds}\n          selectedSubAssemblyIds={selectedSubAssemblyIds}\n          selectedPanelIds={selectedPanelIds}\n          selectedAssemblyId={selectedAssemblyId}\n          onSelectVoid={selectVoid}\n          onSelectSubAssembly={selectSubAssembly}\n          onSelectPanel={selectPanel}\n          onSelectAssembly={selectAssembly}\n          hoveredVoidId={hoveredVoidId}\n          hoveredPanelId={hoveredPanelId}\n          hoveredAssemblyId={hoveredAssemblyId}\n          onHoverVoid={setHoveredVoid}\n          onHoverPanel={setHoveredPanel}\n          onHoverAssembly={setHoveredAssembly}\n          hiddenVoidIds={hiddenVoidIds}\n          isolatedVoidId={isolatedVoidId}\n          onToggleVisibility={toggleVoidVisibility}\n          onSetIsolated={setIsolatedVoid}\n          hiddenSubAssemblyIds={hiddenSubAssemblyIds}\n          isolatedSubAssemblyId={isolatedSubAssemblyId}\n          onToggleSubAssemblyVisibility={toggleSubAssemblyVisibility}\n          onSetIsolatedSubAssembly={setIsolatedSubAssembly}\n          hiddenFaceIds={hiddenFaceIds}\n          isolatedPanelId={isolatedPanelId}\n          onToggleFaceVisibility={toggleFaceVisibility}\n          onSetIsolatedPanel={setIsolatedPanel}\n          onDeleteVoid={removeVoid}\n          onDeleteSubAssembly={removeSubAssembly}\n        />\n      </div>\n      {hasIsolation && (\n        <button\n          className=\"unisolate-btn\"\n          onClick={handleShowAll}\n        >\n          Show All\n        </button>\n      )}\n    </Panel>\n  );\n};\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nimport {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from 'three';\n\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttype: 'LineMaterial',\n\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\t\t\tthis.extensions.derivatives = true;\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\t\t\tthis.extensions.derivatives = false;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import React, { useRef, useMemo } from 'react';\nimport * as THREE from 'three';\nimport { LineSegments2 } from 'three/examples/jsm/lines/LineSegments2.js';\nimport { LineMaterial } from 'three/examples/jsm/lines/LineMaterial.js';\nimport { LineSegmentsGeometry } from 'three/examples/jsm/lines/LineSegmentsGeometry.js';\nimport { useThree } from '@react-three/fiber';\nimport { useBoxStore, isVoidVisible } from '../store/useBoxStore';\nimport { Bounds } from '../types';\n\ninterface VoidMeshProps {\n  voidId: string;\n  bounds: Bounds;\n  boxCenter: { x: number; y: number; z: number };\n}\n\nexport const VoidMesh: React.FC<VoidMeshProps> = ({ voidId, bounds, boxCenter }) => {\n  const meshRef = useRef<THREE.Mesh>(null);\n  const { selectedVoidIds, selectVoid, hoveredVoidId, setHoveredVoid, selectionMode, rootVoid, hiddenVoidIds, isolatedVoidId, config, faces } = useBoxStore();\n  const { size: canvasSize } = useThree();\n\n  const isSelected = selectedVoidIds.has(voidId);\n  const isHovered = hoveredVoidId === voidId;\n  const isVoidMode = selectionMode === 'void';\n  const visible = isVoidVisible(voidId, rootVoid, hiddenVoidIds, isolatedVoidId);\n\n  const { width, height, depth, materialThickness } = config;\n  const tolerance = 0.01;\n\n  // Check which edges of this void are at outer box boundaries\n  const atLeft = bounds.x < tolerance;\n  const atRight = Math.abs(bounds.x + bounds.w - width) < tolerance;\n  const atBottom = bounds.y < tolerance;\n  const atTop = Math.abs(bounds.y + bounds.h - height) < tolerance;\n  const atBack = bounds.z < tolerance;\n  const atFront = Math.abs(bounds.z + bounds.d - depth) < tolerance;\n\n  // Check which outer faces are solid\n  const leftSolid = faces.find(f => f.id === 'left')?.solid ?? false;\n  const rightSolid = faces.find(f => f.id === 'right')?.solid ?? false;\n  const bottomSolid = faces.find(f => f.id === 'bottom')?.solid ?? false;\n  const topSolid = faces.find(f => f.id === 'top')?.solid ?? false;\n  const backSolid = faces.find(f => f.id === 'back')?.solid ?? false;\n  const frontSolid = faces.find(f => f.id === 'front')?.solid ?? false;\n\n  // Calculate insets based on boundary and solid face status\n  const insetLeft = (atLeft && leftSolid) ? materialThickness : 0;\n  const insetRight = (atRight && rightSolid) ? materialThickness : 0;\n  const insetBottom = (atBottom && bottomSolid) ? materialThickness : 0;\n  const insetTop = (atTop && topSolid) ? materialThickness : 0;\n  const insetBack = (atBack && backSolid) ? materialThickness : 0;\n  const insetFront = (atFront && frontSolid) ? materialThickness : 0;\n\n  // Calculate inset bounds\n  const insetBounds = {\n    x: bounds.x + insetLeft,\n    y: bounds.y + insetBottom,\n    z: bounds.z + insetBack,\n    w: bounds.w - insetLeft - insetRight,\n    h: bounds.h - insetBottom - insetTop,\n    d: bounds.d - insetBack - insetFront,\n  };\n\n  const position: [number, number, number] = [\n    insetBounds.x + insetBounds.w / 2 - boxCenter.x,\n    insetBounds.y + insetBounds.h / 2 - boxCenter.y,\n    insetBounds.z + insetBounds.d / 2 - boxCenter.z,\n  ];\n\n  const size: [number, number, number] = [insetBounds.w, insetBounds.h, insetBounds.d];\n\n  // Create thick line wireframe using LineSegments2 (for disconnected segments)\n  const { lineGeometry, lineMaterial } = useMemo(() => {\n    const [w, h, d] = size;\n    const hw = w / 2, hh = h / 2, hd = d / 2;\n\n    // Define box vertices\n    const v = [\n      [-hw, -hh, -hd], [hw, -hh, -hd], [hw, hh, -hd], [-hw, hh, -hd],  // back face\n      [-hw, -hh, hd], [hw, -hh, hd], [hw, hh, hd], [-hw, hh, hd],      // front face\n    ];\n\n    // Define all 12 edges of the box as pairs of points\n    const positions: number[] = [];\n    const edges = [\n      // Back face\n      [0, 1], [1, 2], [2, 3], [3, 0],\n      // Front face\n      [4, 5], [5, 6], [6, 7], [7, 4],\n      // Connecting edges\n      [0, 4], [1, 5], [2, 6], [3, 7],\n    ];\n\n    for (const [a, b] of edges) {\n      positions.push(...v[a], ...v[b]);\n    }\n\n    const geometry = new LineSegmentsGeometry();\n    geometry.setPositions(positions);\n\n    const material = new LineMaterial({\n      color: 0xff00ff,\n      linewidth: 2, // in pixels\n      resolution: new THREE.Vector2(canvasSize.width, canvasSize.height),\n    });\n\n    return { lineGeometry: geometry, lineMaterial: material };\n  }, [size[0], size[1], size[2], canvasSize.width, canvasSize.height]);\n\n  // Create LineSegments2 instance\n  const lineSegments = useMemo(() => {\n    return new LineSegments2(lineGeometry, lineMaterial);\n  }, [lineGeometry, lineMaterial]);\n\n  // Only render void if:\n  // 1. Void selection mode is active, OR\n  // 2. This void is selected, OR\n  // 3. This void is hovered (from tree or 3D view)\n  const shouldRender = visible && (isVoidMode || isSelected || isHovered);\n\n  if (!shouldRender) {\n    return null;\n  }\n\n  return (\n    <group position={position}>\n      {/* Magenta wireframe outline - always visible */}\n      <primitive object={lineSegments} />\n\n      {/* Interactive mesh - click only in void mode, but always show selection/hover */}\n      <mesh\n        ref={meshRef}\n        scale={[0.95, 0.95, 0.95]}\n        onClick={isVoidMode ? (e) => {\n          e.stopPropagation();\n          selectVoid(voidId, e.shiftKey);\n        } : undefined}\n        onPointerOver={isVoidMode ? (e) => {\n          e.stopPropagation();\n          setHoveredVoid(voidId);\n          document.body.style.cursor = 'pointer';\n        } : undefined}\n        onPointerOut={isVoidMode ? () => {\n          setHoveredVoid(null);\n          document.body.style.cursor = 'auto';\n        } : undefined}\n      >\n        <boxGeometry args={[insetBounds.w, insetBounds.h, insetBounds.d]} />\n        <meshStandardMaterial\n          color={isSelected ? '#4a90d9' : isHovered ? '#6ab04c' : '#95a5a6'}\n          transparent\n          opacity={isSelected ? 0.6 : isHovered ? 0.4 : 0.2}\n        />\n      </mesh>\n    </group>\n  );\n};\n","import React from 'react';\nimport { useBoxStore } from '../store/useBoxStore';\nimport { SubAssembly, Bounds } from '../types';\nimport * as THREE from 'three';\n\ninterface SubAssembly3DProps {\n  subAssembly: SubAssembly;\n  parentBounds: Bounds;  // The void bounds this sub-assembly sits in\n  scale: number;\n  boxCenter: { x: number; y: number; z: number };\n}\n\nexport const SubAssembly3D: React.FC<SubAssembly3DProps> = ({\n  subAssembly,\n  parentBounds,\n  scale,\n  boxCenter,\n}) => {\n  const { selectedSubAssemblyIds, selectSubAssembly, selectionMode, selectedAssemblyId, selectAssembly } = useBoxStore();\n\n  const isSelectedSubAssembly = selectedSubAssemblyIds.has(subAssembly.id);\n  const isSelectedAssembly = selectedAssemblyId === subAssembly.id;\n  const isSelected = isSelectedSubAssembly || isSelectedAssembly;\n  const { clearance, rootVoid, materialThickness, faceOffsets } = subAssembly;\n\n  // Get face offsets (default to 0 if not set)\n  const offsets = faceOffsets || { left: 0, right: 0, top: 0, bottom: 0, front: 0, back: 0 };\n\n  // Calculate the sub-assembly outer dimensions (inner + 2*materialThickness)\n  const subOuterW = rootVoid.bounds.w + 2 * materialThickness;\n  const subOuterH = rootVoid.bounds.h + 2 * materialThickness;\n  const subOuterD = rootVoid.bounds.d + 2 * materialThickness;\n\n  // Scale the dimensions\n  const scaledW = subOuterW * scale;\n  const scaledH = subOuterH * scale;\n  const scaledD = subOuterD * scale;\n\n  // Calculate the center position of the sub-assembly within the parent void\n  // Face offsets shift the base position: positive offset extends outward from clearance boundary\n  const subCenterX = (parentBounds.x + clearance - offsets.left + subOuterW / 2 - boxCenter.x) * scale;\n  const subCenterY = (parentBounds.y + clearance - offsets.bottom + subOuterH / 2 - boxCenter.y) * scale;\n  const subCenterZ = (parentBounds.z + clearance - offsets.back + subOuterD / 2 - boxCenter.z) * scale;\n\n  const handleClick = (e: any) => {\n    e.stopPropagation();\n    if (selectionMode === 'void') {\n      selectSubAssembly(subAssembly.id, e.shiftKey);\n    } else if (selectionMode === 'assembly') {\n      selectAssembly(isSelectedAssembly ? null : subAssembly.id);\n    }\n  };\n\n  const isClickable = selectionMode === 'void' || selectionMode === 'assembly';\n\n  return (\n    <group position={[subCenterX, subCenterY, subCenterZ]}>\n      {/* Wireframe outline for sub-assembly selection */}\n      <lineSegments>\n        <edgesGeometry args={[new THREE.BoxGeometry(scaledW, scaledH, scaledD)]} />\n        <lineBasicMaterial color={isSelected ? '#e74c3c' : '#666'} />\n      </lineSegments>\n\n      {/* Invisible clickable box for selection (only in void/assembly mode) */}\n      {isClickable && (\n        <mesh onClick={handleClick}>\n          <boxGeometry args={[scaledW, scaledH, scaledD]} />\n          <meshBasicMaterial transparent opacity={0} depthWrite={false} />\n        </mesh>\n      )}\n    </group>\n  );\n};\n","import React, { useMemo, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { PanelPath, PathPoint } from '../types';\nimport { useBoxStore } from '../store/useBoxStore';\n\ninterface PanelPathRendererProps {\n  panel: PanelPath;\n  scale: number;\n  isSelected: boolean;\n  isHovered?: boolean;\n  onClick?: (event?: React.MouseEvent) => void;\n  onDoubleClick?: (event?: React.MouseEvent) => void;\n  onHover?: (hovered: boolean) => void;\n  color?: string;\n  selectedColor?: string;\n  hoveredColor?: string;\n}\n\n// Convert stored PathPoints to THREE.js geometry\nconst createGeometryFromPath = (\n  outline: PathPoint[],\n  holes: { points: PathPoint[] }[],\n  thickness: number,\n  scale: number\n): THREE.ExtrudeGeometry => {\n  const scaledThickness = thickness * scale;\n\n  // Create the main shape from outline points (scaled)\n  const shape = new THREE.Shape();\n  if (outline.length > 0) {\n    const first = outline[0];\n    shape.moveTo(first.x * scale, first.y * scale);\n\n    for (let i = 1; i < outline.length; i++) {\n      const pt = outline[i];\n      shape.lineTo(pt.x * scale, pt.y * scale);\n    }\n\n    shape.closePath();\n  }\n\n  // Add holes (scaled)\n  for (const hole of holes) {\n    if (hole.points.length > 0) {\n      const holePath = new THREE.Path();\n      const first = hole.points[0];\n      holePath.moveTo(first.x * scale, first.y * scale);\n      for (let i = 1; i < hole.points.length; i++) {\n        holePath.lineTo(hole.points[i].x * scale, hole.points[i].y * scale);\n      }\n      holePath.closePath();\n      shape.holes.push(holePath);\n    }\n  }\n\n  // Extrude\n  const extrudeSettings: THREE.ExtrudeGeometryOptions = {\n    depth: scaledThickness,\n    bevelEnabled: false,\n  };\n\n  const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n  geo.translate(0, 0, -scaledThickness / 2);\n\n  return geo;\n};\n\n// Create edge geometry for wireframe outline\nconst createEdgeGeometry = (\n  outline: PathPoint[],\n  holes: { points: PathPoint[] }[],\n  thickness: number,\n  scale: number\n): THREE.BufferGeometry => {\n  const scaledThickness = thickness * scale;\n  const frontZ = scaledThickness / 2;\n  const backZ = -scaledThickness / 2;\n\n  const vertices: number[] = [];\n\n  const addSegment = (x1: number, y1: number, z1: number, x2: number, y2: number, z2: number) => {\n    // Skip zero-length segments\n    if (Math.abs(x1 - x2) < 0.001 && Math.abs(y1 - y2) < 0.001 && Math.abs(z1 - z2) < 0.001) {\n      return;\n    }\n    vertices.push(x1, y1, z1, x2, y2, z2);\n  };\n\n  // Add path outline, connecting consecutive points\n  // Only connects distinct points (skips if next point is same as current)\n  const addPathOutline = (points: PathPoint[], z: number) => {\n    for (let i = 0; i < points.length; i++) {\n      const p1 = points[i];\n      const p2 = points[(i + 1) % points.length];\n      addSegment(p1.x * scale, p1.y * scale, z, p2.x * scale, p2.y * scale, z);\n    }\n  };\n\n  // Add connecting edges between front and back faces\n  // Only at unique positions (skips duplicate points)\n  const addConnectingEdges = (points: PathPoint[]) => {\n    const seen = new Set<string>();\n    for (const p of points) {\n      const key = `${Math.round(p.x * 1000)},${Math.round(p.y * 1000)}`;\n      if (seen.has(key)) continue;\n      seen.add(key);\n      addSegment(p.x * scale, p.y * scale, frontZ, p.x * scale, p.y * scale, backZ);\n    }\n  };\n\n  // Outer path\n  addPathOutline(outline, frontZ);\n  addPathOutline(outline, backZ);\n  addConnectingEdges(outline);\n\n  // Hole paths\n  for (const hole of holes) {\n    addPathOutline(hole.points, frontZ);\n    addPathOutline(hole.points, backZ);\n    addConnectingEdges(hole.points);\n  }\n\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n  return geometry;\n};\n\nexport const PanelPathRenderer: React.FC<PanelPathRendererProps> = ({\n  panel,\n  scale,\n  isSelected,\n  isHovered = false,\n  onClick,\n  onDoubleClick,\n  onHover,\n  color = '#3498db',\n  selectedColor = '#9b59b6',\n  hoveredColor = '#6ab04c',\n}) => {\n  const { outline, holes, thickness, position, rotation, visible } = panel;\n\n  // Scale the stored position for rendering\n  const scaledPosition: [number, number, number] = useMemo(() => [\n    position[0] * scale,\n    position[1] * scale,\n    position[2] * scale,\n  ], [position, scale]);\n\n  const geometry = useMemo(() => {\n    if (!visible || outline.points.length === 0) return null;\n    return createGeometryFromPath(\n      outline.points,\n      holes.map(h => ({ points: h.path.points })),\n      thickness,\n      scale\n    );\n  }, [outline, holes, thickness, scale, visible]);\n\n  const edgeGeometry = useMemo(() => {\n    if (!visible || outline.points.length === 0) return null;\n    return createEdgeGeometry(\n      outline.points,\n      holes.map(h => ({ points: h.path.points })),\n      thickness,\n      scale\n    );\n  }, [outline, holes, thickness, scale, visible]);\n\n  // Properly dispose of geometry when it changes or component unmounts\n  useEffect(() => {\n    return () => {\n      if (geometry) {\n        geometry.dispose();\n      }\n      if (edgeGeometry) {\n        edgeGeometry.dispose();\n      }\n    };\n  }, [geometry, edgeGeometry]);\n\n  if (!visible || !geometry) {\n    return null;\n  }\n\n  const handleClick = onClick ? (e: any) => {\n    e.stopPropagation?.();\n    // Extract native event for shiftKey access\n    const nativeEvent = e.nativeEvent || e;\n    onClick(nativeEvent);\n  } : undefined;\n\n  const handleDoubleClick = onDoubleClick ? (e: any) => {\n    e.stopPropagation?.();\n    const nativeEvent = e.nativeEvent || e;\n    onDoubleClick(nativeEvent);\n  } : undefined;\n\n  const handlePointerOver = onHover ? (e: any) => {\n    e.stopPropagation?.();\n    onHover(true);\n    document.body.style.cursor = 'pointer';\n  } : undefined;\n\n  const handlePointerOut = onHover ? () => {\n    onHover(false);\n    document.body.style.cursor = 'auto';\n  } : undefined;\n\n  // Determine color - selected takes priority, then hovered, then default\n  const displayColor = isSelected ? selectedColor : isHovered ? hoveredColor : color;\n  const displayOpacity = isSelected ? 0.9 : isHovered ? 0.8 : 0.7;\n\n  return (\n    <group position={scaledPosition} rotation={rotation}>\n      <mesh\n        geometry={geometry}\n        onClick={handleClick}\n        onDoubleClick={handleDoubleClick}\n        onPointerOver={handlePointerOver}\n        onPointerOut={handlePointerOut}\n      >\n        <meshStandardMaterial\n          color={displayColor}\n          transparent\n          opacity={displayOpacity}\n          side={THREE.DoubleSide}\n        />\n      </mesh>\n      {edgeGeometry && (\n        <lineSegments geometry={edgeGeometry}>\n          <lineBasicMaterial\n            color={isSelected ? '#7b4397' : isHovered ? '#2d6a4f' : '#1a5276'}\n            linewidth={1}\n          />\n        </lineSegments>\n      )}\n    </group>\n  );\n};\n\n// Helper to get assembly ID from panel source\nconst getAssemblyIdFromPanel = (panel: PanelPath): string => {\n  // Use source.subAssemblyId if set, otherwise it's 'main'\n  return panel.source.subAssemblyId ?? 'main';\n};\n\n\n// Render all panels from a collection\ninterface PanelCollectionRendererProps {\n  scale: number;\n  selectedPanelIds: Set<string>;\n  onPanelClick?: (panelId: string, event?: React.MouseEvent) => void;\n  onPanelDoubleClick?: (panelId: string, event?: React.MouseEvent) => void;\n  hiddenFaceIds?: Set<string>;\n}\n\nexport const PanelCollectionRenderer: React.FC<PanelCollectionRendererProps> = ({\n  scale,\n  selectedPanelIds,\n  onPanelClick,\n  onPanelDoubleClick,\n  hiddenFaceIds = new Set(),\n}) => {\n  const panelCollection = useBoxStore((state) => state.panelCollection);\n  const hoveredPanelId = useBoxStore((state) => state.hoveredPanelId);\n  const hoveredAssemblyId = useBoxStore((state) => state.hoveredAssemblyId);\n  const selectedAssemblyId = useBoxStore((state) => state.selectedAssemblyId);\n  const selectedSubAssemblyIds = useBoxStore((state) => state.selectedSubAssemblyIds);\n  const setHoveredPanel = useBoxStore((state) => state.setHoveredPanel);\n\n  if (!panelCollection) {\n    return null;\n  }\n\n  return (\n    <>\n      {panelCollection.panels.map((panel: PanelPath) => {\n        // Check visibility\n        if (!panel.visible) return null;\n        if (hiddenFaceIds.has(panel.id)) return null;\n\n        const isDivider = panel.source.type === 'divider';\n        const isSubAssemblyPanel = !!panel.source.subAssemblyId;\n\n        // Get this panel's parent assembly\n        const panelAssemblyId = getAssemblyIdFromPanel(panel);\n\n        // Check if this panel or its assembly is selected/hovered\n        const isPanelSelected = selectedPanelIds.has(panel.id);\n        // Assembly can be selected via selectAssembly (selectedAssemblyId) or selectSubAssembly (selectedSubAssemblyIds)\n        const isAssemblySelected = selectedAssemblyId === panelAssemblyId ||\n          (panelAssemblyId !== 'main' && selectedSubAssemblyIds.has(panelAssemblyId));\n        const isPanelHovered = hoveredPanelId === panel.id;\n        const isAssemblyHovered = hoveredAssemblyId === panelAssemblyId;\n\n        // Panel is \"selected\" if directly selected OR its assembly is selected\n        const isSelected = isPanelSelected || isAssemblySelected;\n        // Panel is \"hovered\" if directly hovered OR its assembly is hovered\n        const isHovered = isPanelHovered || isAssemblyHovered;\n\n        // Color based on panel type\n        // Sub-assembly: teal, Divider: orange, Main box: blue\n        const color = isSubAssemblyPanel ? '#1abc9c' : isDivider ? '#f39c12' : '#3498db';\n\n        return (\n          <PanelPathRenderer\n            key={panel.id}\n            panel={panel}\n            scale={scale}\n            isSelected={isSelected}\n            isHovered={isHovered}\n            onClick={onPanelClick ? (e) => onPanelClick(panel.id, e) : undefined}\n            onDoubleClick={onPanelDoubleClick ? (e) => onPanelDoubleClick(panel.id, e) : undefined}\n            onHover={(hovered) => setHoveredPanel(hovered ? panel.id : null)}\n            color={color}\n            selectedColor={'#9b59b6'}\n          />\n        );\n      })}\n    </>\n  );\n};\n","import React, { useMemo, useEffect } from 'react';\nimport { useBoxStore, getLeafVoids, getAllSubdivisions, getAllSubAssemblies, isVoidVisible, isSubAssemblyVisible } from '../store/useBoxStore';\nimport { VoidMesh } from './VoidMesh';\nimport { SubAssembly3D } from './SubAssembly3D';\nimport { FaceWithFingers } from './FaceWithFingers';\nimport { DividerPanel } from './DividerPanel';\nimport { PanelCollectionRenderer } from './PanelPathRenderer';\nimport { FaceId, Bounds, AssemblyConfig, getFaceRole, getLidSide, getLidFaceId } from '../types';\nimport * as THREE from 'three';\n\n// Flag to switch between old (computed) and new (stored paths) rendering\nconst USE_STORED_PATHS = true;  // Check panelGenerator holes\n\n// Face configs for a box with OUTER dimensions w  h  d.\n//\n// Edge length matching (mating edges must have same length for finger alignment):\n// - fronttop: both w\n// - frontleft: both h-2T\n// - lefttop: both d\n//\n// Sizing:\n// - front/back: w  (h-2T)  tabs on top/bottom extend height to h\n// - left/right: d  (h-2T)  tabs on top/bottom extend height to h\n// - top/bottom: w  d  full size, slots cut inward\nconst getFaceConfigs = (scaledThickness: number): {\n  id: FaceId;\n  position: (w: number, h: number, d: number) => [number, number, number];\n  rotation: [number, number, number];\n  size: (w: number, h: number, d: number) => [number, number];\n}[] => {\n  const halfT = scaledThickness / 2;\n  const T = scaledThickness;\n  return [\n    {\n      id: 'front',\n      position: (w, h, d) => [0, 0, d / 2 - halfT],  // outer surface at z = d/2\n      rotation: [0, 0, 0],\n      size: (w, h) => [w, h],  // full height - corner insets handle tab overlaps\n    },\n    {\n      id: 'back',\n      position: (w, h, d) => [0, 0, -d / 2 + halfT],  // outer surface at z = -d/2\n      rotation: [0, Math.PI, 0],\n      size: (w, h) => [w, h],  // full height - corner insets handle tab overlaps\n    },\n    {\n      id: 'left',\n      position: (w, h, d) => [-w / 2 + halfT, 0, 0],  // outer surface at x = -w/2\n      rotation: [0, -Math.PI / 2, 0],\n      size: (w, h, d) => [d, h],  // full height - corner insets handle tab overlaps\n    },\n    {\n      id: 'right',\n      position: (w, h, d) => [w / 2 - halfT, 0, 0],  // outer surface at x = w/2\n      rotation: [0, Math.PI / 2, 0],\n      size: (w, h, d) => [d, h],  // full height - corner insets handle tab overlaps\n    },\n    {\n      id: 'top',\n      position: (w, h, d) => [0, h / 2 - halfT, 0],  // outer surface at y = h/2\n      rotation: [-Math.PI / 2, 0, 0],\n      size: (w, h, d) => [w, d],\n    },\n    {\n      id: 'bottom',\n      position: (w, h, d) => [0, -h / 2 + halfT, 0],  // outer surface at y = -h/2\n      rotation: [Math.PI / 2, 0, 0],\n      size: (w, h, d) => [w, d],\n    },\n  ];\n};\n\n// Find a void by ID (including inside sub-assemblies)\nconst findVoid = (root: { id: string; bounds: Bounds; children: any[]; subAssembly?: any }, id: string): { bounds: Bounds } | null => {\n  if (root.id === id) return root;\n  for (const child of root.children) {\n    const found = findVoid(child, id);\n    if (found) return found;\n  }\n  // Also search inside sub-assembly's void structure\n  if (root.subAssembly) {\n    const found = findVoid(root.subAssembly.rootVoid, id);\n    if (found) return found;\n  }\n  return null;\n};\n\n// Find the parent sub-assembly of a void (if any) and return its world offset\nconst findParentSubAssemblyOffset = (\n  root: { id: string; bounds: Bounds; children: any[]; subAssembly?: any },\n  voidId: string,\n  subAssemblyInfo?: { bounds: Bounds; clearance: number; materialThickness: number; faceOffsets?: { left: number; right: number; top: number; bottom: number; front: number; back: number } }\n): { x: number; y: number; z: number } | null => {\n  // Check if this void is the target\n  if (root.id === voidId) {\n    if (subAssemblyInfo) {\n      // This void is inside a sub-assembly, return the offset\n      const { bounds, clearance, materialThickness, faceOffsets } = subAssemblyInfo;\n      const offsets = faceOffsets || { left: 0, right: 0, top: 0, bottom: 0, front: 0, back: 0 };\n      const subOuterW = root.bounds.w + 2 * materialThickness;\n      const subOuterH = root.bounds.h + 2 * materialThickness;\n      const subOuterD = root.bounds.d + 2 * materialThickness;\n      return {\n        x: bounds.x + clearance - offsets.left + subOuterW / 2 - root.bounds.w / 2 - materialThickness,\n        y: bounds.y + clearance - offsets.bottom + subOuterH / 2 - root.bounds.h / 2 - materialThickness,\n        z: bounds.z + clearance - offsets.back + subOuterD / 2 - root.bounds.d / 2 - materialThickness,\n      };\n    }\n    return null; // Void is in main box, no offset needed\n  }\n\n  // Check children\n  for (const child of root.children) {\n    const result = findParentSubAssemblyOffset(child, voidId, subAssemblyInfo);\n    if (result !== undefined) return result;\n  }\n\n  // Check inside sub-assembly\n  if (root.subAssembly) {\n    const result = findParentSubAssemblyOffset(\n      root.subAssembly.rootVoid,\n      voidId,\n      {\n        bounds: root.bounds,\n        clearance: root.subAssembly.clearance,\n        materialThickness: root.subAssembly.materialThickness,\n        faceOffsets: root.subAssembly.faceOffsets,\n      }\n    );\n    if (result !== undefined) return result;\n  }\n\n  return undefined as any; // Not found in this branch\n};\n\n// Find the parent sub-assembly of a void and return the sub-assembly + parent bounds\nconst findParentSubAssemblyInfo = (\n  root: { id: string; bounds: Bounds; children: any[]; subAssembly?: any },\n  voidId: string,\n  parentSubAssembly?: { subAssembly: any; parentBounds: Bounds }\n): { subAssembly: any; parentBounds: Bounds } | null => {\n  // Check if this void is the target\n  if (root.id === voidId) {\n    return parentSubAssembly || null;\n  }\n\n  // Check children\n  for (const child of root.children) {\n    const result = findParentSubAssemblyInfo(child, voidId, parentSubAssembly);\n    if (result !== undefined) return result;\n  }\n\n  // Check inside sub-assembly\n  if (root.subAssembly) {\n    const result = findParentSubAssemblyInfo(\n      root.subAssembly.rootVoid,\n      voidId,\n      { subAssembly: root.subAssembly, parentBounds: root.bounds }\n    );\n    if (result !== undefined) return result;\n  }\n\n  return undefined as any; // Not found in this branch\n};\n\n// Divider intersection with a face - used for cutting slots\nexport interface DividerIntersection {\n  subdivisionId: string;\n  // Position along the face in local 2D coordinates (after scaling)\n  // For horizontal slots: x position of slot center\n  // For vertical slots: y position of slot center\n  position: number;\n  // Length of the slot (how much of the face edge the divider spans)\n  length: number;\n  // Whether the slot is horizontal or vertical on the face\n  orientation: 'horizontal' | 'vertical';\n  // The divider's bounds (needed for finger pattern calculation)\n  dividerBounds: Bounds;\n  // The divider's axis\n  dividerAxis: 'x' | 'y' | 'z';\n  // Insets at start and end of the slot (where divider meets perpendicular outer faces)\n  // These must be subtracted from the slot length to get the finger region\n  startInset: number;  // Inset at start of slot (scaled)\n  endInset: number;    // Inset at end of slot (scaled)\n}\n\n// Calculate which dividers intersect a given face\nconst getDividerIntersections = (\n  faceId: FaceId,\n  subdivisions: { id: string; axis: 'x' | 'y' | 'z'; position: number; bounds: Bounds }[],\n  boxDimensions: { width: number; height: number; depth: number },\n  scale: number,\n  materialThickness: number\n): DividerIntersection[] => {\n  const { width, height, depth } = boxDimensions;\n  const intersections: DividerIntersection[] = [];\n  const T = materialThickness * scale;  // Scaled material thickness\n  const tolerance = 0.01;\n\n  for (const sub of subdivisions) {\n    const { axis, position, bounds } = sub;\n    let intersects = false;\n    let localPosition = 0;\n    let length = 0;\n    let orientation: 'horizontal' | 'vertical' = 'horizontal';\n    let startInset = 0;  // Inset at start of slot\n    let endInset = 0;    // Inset at end of slot\n\n    // Helper to check if divider meets an outer face\n    const meetsBottom = bounds.y < tolerance;\n    const meetsTop = bounds.y + bounds.h > height - tolerance;\n    const meetsLeft = bounds.x < tolerance;\n    const meetsRight = bounds.x + bounds.w > width - tolerance;\n    const meetsBack = bounds.z < tolerance;\n    const meetsFront = bounds.z + bounds.d > depth - tolerance;\n\n    switch (faceId) {\n      case 'front':\n      case 'back':\n        // Front/back faces are intersected by X and Y axis dividers\n        if (axis === 'x') {\n          // X-axis divider creates a vertical slot on front/back\n          if ((faceId === 'front' && meetsFront) || (faceId === 'back' && meetsBack)) {\n            intersects = true;\n            localPosition = (position - width / 2) * scale;\n            length = bounds.h * scale;\n            orientation = 'vertical';\n            // Vertical slot: start=bottom, end=top\n            startInset = meetsBottom ? T : 0;\n            endInset = meetsTop ? T : 0;\n          }\n        } else if (axis === 'y') {\n          // Y-axis divider creates a horizontal slot on front/back\n          if ((faceId === 'front' && meetsFront) || (faceId === 'back' && meetsBack)) {\n            intersects = true;\n            localPosition = (position - height / 2) * scale;\n            length = bounds.w * scale;\n            orientation = 'horizontal';\n            // Horizontal slot: start=left, end=right\n            startInset = meetsLeft ? T : 0;\n            endInset = meetsRight ? T : 0;\n          }\n        }\n        break;\n\n      case 'left':\n      case 'right':\n        // Left/right faces are intersected by Y and Z axis dividers\n        if (axis === 'y') {\n          // Y-axis divider creates a horizontal slot on left/right\n          if ((faceId === 'left' && meetsLeft) || (faceId === 'right' && meetsRight)) {\n            intersects = true;\n            localPosition = (position - height / 2) * scale;\n            length = bounds.d * scale;\n            orientation = 'horizontal';\n            // Horizontal slot on left/right: start=back, end=front\n            startInset = meetsBack ? T : 0;\n            endInset = meetsFront ? T : 0;\n          }\n        } else if (axis === 'z') {\n          // Z-axis divider creates a vertical slot on left/right\n          if ((faceId === 'left' && meetsLeft) || (faceId === 'right' && meetsRight)) {\n            intersects = true;\n            localPosition = (faceId === 'left' ? -1 : 1) * (position - depth / 2) * scale;\n            length = bounds.h * scale;\n            orientation = 'vertical';\n            // Vertical slot: start=bottom, end=top\n            startInset = meetsBottom ? T : 0;\n            endInset = meetsTop ? T : 0;\n          }\n        }\n        break;\n\n      case 'top':\n      case 'bottom':\n        // Top/bottom faces are intersected by X and Z axis dividers\n        if (axis === 'x') {\n          // X-axis divider creates a slot along Z on top/bottom\n          if ((faceId === 'top' && meetsTop) || (faceId === 'bottom' && meetsBottom)) {\n            intersects = true;\n            localPosition = (position - width / 2) * scale;\n            length = bounds.d * scale;\n            orientation = 'vertical';  // Along Y in local 2D (which is Z in world)\n            // For top: start=front (negative local Y), end=back\n            // For bottom: start=back (negative local Y), end=front\n            if (faceId === 'top') {\n              startInset = meetsFront ? T : 0;\n              endInset = meetsBack ? T : 0;\n            } else {\n              startInset = meetsBack ? T : 0;\n              endInset = meetsFront ? T : 0;\n            }\n          }\n        } else if (axis === 'z') {\n          // Z-axis divider creates a slot along X on top/bottom\n          if ((faceId === 'top' && meetsTop) || (faceId === 'bottom' && meetsBottom)) {\n            intersects = true;\n            localPosition = (faceId === 'top' ? -1 : 1) * (position - depth / 2) * scale;\n            length = bounds.w * scale;\n            orientation = 'horizontal';  // Along X in local 2D\n            // Horizontal slot: start=left, end=right\n            startInset = meetsLeft ? T : 0;\n            endInset = meetsRight ? T : 0;\n          }\n        }\n        break;\n    }\n\n    if (intersects) {\n      intersections.push({\n        subdivisionId: sub.id,\n        position: localPosition,\n        length,\n        orientation,\n        dividerBounds: bounds,\n        dividerAxis: axis,\n        startInset,\n        endInset,\n      });\n    }\n  }\n\n  return intersections;\n};\n\n// Calculate lid intersections for a wall face (when lids have tabs-out)\n// Returns DividerIntersection-like objects for slot cutting in walls\nconst getLidIntersections = (\n  faceId: FaceId,\n  assembly: AssemblyConfig,\n  faces: { id: FaceId; solid: boolean }[],\n  boxDimensions: { width: number; height: number; depth: number },\n  scale: number,\n  materialThickness: number\n): DividerIntersection[] => {\n  const intersections: DividerIntersection[] = [];\n  const { width, height, depth } = boxDimensions;\n  const T = materialThickness * scale;\n\n  // Only walls get slots for lid tabs\n  if (getFaceRole(faceId, assembly.assemblyAxis) !== 'wall') return [];\n\n  // Check each lid (positive and negative)\n  for (const side of ['positive', 'negative'] as const) {\n    const lidConfig = assembly.lids[side];\n\n    // Only process if lid has tabs-out, is enabled, AND is inset\n    // For flush lids (inset=0), the tabs interlock with wall edges via finger joints\n    // Only inset lids need separate slots cut through the wall face\n    if (lidConfig.tabDirection !== 'tabs-out') continue;\n    if (lidConfig.inset <= 0) continue;  // Flush lids use edge finger joints, not face slots\n\n    const lidFaceId = getLidFaceId(assembly.assemblyAxis, side);\n    const lidFace = faces.find(f => f.id === lidFaceId);\n    if (!lidFace?.solid) continue;\n\n    const inset = lidConfig.inset * scale;\n\n    // Calculate the slot based on assembly axis and face\n    // The slot is a horizontal or vertical line where the lid tabs meet this wall\n    let slotPosition: number;  // Position along face's primary axis\n    let slotLength: number;     // Length of the intersection\n    let orientation: 'horizontal' | 'vertical';\n    let startInset = 0;\n    let endInset = 0;\n\n    // Determine slot position based on which face and which lid\n    switch (assembly.assemblyAxis) {\n      case 'y':\n        // Top/bottom are lids\n        // Walls (front/back/left/right) get horizontal slots at top/bottom edges\n        if (side === 'positive') {\n          // Top lid - slot at top of wall\n          slotPosition = (height / 2 - materialThickness / 2 - lidConfig.inset) * scale;\n        } else {\n          // Bottom lid - slot at bottom of wall\n          slotPosition = (-height / 2 + materialThickness / 2 + lidConfig.inset) * scale;\n        }\n        orientation = 'horizontal';\n\n        // Slot length depends on which wall\n        if (faceId === 'front' || faceId === 'back') {\n          slotLength = width * scale;\n          // Insets where lid meets left/right walls\n          const leftFace = faces.find(f => f.id === 'left');\n          const rightFace = faces.find(f => f.id === 'right');\n          startInset = leftFace?.solid ? T : 0;\n          endInset = rightFace?.solid ? T : 0;\n        } else {  // left or right\n          slotLength = depth * scale;\n          // Insets where lid meets front/back walls\n          const backFace = faces.find(f => f.id === 'back');\n          const frontFace = faces.find(f => f.id === 'front');\n          startInset = (faceId === 'left' ? backFace : frontFace)?.solid ? T : 0;\n          endInset = (faceId === 'left' ? frontFace : backFace)?.solid ? T : 0;\n        }\n        break;\n\n      case 'x':\n        // Left/right are lids\n        // Walls (front/back/top/bottom) get vertical slots at left/right edges\n        if (side === 'positive') {\n          // Right lid - slot at right of wall\n          slotPosition = (width / 2 - materialThickness / 2 - lidConfig.inset) * scale;\n        } else {\n          // Left lid - slot at left of wall\n          slotPosition = (-width / 2 + materialThickness / 2 + lidConfig.inset) * scale;\n        }\n        orientation = 'vertical';\n\n        // Slot length depends on which wall\n        if (faceId === 'front' || faceId === 'back') {\n          slotLength = height * scale;\n          const topFace = faces.find(f => f.id === 'top');\n          const bottomFace = faces.find(f => f.id === 'bottom');\n          startInset = bottomFace?.solid ? T : 0;\n          endInset = topFace?.solid ? T : 0;\n        } else {  // top or bottom\n          slotLength = depth * scale;\n          const backFace = faces.find(f => f.id === 'back');\n          const frontFace = faces.find(f => f.id === 'front');\n          startInset = (faceId === 'top' ? frontFace : backFace)?.solid ? T : 0;\n          endInset = (faceId === 'top' ? backFace : frontFace)?.solid ? T : 0;\n        }\n        break;\n\n      case 'z':\n        // Front/back are lids\n        // Left/right walls get vertical slots, top/bottom walls get horizontal slots\n        if (side === 'positive') {\n          // Front lid - slot at front of wall (positive Z)\n          if (faceId === 'left') {\n            slotPosition = (depth / 2 - materialThickness / 2 - lidConfig.inset) * scale;\n          } else if (faceId === 'right') {\n            slotPosition = (-depth / 2 + materialThickness / 2 + lidConfig.inset) * scale;\n          } else {\n            // top/bottom - slot along Y (negative for top, positive for bottom due to rotation)\n            slotPosition = (faceId === 'top' ? -1 : 1) * (depth / 2 - materialThickness / 2 - lidConfig.inset) * scale;\n          }\n        } else {\n          // Back lid - slot at back of wall (negative Z)\n          if (faceId === 'left') {\n            slotPosition = (-depth / 2 + materialThickness / 2 + lidConfig.inset) * scale;\n          } else if (faceId === 'right') {\n            slotPosition = (depth / 2 - materialThickness / 2 - lidConfig.inset) * scale;\n          } else {\n            slotPosition = (faceId === 'top' ? 1 : -1) * (depth / 2 - materialThickness / 2 - lidConfig.inset) * scale;\n          }\n        }\n\n        // Slot length and orientation depend on which wall\n        if (faceId === 'left' || faceId === 'right') {\n          slotLength = height * scale;\n          orientation = 'vertical';\n          const topFace = faces.find(f => f.id === 'top');\n          const bottomFace = faces.find(f => f.id === 'bottom');\n          startInset = bottomFace?.solid ? T : 0;\n          endInset = topFace?.solid ? T : 0;\n        } else {  // top or bottom\n          slotLength = width * scale;\n          orientation = 'horizontal';  // Slots run along X on top/bottom faces\n          const leftFace = faces.find(f => f.id === 'left');\n          const rightFace = faces.find(f => f.id === 'right');\n          startInset = leftFace?.solid ? T : 0;\n          endInset = rightFace?.solid ? T : 0;\n        }\n        break;\n    }\n\n    intersections.push({\n      subdivisionId: `lid-${side}`,\n      position: slotPosition,\n      length: slotLength,\n      orientation,\n      dividerBounds: { x: 0, y: 0, z: 0, w: width, h: height, d: depth },\n      dividerAxis: assembly.assemblyAxis,\n      startInset,\n      endInset,\n    });\n  }\n\n  return intersections;\n};\n\nexport const Box3D: React.FC = () => {\n  const { config, faces, rootVoid, subdivisionPreview, subAssemblyPreview, selectionMode, selectedPanelIds, selectPanel, selectedAssemblyId, selectAssembly, hiddenVoidIds, isolatedVoidId, hiddenSubAssemblyIds, isolatedSubAssemblyId, hiddenFaceIds, panelsDirty, generatePanels, panelCollection, showDebugAnchors } = useBoxStore();\n  const { width, height, depth } = config;\n\n  // Auto-generate panels when dirty\n  useEffect(() => {\n    if (panelsDirty) {\n      generatePanels();\n    }\n  }, [panelsDirty, generatePanels]);\n\n  const scale = 100 / Math.max(width, height, depth);\n  const scaledW = width * scale;\n  const scaledH = height * scale;\n  const scaledD = depth * scale;\n  const scaledThickness = config.materialThickness * scale;\n\n  const boxCenter = { x: width / 2, y: height / 2, z: depth / 2 };\n\n  // Get face configs with proper thickness offset\n  const faceConfigs = getFaceConfigs(scaledThickness);\n\n  // Get all leaf voids (selectable cells)\n  const leafVoids = getLeafVoids(rootVoid);\n\n  // Get all subdivisions for rendering divider planes\n  const subdivisions = getAllSubdivisions(rootVoid);\n\n  // Get all sub-assemblies\n  const subAssemblies = getAllSubAssemblies(rootVoid);\n\n  // Get preview void bounds if preview is active, with insets for panel thickness\n  const previewVoid = subdivisionPreview ? findVoid(rootVoid, subdivisionPreview.voidId) : null;\n\n  // Calculate offset for preview voids to convert from void coordinates to centered world coordinates\n  // This needs to account for: main wall thickness, sub-assembly position, and main box center\n  const previewOffset = useMemo(() => {\n    if (!subdivisionPreview) return { x: 0, y: 0, z: 0 };\n\n    const mainCenterX = config.width / 2;\n    const mainCenterY = config.height / 2;\n    const mainCenterZ = config.depth / 2;\n\n    // Find the sub-assembly that contains this void\n    const subAssemblyInfo = findParentSubAssemblyInfo(rootVoid, subdivisionPreview.voidId);\n\n    if (!subAssemblyInfo) {\n      // Void is in main box - offset just centers the coordinates\n      // Void coords use exterior dimensions (0 to width), so we just need to subtract the center\n      return {\n        x: -mainCenterX,\n        y: -mainCenterY,\n        z: -mainCenterZ,\n      };\n    }\n\n    const { subAssembly, parentBounds } = subAssemblyInfo;\n\n    // Sub-assembly outer dimensions\n    const subOuterW = subAssembly.rootVoid.bounds.w + 2 * subAssembly.materialThickness;\n    const subOuterH = subAssembly.rootVoid.bounds.h + 2 * subAssembly.materialThickness;\n    const subOuterD = subAssembly.rootVoid.bounds.d + 2 * subAssembly.materialThickness;\n\n    const offsets = subAssembly.faceOffsets || { left: 0, right: 0, top: 0, bottom: 0, front: 0, back: 0 };\n\n    // Sub-assembly center in main interior coordinates\n    const subCenterX = parentBounds.x + subAssembly.clearance - offsets.left + subOuterW / 2;\n    const subCenterY = parentBounds.y + subAssembly.clearance - offsets.bottom + subOuterH / 2;\n    const subCenterZ = parentBounds.z + subAssembly.clearance - offsets.back + subOuterD / 2;\n\n    // Sub-assembly interior dimensions\n    const subInteriorW = subAssembly.rootVoid.bounds.w;\n    const subInteriorH = subAssembly.rootVoid.bounds.h;\n    const subInteriorD = subAssembly.rootVoid.bounds.d;\n\n    // Offset to convert from sub-assembly interior coordinates to main-box-centered world coordinates\n    // Interior coords (0,0,0) is the interior corner of the sub-assembly\n    // This corner is at: main wall thickness + sub-assembly position + sub-assembly wall thickness\n    // = mainMaterialThickness + (subCenter - subOuterSize/2 + subMaterialThickness)\n    // = mainMaterialThickness + subCenter - subInteriorSize/2 - subMaterialThickness + subMaterialThickness\n    // = mainMaterialThickness + subCenter - subInteriorSize/2\n    return {\n      x: config.materialThickness + subCenterX - subInteriorW / 2 - mainCenterX,\n      y: config.materialThickness + subCenterY - subInteriorH / 2 - mainCenterY,\n      z: config.materialThickness + subCenterZ - subInteriorD / 2 - mainCenterZ,\n    };\n  }, [rootVoid, subdivisionPreview, config]);\n\n  // Find the sub-assembly that contains this void (for face solid checks)\n  const previewSubAssembly = useMemo(() => {\n    if (!subdivisionPreview) return null;\n    for (const { subAssembly } of subAssemblies) {\n      if (findVoid(subAssembly.rootVoid, subdivisionPreview.voidId)) {\n        return subAssembly;\n      }\n    }\n    return null;\n  }, [subdivisionPreview, subAssemblies]);\n\n  // Calculate inset bounds for preview (accounting for solid outer faces)\n  const previewInsetBounds = useMemo(() => {\n    if (!previewVoid) return null;\n    const { bounds } = previewVoid;\n    const tolerance = 0.01;\n\n    // Use sub-assembly's material thickness and faces if inside one\n    const mt = previewSubAssembly?.materialThickness ?? config.materialThickness;\n    const previewFaces = previewSubAssembly?.faces ?? faces;\n\n    // For sub-assembly voids, check against the sub-assembly's interior dimensions\n    // The sub-assembly rootVoid bounds represent the interior space\n    const containerW = previewSubAssembly?.rootVoid.bounds.w ?? width;\n    const containerH = previewSubAssembly?.rootVoid.bounds.h ?? height;\n    const containerD = previewSubAssembly?.rootVoid.bounds.d ?? depth;\n\n    // Check which edges are at outer boundaries (of the containing box/sub-assembly)\n    const atLeft = bounds.x < tolerance;\n    const atRight = Math.abs(bounds.x + bounds.w - containerW) < tolerance;\n    const atBottom = bounds.y < tolerance;\n    const atTop = Math.abs(bounds.y + bounds.h - containerH) < tolerance;\n    const atBack = bounds.z < tolerance;\n    const atFront = Math.abs(bounds.z + bounds.d - containerD) < tolerance;\n\n    // Check which faces are solid (from main box or sub-assembly)\n    const leftSolid = previewFaces.find(f => f.id === 'left')?.solid ?? false;\n    const rightSolid = previewFaces.find(f => f.id === 'right')?.solid ?? false;\n    const bottomSolid = previewFaces.find(f => f.id === 'bottom')?.solid ?? false;\n    const topSolid = previewFaces.find(f => f.id === 'top')?.solid ?? false;\n    const backSolid = previewFaces.find(f => f.id === 'back')?.solid ?? false;\n    const frontSolid = previewFaces.find(f => f.id === 'front')?.solid ?? false;\n\n    // Calculate insets\n    const insetLeft = (atLeft && leftSolid) ? mt : 0;\n    const insetRight = (atRight && rightSolid) ? mt : 0;\n    const insetBottom = (atBottom && bottomSolid) ? mt : 0;\n    const insetTop = (atTop && topSolid) ? mt : 0;\n    const insetBack = (atBack && backSolid) ? mt : 0;\n    const insetFront = (atFront && frontSolid) ? mt : 0;\n\n    return {\n      x: bounds.x + insetLeft,\n      y: bounds.y + insetBottom,\n      z: bounds.z + insetBack,\n      w: bounds.w - insetLeft - insetRight,\n      h: bounds.h - insetBottom - insetTop,\n      d: bounds.d - insetBack - insetFront,\n    };\n  }, [previewVoid, config.materialThickness, width, height, depth, faces, previewSubAssembly]);\n\n  // Calculate the 8 box corner anchor points (inset by half material thickness)\n  // This represents the center of the panel material at each corner.\n  const halfMT = scaledThickness / 2;\n  const anchorCorners = useMemo(() => {\n    const hx = scaledW / 2 - halfMT;\n    const hy = scaledH / 2 - halfMT;\n    const hz = scaledD / 2 - halfMT;\n    return [\n      { x: -hx, y: -hy, z: -hz },\n      { x: hx, y: -hy, z: -hz },\n      { x: -hx, y: hy, z: -hz },\n      { x: hx, y: hy, z: -hz },\n      { x: -hx, y: -hy, z: hz },\n      { x: hx, y: -hy, z: hz },\n      { x: -hx, y: hy, z: hz },\n      { x: hx, y: hy, z: hz },\n    ];\n  }, [scaledW, scaledH, scaledD, halfMT]);\n\n  return (\n    <group>\n      {/* Wireframe box outline - RED shows outer dimensions for alignment verification */}\n      <lineSegments>\n        <edgesGeometry args={[new THREE.BoxGeometry(scaledW, scaledH, scaledD)]} />\n        <lineBasicMaterial color=\"#ff0000\" linewidth={2} />\n      </lineSegments>\n\n      {/* Debug anchor spheres at box corners (inset by half material thickness) */}\n      {showDebugAnchors && anchorCorners.map((corner, idx) => (\n        <mesh key={`anchor-${idx}`} position={[corner.x, corner.y, corner.z]}>\n          <sphereGeometry args={[2, 16, 16]} />\n          <meshStandardMaterial color=\"#ff6600\" />\n        </mesh>\n      ))}\n\n      {/* Render panels from stored paths when enabled and available */}\n      {USE_STORED_PATHS && panelCollection && (\n        <PanelCollectionRenderer\n          scale={scale}\n          selectedPanelIds={selectedPanelIds}\n          onPanelClick={(selectionMode === 'panel' || selectionMode === null) ? (panelId, e) => {\n            selectPanel(panelId, e?.shiftKey);\n          } : undefined}\n          onPanelDoubleClick={selectionMode === null ? (panelId) => {\n            // Look up panel to get its assembly from source\n            const panel = panelCollection.panels.find(p => p.id === panelId);\n            const assemblyId = panel?.source.subAssemblyId ?? 'main';\n            selectAssembly(assemblyId);\n          } : undefined}\n          hiddenFaceIds={hiddenFaceIds}\n        />\n      )}\n\n      {/* Face panels with finger joints and material thickness (old method, when not using stored paths) */}\n      {!USE_STORED_PATHS && faceConfigs.map((faceConfig) => {\n        const face = faces.find((f) => f.id === faceConfig.id);\n        const isSolid = face?.solid ?? true;\n        const faceId = `face-${faceConfig.id}`;\n        const isHidden = hiddenFaceIds.has(faceId);\n\n        // Skip hidden faces\n        if (isHidden) return null;\n\n        let [sizeW, sizeH] = faceConfig.size(scaledW, scaledH, scaledD);\n        let position = faceConfig.position(scaledW, scaledH, scaledD);\n\n        // Apply inset adjustments for lid faces\n        const faceRole = getFaceRole(faceConfig.id, config.assembly.assemblyAxis);\n        const lidSide = getLidSide(faceConfig.id, config.assembly.assemblyAxis);\n        if (faceRole === 'lid' && lidSide) {\n          const lidConfig = config.assembly.lids[lidSide];\n          const inset = lidConfig.inset * scale;\n\n          if (inset > 0) {\n            // Adjust position: move lid inward by inset amount\n            // Positive lid moves in negative direction, negative lid moves in positive direction\n            const insetDirection = lidSide === 'positive' ? -1 : 1;\n\n            switch (config.assembly.assemblyAxis) {\n              case 'y':\n                // Top/bottom lids - adjust Y position\n                position = [position[0], position[1] + insetDirection * inset, position[2]];\n                // Size stays the same when inset (tabs still go to walls, just positioned differently)\n                // But if inset is large enough, size might need to shrink to fit between walls\n                break;\n              case 'x':\n                // Left/right lids - adjust X position\n                position = [position[0] + insetDirection * inset, position[1], position[2]];\n                break;\n              case 'z':\n                // Front/back lids - adjust Z position\n                position = [position[0], position[1], position[2] + insetDirection * inset];\n                break;\n            }\n          }\n        }\n        const isSelectedPanel = selectedPanelIds.has(`face-${faceConfig.id}`);\n        const isSelectedAssembly = selectedAssemblyId === 'main';\n        const isPanelMode = selectionMode === 'panel';\n        const isAssemblyMode = selectionMode === 'assembly';\n\n        // Calculate which dividers intersect this face\n        const dividerIntersections = getDividerIntersections(\n          faceConfig.id,\n          subdivisions,\n          { width, height, depth },\n          scale,\n          config.materialThickness\n        );\n\n        // Calculate which lid tabs intersect this face (for walls when lids have tabs-out)\n        const lidIntersections = getLidIntersections(\n          faceConfig.id,\n          config.assembly,\n          faces,\n          { width, height, depth },\n          scale,\n          config.materialThickness\n        );\n\n        const handleClick = (e?: React.MouseEvent) => {\n          if (isPanelMode && isSolid) {\n            selectPanel(`face-${faceConfig.id}`, e?.shiftKey);\n          } else if (isAssemblyMode) {\n            selectAssembly(isSelectedAssembly ? null : 'main');\n          }\n        };\n\n        return (\n          <FaceWithFingers\n            key={faceConfig.id}\n            faceId={faceConfig.id}\n            position={position}\n            rotation={faceConfig.rotation}\n            sizeW={sizeW}\n            sizeH={sizeH}\n            scale={scale}\n            isSelected={isSelectedPanel || isSelectedAssembly}\n            isSolid={isSolid}\n            dividerIntersections={dividerIntersections}\n            lidIntersections={lidIntersections}\n            assembly={config.assembly}\n            onClick={(isPanelMode && isSolid) || isAssemblyMode ? handleClick : undefined}\n          />\n        );\n      })}\n\n      {/* Existing subdivision panels with finger joints (old method, when not using stored paths) */}\n      {!USE_STORED_PATHS && subdivisions.map((sub) => {\n        let position: [number, number, number];\n        let rotation: [number, number, number];\n        let sizeW: number;\n        let sizeH: number;\n\n        const { bounds } = sub;\n        const centerX = (bounds.x + bounds.w / 2 - boxCenter.x) * scale;\n        const centerY = (bounds.y + bounds.h / 2 - boxCenter.y) * scale;\n        const centerZ = (bounds.z + bounds.d / 2 - boxCenter.z) * scale;\n\n        switch (sub.axis) {\n          case 'x':\n            position = [(sub.position - boxCenter.x) * scale, centerY, centerZ];\n            rotation = [0, Math.PI / 2, 0];\n            sizeW = bounds.d * scale;\n            sizeH = bounds.h * scale;\n            break;\n          case 'y':\n            position = [centerX, (sub.position - boxCenter.y) * scale, centerZ];\n            rotation = [Math.PI / 2, 0, 0];\n            sizeW = bounds.w * scale;\n            sizeH = bounds.d * scale;\n            break;\n          case 'z':\n            position = [centerX, centerY, (sub.position - boxCenter.z) * scale];\n            rotation = [0, 0, 0];\n            sizeW = bounds.w * scale;\n            sizeH = bounds.h * scale;\n            break;\n        }\n\n        const isSelected = selectedPanelIds.has(`sub-${sub.id}`);\n        const isPanelMode = selectionMode === 'panel';\n\n        return (\n          <DividerPanel\n            key={sub.id}\n            subdivision={sub}\n            position={position}\n            rotation={rotation}\n            sizeW={sizeW}\n            sizeH={sizeH}\n            scale={scale}\n            boxDimensions={{ width, height, depth }}\n            isSelected={isSelected}\n            onClick={isPanelMode ? (e?: React.MouseEvent) => {\n              selectPanel(`sub-${sub.id}`, e?.shiftKey);\n            } : undefined}\n          />\n        );\n      })}\n\n      {/* Preview panels (semi-transparent, different color) with thickness */}\n      {subdivisionPreview && previewVoid && previewInsetBounds && subdivisionPreview.positions.map((pos, idx) => {\n        const bounds = previewInsetBounds;\n        let position: [number, number, number];\n        let rotation: [number, number, number];\n        let size: [number, number];\n\n        // Apply offset for converting void coords to centered world coords\n        // The offset already includes the main center subtraction\n        const offsetX = previewOffset.x;\n        const offsetY = previewOffset.y;\n        const offsetZ = previewOffset.z;\n\n        const centerX = (bounds.x + bounds.w / 2 + offsetX) * scale;\n        const centerY = (bounds.y + bounds.h / 2 + offsetY) * scale;\n        const centerZ = (bounds.z + bounds.d / 2 + offsetZ) * scale;\n\n        switch (subdivisionPreview.axis) {\n          case 'x':\n            position = [(pos + offsetX) * scale, centerY, centerZ];\n            rotation = [0, Math.PI / 2, 0];\n            size = [bounds.d * scale, bounds.h * scale];\n            break;\n          case 'y':\n            position = [centerX, (pos + offsetY) * scale, centerZ];\n            rotation = [Math.PI / 2, 0, 0];\n            size = [bounds.w * scale, bounds.d * scale];\n            break;\n          case 'z':\n            position = [centerX, centerY, (pos + offsetZ) * scale];\n            rotation = [0, 0, 0];\n            size = [bounds.w * scale, bounds.h * scale];\n            break;\n        }\n\n        return (\n          <mesh key={`preview-${idx}`} position={position} rotation={rotation}>\n            <boxGeometry args={[size[0], size[1], scaledThickness]} />\n            <meshStandardMaterial\n              color=\"#2ecc71\"\n              transparent\n              opacity={0.7}\n            />\n          </mesh>\n        );\n      })}\n\n      {/* Sub-assembly creation preview (wireframe box) */}\n      {subAssemblyPreview && (() => {\n        const { bounds } = subAssemblyPreview;\n        const centerX = (bounds.x + bounds.w / 2 - boxCenter.x) * scale;\n        const centerY = (bounds.y + bounds.h / 2 - boxCenter.y) * scale;\n        const centerZ = (bounds.z + bounds.d / 2 - boxCenter.z) * scale;\n        const scaledW = bounds.w * scale;\n        const scaledH = bounds.h * scale;\n        const scaledD = bounds.d * scale;\n\n        return (\n          <group position={[centerX, centerY, centerZ]}>\n            {/* Wireframe outline */}\n            <lineSegments>\n              <edgesGeometry args={[new THREE.BoxGeometry(scaledW, scaledH, scaledD)]} />\n              <lineBasicMaterial color=\"#2ecc71\" linewidth={2} />\n            </lineSegments>\n            {/* Semi-transparent fill */}\n            <mesh>\n              <boxGeometry args={[scaledW, scaledH, scaledD]} />\n              <meshStandardMaterial\n                color=\"#2ecc71\"\n                transparent\n                opacity={0.15}\n                depthWrite={false}\n              />\n            </mesh>\n          </group>\n        );\n      })()}\n\n      {/* Void cells (leaf voids are selectable) - filtered by visibility */}\n      {leafVoids\n        .filter((leafVoid) => isVoidVisible(leafVoid.id, rootVoid, hiddenVoidIds, isolatedVoidId))\n        .map((leafVoid) => (\n          <VoidMesh\n            key={leafVoid.id}\n            voidId={leafVoid.id}\n            bounds={{\n              x: leafVoid.bounds.x * scale,\n              y: leafVoid.bounds.y * scale,\n              z: leafVoid.bounds.z * scale,\n              w: leafVoid.bounds.w * scale,\n              h: leafVoid.bounds.h * scale,\n              d: leafVoid.bounds.d * scale,\n            }}\n            boxCenter={{\n              x: boxCenter.x * scale,\n              y: boxCenter.y * scale,\n              z: boxCenter.z * scale,\n            }}\n          />\n        ))}\n\n      {/* Sub-assemblies (drawers, trays, inserts) */}\n      {subAssemblies\n        .filter(({ voidId, subAssembly }) =>\n          isVoidVisible(voidId, rootVoid, hiddenVoidIds, isolatedVoidId) &&\n          isSubAssemblyVisible(subAssembly.id, hiddenSubAssemblyIds, isolatedSubAssemblyId)\n        )\n        .map(({ voidId, subAssembly, bounds }) => (\n          <SubAssembly3D\n            key={subAssembly.id}\n            subAssembly={subAssembly}\n            parentBounds={bounds}\n            scale={scale}\n            boxCenter={boxCenter}\n          />\n        ))}\n    </group>\n  );\n};\n","import React from 'react';\nimport { useBoxStore } from '../store/useBoxStore';\n\nexport const ViewportToolbar: React.FC = () => {\n  const { selectionMode, setSelectionMode, showDebugAnchors, toggleDebugAnchors } = useBoxStore();\n\n  // Non-null modes for the filter buttons\n  type FilterMode = 'assembly' | 'void' | 'panel';\n\n  const tools: { mode: FilterMode; label: string; icon: string; tooltip: string }[] = [\n    {\n      mode: 'assembly',\n      label: 'Assembly',\n      icon: '',\n      tooltip: 'Filter: select only assemblies',\n    },\n    {\n      mode: 'void',\n      label: 'Void',\n      icon: '',\n      tooltip: 'Filter: select only voids',\n    },\n    {\n      mode: 'panel',\n      label: 'Panel',\n      icon: '',\n      tooltip: 'Filter: select only panels',\n    },\n  ];\n\n  const handleToolClick = (mode: FilterMode) => {\n    // Toggle: if already active, turn off (set to null)\n    if (selectionMode === mode) {\n      setSelectionMode(null);\n    } else {\n      setSelectionMode(mode);\n    }\n  };\n\n  return (\n    <div className=\"viewport-toolbar\">\n      <div className=\"toolbar-group\">\n        <span className=\"toolbar-label\">Filter:</span>\n        {tools.map((tool) => (\n          <button\n            key={tool.mode}\n            className={`toolbar-btn ${selectionMode === tool.mode ? 'active' : ''}`}\n            onClick={() => handleToolClick(tool.mode)}\n            title={tool.tooltip}\n          >\n            <span className=\"toolbar-icon\">{tool.icon}</span>\n            <span className=\"toolbar-text\">{tool.label}</span>\n          </button>\n        ))}\n      </div>\n      <div className=\"toolbar-group\">\n        <span className=\"toolbar-label\">Debug:</span>\n        <button\n          className={`toolbar-btn ${showDebugAnchors ? 'active' : ''}`}\n          onClick={toggleDebugAnchors}\n          title=\"Show finger joint anchor points\"\n        >\n          <span className=\"toolbar-icon\"></span>\n          <span className=\"toolbar-text\">Anchors</span>\n        </button>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n\nexport type EditorTool =\n  | 'select'\n  | 'pan'\n  | 'rectangle'\n  | 'circle'\n  | 'path'\n  | 'inset'\n  | 'chamfer';\n\nexport type EditorMode = '2d' | '3d';\n\ninterface EditorToolbarProps {\n  mode: EditorMode;\n  activeTool?: EditorTool;\n  onToolChange?: (tool: EditorTool) => void;\n  mirrorX?: boolean;\n  mirrorY?: boolean;\n  onMirrorXChange?: (enabled: boolean) => void;\n  onMirrorYChange?: (enabled: boolean) => void;\n}\n\ninterface ToolButton {\n  id: EditorTool;\n  icon: string;\n  label: string;\n  tooltip: string;\n  modes: EditorMode[]; // Which modes this tool appears in\n}\n\nconst tools: ToolButton[] = [\n  {\n    id: 'select',\n    icon: '',\n    label: 'Select',\n    tooltip: 'Select elements (V)',\n    modes: ['2d', '3d'],\n  },\n  {\n    id: 'pan',\n    icon: '',\n    label: 'Pan',\n    tooltip: 'Pan view (Space+drag)',\n    modes: ['2d', '3d'],\n  },\n  {\n    id: 'rectangle',\n    icon: '',\n    label: 'Rect',\n    tooltip: 'Draw rectangle (R)',\n    modes: ['2d'],\n  },\n  {\n    id: 'circle',\n    icon: '',\n    label: 'Circle',\n    tooltip: 'Draw circle (C)',\n    modes: ['2d'],\n  },\n  {\n    id: 'path',\n    icon: '',\n    label: 'Path',\n    tooltip: 'Draw path (P)',\n    modes: ['2d'],\n  },\n  {\n    id: 'inset',\n    icon: '',\n    label: 'Inset',\n    tooltip: 'Inset/Outset edges (I)',\n    modes: ['2d'],\n  },\n  {\n    id: 'chamfer',\n    icon: '',\n    label: 'Chamfer',\n    tooltip: 'Chamfer corners (F)',\n    modes: ['2d'],\n  },\n];\n\nexport const EditorToolbar: React.FC<EditorToolbarProps> = ({\n  mode,\n  activeTool = 'select',\n  onToolChange,\n  mirrorX = false,\n  mirrorY = false,\n  onMirrorXChange,\n  onMirrorYChange,\n}) => {\n  // Filter tools based on current mode\n  const availableTools = tools.filter(t => t.modes.includes(mode));\n\n  const handleToolClick = (toolId: EditorTool) => {\n    if (onToolChange) {\n      onToolChange(toolId);\n    }\n  };\n\n  return (\n    <div className=\"editor-toolbar\">\n      {/* Tool buttons */}\n      <div className=\"editor-toolbar-section\">\n        <span className=\"editor-toolbar-label\">Tools</span>\n        <div className=\"editor-toolbar-buttons\">\n          {availableTools.map((tool) => (\n            <button\n              key={tool.id}\n              className={`editor-tool-btn ${activeTool === tool.id ? 'active' : ''}`}\n              onClick={() => handleToolClick(tool.id)}\n              title={tool.tooltip}\n              disabled={!onToolChange}\n            >\n              <span className=\"editor-tool-icon\">{tool.icon}</span>\n              <span className=\"editor-tool-label\">{tool.label}</span>\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Mirror toggles - only in 2D mode */}\n      {mode === '2d' && (\n        <div className=\"editor-toolbar-section\">\n          <span className=\"editor-toolbar-label\">Mirror</span>\n          <div className=\"editor-toolbar-buttons\">\n            <button\n              className={`editor-tool-btn ${mirrorX ? 'active' : ''}`}\n              onClick={() => onMirrorXChange?.(!mirrorX)}\n              title=\"Mirror horizontally (X axis)\"\n              disabled={!onMirrorXChange}\n            >\n              <span className=\"editor-tool-icon\"></span>\n              <span className=\"editor-tool-label\">X</span>\n            </button>\n            <button\n              className={`editor-tool-btn ${mirrorY ? 'active' : ''}`}\n              onClick={() => onMirrorYChange?.(!mirrorY)}\n              title=\"Mirror vertically (Y axis)\"\n              disabled={!onMirrorYChange}\n            >\n              <span className=\"editor-tool-icon\"></span>\n              <span className=\"editor-tool-label\">Y</span>\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Placeholder for future sections */}\n      {mode === '2d' && (\n        <div className=\"editor-toolbar-section\">\n          <span className=\"editor-toolbar-label\">Boolean</span>\n          <div className=\"editor-toolbar-buttons\">\n            <button\n              className=\"editor-tool-btn\"\n              title=\"Add (Union)\"\n              disabled\n            >\n              <span className=\"editor-tool-icon\">+</span>\n              <span className=\"editor-tool-label\">Add</span>\n            </button>\n            <button\n              className=\"editor-tool-btn\"\n              title=\"Subtract (Cut)\"\n              disabled\n            >\n              <span className=\"editor-tool-icon\"></span>\n              <span className=\"editor-tool-label\">Cut</span>\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n","import React, { useEffect, useRef, useImperativeHandle, forwardRef, useCallback } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { OrbitControls, Grid, Environment } from '@react-three/drei';\nimport { Box3D } from './Box3D';\nimport { ViewportToolbar } from './ViewportToolbar';\nimport { EditorToolbar } from './EditorToolbar';\nimport { useBoxStore } from '../store/useBoxStore';\nimport { FaceId } from '../types';\n\nexport interface Viewport3DHandle {\n  getCanvas: () => HTMLCanvasElement | null;\n}\n\nexport const Viewport3D = forwardRef<Viewport3DHandle>((_, ref) => {\n  const clearSelection = useBoxStore((state) => state.clearSelection);\n  const selectedPanelIds = useBoxStore((state) => state.selectedPanelIds);\n  const panelCollection = useBoxStore((state) => state.panelCollection);\n  const toggleFace = useBoxStore((state) => state.toggleFace);\n  const purgeVoid = useBoxStore((state) => state.purgeVoid);\n  const canvasContainerRef = useRef<HTMLDivElement>(null);\n\n  // Expose method to get the canvas element\n  useImperativeHandle(ref, () => ({\n    getCanvas: () => {\n      if (!canvasContainerRef.current) return null;\n      return canvasContainerRef.current.querySelector('canvas');\n    },\n  }));\n\n  // Handle deletion of selected panels\n  const handleDeleteSelectedPanels = useCallback(() => {\n    if (selectedPanelIds.size === 0 || !panelCollection) return;\n\n    // Process each selected panel\n    for (const panelId of selectedPanelIds) {\n      const panel = panelCollection.panels.find(p => p.id === panelId);\n      if (!panel) continue;\n\n      if (panel.source.type === 'face') {\n        // Face panel: toggle to non-solid (make it open)\n        const faceId = panel.source.faceId;\n        if (faceId) {\n          toggleFace(faceId as FaceId);\n        }\n      } else if (panel.source.type === 'divider') {\n        // Divider panel: remove the subdivision\n        // subdivisionId format is \"{voidId}-split\"\n        const subdivisionId = panel.source.subdivisionId;\n        if (subdivisionId && subdivisionId.endsWith('-split')) {\n          const voidId = subdivisionId.slice(0, -6); // Remove '-split' suffix\n          purgeVoid(voidId);\n        }\n      }\n    }\n\n    // Clear selection after deletion\n    clearSelection();\n  }, [selectedPanelIds, panelCollection, toggleFace, purgeVoid, clearSelection]);\n\n  // Handle keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Don't handle if user is typing in an input field\n      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {\n        return;\n      }\n\n      if (e.key === 'Escape') {\n        clearSelection();\n      } else if (e.key === 'Delete' || e.key === 'Backspace') {\n        e.preventDefault(); // Prevent browser back navigation on Backspace\n        handleDeleteSelectedPanels();\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [clearSelection, handleDeleteSelectedPanels]);\n\n  return (\n    <div className=\"viewport-container\" ref={canvasContainerRef}>\n      <ViewportToolbar />\n      <EditorToolbar mode=\"3d\" />\n      <Canvas\n        camera={{ position: [150, 150, 150], fov: 50 }}\n        style={{ background: '#1a1a2e' }}\n        gl={{ preserveDrawingBuffer: true }}\n        onPointerMissed={() => clearSelection()}\n      >\n        <ambientLight intensity={0.5} />\n        <directionalLight position={[10, 10, 5]} intensity={1} />\n        <pointLight position={[-10, -10, -5]} intensity={0.5} />\n\n        <Box3D />\n\n        <Grid\n          args={[200, 200]}\n          cellSize={10}\n          cellThickness={0.5}\n          cellColor=\"#444\"\n          sectionSize={50}\n          sectionThickness={1}\n          sectionColor=\"#666\"\n          fadeDistance={400}\n          fadeStrength={1}\n          followCamera={false}\n          position={[0, -60, 0]}\n        />\n\n        <OrbitControls\n          makeDefault\n          enablePan={true}\n          enableZoom={true}\n          enableRotate={true}\n          minDistance={50}\n          maxDistance={500}\n        />\n\n        <Environment preset=\"studio\" />\n      </Canvas>\n    </div>\n  );\n});\n\nViewport3D.displayName = 'Viewport3D';\n","/**\n * Calculate editable areas (safe zones for cutouts) for a panel\n *\n * Editable areas are regions where:\n * - Cutouts can be added without affecting finger joints\n * - The user can safely modify the panel shape\n */\n\nimport { PanelPath, BoxConfig, FaceConfig, AssemblyConfig } from '../types';\n\nexport interface EditableArea {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  label?: string;\n}\n\ntype EdgePosition = 'top' | 'bottom' | 'left' | 'right';\n\ninterface EdgeInfo {\n  position: EdgePosition;\n  hasJoints: boolean;\n  margin: number; // Distance from edge to editable area\n}\n\n/**\n * Determine if a face edge has finger joints (is connected to an adjacent solid face)\n */\nconst faceEdgeHasJoints = (\n  faceId: string,\n  edgePosition: EdgePosition,\n  faces: FaceConfig[],\n  assembly: AssemblyConfig\n): boolean => {\n  // Mapping of face ID to its neighbor on each edge\n  const neighborMap: Record<string, Record<EdgePosition, string>> = {\n    front: { top: 'top', bottom: 'bottom', left: 'left', right: 'right' },\n    back: { top: 'top', bottom: 'bottom', left: 'right', right: 'left' },\n    left: { top: 'top', bottom: 'bottom', left: 'back', right: 'front' },\n    right: { top: 'top', bottom: 'bottom', left: 'front', right: 'back' },\n    top: { top: 'back', bottom: 'front', left: 'left', right: 'right' },\n    bottom: { top: 'front', bottom: 'back', left: 'left', right: 'right' },\n  };\n\n  const neighbors = neighborMap[faceId];\n  if (!neighbors) return false;\n\n  const neighborId = neighbors[edgePosition];\n  const neighborFace = faces.find(f => f.id === neighborId);\n\n  // If neighbor face is solid, this edge has joints\n  return neighborFace?.solid ?? false;\n};\n\n/**\n * Get edge information for a face panel\n */\nconst getFaceEdgeInfo = (\n  faceId: string,\n  faces: FaceConfig[],\n  assembly: AssemblyConfig,\n  materialThickness: number\n): EdgeInfo[] => {\n  const edges: EdgePosition[] = ['top', 'bottom', 'left', 'right'];\n\n  return edges.map(position => {\n    const hasJoints = faceEdgeHasJoints(faceId, position, faces, assembly);\n    return {\n      position,\n      hasJoints,\n      // Margin from edge: materialThickness if has joints, 0 if open\n      margin: hasJoints ? materialThickness : 0,\n    };\n  });\n};\n\n/**\n * Get edge information for a divider panel\n * Dividers typically have joints on all edges\n */\nconst getDividerEdgeInfo = (\n  materialThickness: number\n): EdgeInfo[] => {\n  const edges: EdgePosition[] = ['top', 'bottom', 'left', 'right'];\n\n  return edges.map(position => ({\n    position,\n    hasJoints: true, // Dividers connect to faces on all sides\n    margin: materialThickness,\n  }));\n};\n\n/**\n * Calculate the main editable area for a panel\n * This is the central region away from all joints\n */\nexport const getEditableAreas = (\n  panel: PanelPath,\n  faces: FaceConfig[],\n  config: BoxConfig\n): EditableArea[] => {\n  const { materialThickness } = config;\n\n  // Calculate original dimensions (without extensions)\n  const ext = panel.edgeExtensions ?? { top: 0, bottom: 0, left: 0, right: 0 };\n  const originalWidth = panel.width - (ext.left ?? 0) - (ext.right ?? 0);\n  const originalHeight = panel.height - (ext.top ?? 0) - (ext.bottom ?? 0);\n\n  // Use original dimensions for positioning (panel outline uses original dims + extensions)\n  const halfW = originalWidth / 2;\n  const halfH = originalHeight / 2;\n\n  let edgeInfos: EdgeInfo[];\n\n  if (panel.source.type === 'face' && panel.source.faceId) {\n    edgeInfos = getFaceEdgeInfo(\n      panel.source.faceId,\n      faces,\n      config.assembly,\n      materialThickness\n    );\n  } else if (panel.source.type === 'divider') {\n    edgeInfos = getDividerEdgeInfo(materialThickness);\n  } else {\n    // Unknown panel type - use conservative margins\n    edgeInfos = ['top', 'bottom', 'left', 'right'].map(position => ({\n      position: position as EdgePosition,\n      hasJoints: true,\n      margin: materialThickness,\n    }));\n  }\n\n  // Get margins for each edge\n  const topMargin = edgeInfos.find(e => e.position === 'top')?.margin ?? materialThickness;\n  const bottomMargin = edgeInfos.find(e => e.position === 'bottom')?.margin ?? materialThickness;\n  const leftMargin = edgeInfos.find(e => e.position === 'left')?.margin ?? materialThickness;\n  const rightMargin = edgeInfos.find(e => e.position === 'right')?.margin ?? materialThickness;\n\n  // Calculate the main editable area (based on original dimensions)\n  const mainArea: EditableArea = {\n    x: -halfW + leftMargin,\n    y: -halfH + bottomMargin,\n    width: originalWidth - leftMargin - rightMargin,\n    height: originalHeight - topMargin - bottomMargin,\n    label: 'Safe zone',\n  };\n\n  // Only return the area if it has positive dimensions\n  const areas: EditableArea[] = [];\n\n  if (mainArea.width > 0 && mainArea.height > 0) {\n    areas.push(mainArea);\n  }\n\n  // For edges without joints (open faces), we can have additional editable strips\n  // extending all the way to those edges\n  for (const edgeInfo of edgeInfos) {\n    if (!edgeInfo.hasJoints) {\n      // This edge is open - create an extended editable strip\n      let stripArea: EditableArea | null = null;\n\n      switch (edgeInfo.position) {\n        case 'top':\n          if (topMargin === 0) {\n            stripArea = {\n              x: -halfW + leftMargin,\n              y: halfH - materialThickness, // Top strip\n              width: originalWidth - leftMargin - rightMargin,\n              height: materialThickness,\n              label: 'Top edge (open)',\n            };\n          }\n          break;\n        case 'bottom':\n          if (bottomMargin === 0) {\n            stripArea = {\n              x: -halfW + leftMargin,\n              y: -halfH,\n              width: originalWidth - leftMargin - rightMargin,\n              height: materialThickness,\n              label: 'Bottom edge (open)',\n            };\n          }\n          break;\n        case 'left':\n          if (leftMargin === 0) {\n            stripArea = {\n              x: -halfW,\n              y: -halfH + bottomMargin,\n              width: materialThickness,\n              height: originalHeight - topMargin - bottomMargin,\n              label: 'Left edge (open)',\n            };\n          }\n          break;\n        case 'right':\n          if (rightMargin === 0) {\n            stripArea = {\n              x: halfW - materialThickness,\n              y: -halfH + bottomMargin,\n              width: materialThickness,\n              height: originalHeight - topMargin - bottomMargin,\n              label: 'Right edge (open)',\n            };\n          }\n          break;\n      }\n\n      // For open edges, actually extend the main area to include them\n      // Instead of adding separate strips, we've already handled this above\n      // by setting margin to 0\n    }\n  }\n\n  // Add editable areas for extended edges\n  // The extended portion is outside the original joint area and is safe to edit\n  const extTop = ext.top ?? 0;\n  const extBottom = ext.bottom ?? 0;\n  const extLeft = ext.left ?? 0;\n  const extRight = ext.right ?? 0;\n\n  // Top extension area\n  if (extTop > 0) {\n    areas.push({\n      x: -halfW + leftMargin,\n      y: halfH, // Start from original top edge\n      width: originalWidth - leftMargin - rightMargin,\n      height: extTop,\n      label: 'Extended top',\n    });\n  }\n\n  // Bottom extension area\n  if (extBottom > 0) {\n    areas.push({\n      x: -halfW + leftMargin,\n      y: -halfH - extBottom, // Start from extended bottom\n      width: originalWidth - leftMargin - rightMargin,\n      height: extBottom,\n      label: 'Extended bottom',\n    });\n  }\n\n  // Left extension area\n  if (extLeft > 0) {\n    areas.push({\n      x: -halfW - extLeft, // Start from extended left\n      y: -halfH + bottomMargin,\n      width: extLeft,\n      height: originalHeight - topMargin - bottomMargin,\n      label: 'Extended left',\n    });\n  }\n\n  // Right extension area\n  if (extRight > 0) {\n    areas.push({\n      x: halfW, // Start from original right edge\n      y: -halfH + bottomMargin,\n      width: extRight,\n      height: originalHeight - topMargin - bottomMargin,\n      label: 'Extended right',\n    });\n  }\n\n  return areas;\n};\n\n/**\n * Check if a point is within any editable area\n */\nexport const isPointInEditableArea = (\n  x: number,\n  y: number,\n  areas: EditableArea[]\n): boolean => {\n  for (const area of areas) {\n    if (\n      x >= area.x &&\n      x <= area.x + area.width &&\n      y >= area.y &&\n      y <= area.y + area.height\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Check if a rectangle is fully within any editable area\n */\nexport const isRectInEditableArea = (\n  rectX: number,\n  rectY: number,\n  rectWidth: number,\n  rectHeight: number,\n  areas: EditableArea[]\n): boolean => {\n  // Check all four corners\n  const corners = [\n    { x: rectX, y: rectY },\n    { x: rectX + rectWidth, y: rectY },\n    { x: rectX, y: rectY + rectHeight },\n    { x: rectX + rectWidth, y: rectY + rectHeight },\n  ];\n\n  // All corners must be in some editable area (not necessarily the same one)\n  for (const corner of corners) {\n    if (!isPointInEditableArea(corner.x, corner.y, areas)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","/**\n * Corner finishing utilities - chamfers and fillets\n */\n\nimport { PathPoint, CornerFinish, CornerFinishType } from '../types';\n\nexport type { CornerFinishType, CornerFinish };\n\nexport interface DetectedCorner {\n  id: string;\n  index: number;  // Index in the points array\n  position: { x: number; y: number };\n  angle: number;  // Interior angle in radians\n  eligible: boolean;\n  maxRadius: number;\n  incomingEdgeLength: number;\n  outgoingEdgeLength: number;\n}\n\n/**\n * Calculate the angle between two vectors\n */\nconst angleBetweenVectors = (\n  v1: { x: number; y: number },\n  v2: { x: number; y: number }\n): number => {\n  const dot = v1.x * v2.x + v1.y * v2.y;\n  const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);\n  const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);\n\n  if (mag1 === 0 || mag2 === 0) return 0;\n\n  const cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));\n  return Math.acos(cosAngle);\n};\n\n/**\n * Detect corners in a panel outline\n *\n * A corner is any vertex where the angle changes significantly (not straight)\n */\nexport const detectCorners = (\n  points: PathPoint[],\n  panelWidth: number,\n  panelHeight: number,\n  materialThickness: number\n): DetectedCorner[] => {\n  if (points.length < 3) return [];\n\n  const corners: DetectedCorner[] = [];\n  const halfW = panelWidth / 2;\n  const halfH = panelHeight / 2;\n\n  // Threshold for corner detection (degrees from straight = 180)\n  const angleThreshold = Math.PI * 0.9; // About 162 degrees\n\n  for (let i = 0; i < points.length; i++) {\n    const prevIdx = (i - 1 + points.length) % points.length;\n    const nextIdx = (i + 1) % points.length;\n\n    const prev = points[prevIdx];\n    const curr = points[i];\n    const next = points[nextIdx];\n\n    // Vectors for incoming and outgoing edges\n    const inVec = { x: curr.x - prev.x, y: curr.y - prev.y };\n    const outVec = { x: next.x - curr.x, y: next.y - curr.y };\n\n    // Edge lengths\n    const inLength = Math.sqrt(inVec.x * inVec.x + inVec.y * inVec.y);\n    const outLength = Math.sqrt(outVec.x * outVec.x + outVec.y * outVec.y);\n\n    // Skip very short edges (likely part of finger joints)\n    if (inLength < materialThickness * 0.5 || outLength < materialThickness * 0.5) {\n      continue;\n    }\n\n    // Calculate interior angle\n    const angle = angleBetweenVectors(inVec, outVec);\n\n    // Only detect corners where angle is less than threshold (not nearly straight)\n    if (angle > angleThreshold) continue;\n\n    // Check if this corner is at the panel boundary (eligible for finishing)\n    const atEdge = (\n      Math.abs(curr.x - halfW) < 1 ||\n      Math.abs(curr.x + halfW) < 1 ||\n      Math.abs(curr.y - halfH) < 1 ||\n      Math.abs(curr.y + halfH) < 1\n    );\n\n    // Check if this is an outer corner (not part of finger joint pattern)\n    // Outer corners typically have both adjacent edges going in different primary directions\n    const isOuterCorner = atEdge && inLength > materialThickness && outLength > materialThickness;\n\n    // Maximum radius is limited by the shorter of the two adjacent edges\n    const maxRadius = Math.min(inLength, outLength) * 0.4; // 40% of shorter edge\n\n    // Corner is eligible if it's at the panel boundary and not too small\n    const eligible = isOuterCorner && maxRadius >= 1;\n\n    corners.push({\n      id: `corner-${i}`,\n      index: i,\n      position: { x: curr.x, y: curr.y },\n      angle,\n      eligible,\n      maxRadius,\n      incomingEdgeLength: inLength,\n      outgoingEdgeLength: outLength,\n    });\n  }\n\n  return corners;\n};\n\n/**\n * Detect only the 4 main panel corners (simplified version)\n */\nexport const detectMainCorners = (\n  panelWidth: number,\n  panelHeight: number,\n  materialThickness: number\n): DetectedCorner[] => {\n  const halfW = panelWidth / 2;\n  const halfH = panelHeight / 2;\n\n  // Default max radius based on material thickness\n  const defaultMaxRadius = Math.min(halfW, halfH) * 0.3;\n\n  return [\n    {\n      id: 'corner-tl',\n      index: -1,\n      position: { x: -halfW, y: halfH },\n      angle: Math.PI / 2,\n      eligible: true,\n      maxRadius: defaultMaxRadius,\n      incomingEdgeLength: panelWidth,\n      outgoingEdgeLength: panelHeight,\n    },\n    {\n      id: 'corner-tr',\n      index: -1,\n      position: { x: halfW, y: halfH },\n      angle: Math.PI / 2,\n      eligible: true,\n      maxRadius: defaultMaxRadius,\n      incomingEdgeLength: panelHeight,\n      outgoingEdgeLength: panelWidth,\n    },\n    {\n      id: 'corner-br',\n      index: -1,\n      position: { x: halfW, y: -halfH },\n      angle: Math.PI / 2,\n      eligible: true,\n      maxRadius: defaultMaxRadius,\n      incomingEdgeLength: panelWidth,\n      outgoingEdgeLength: panelHeight,\n    },\n    {\n      id: 'corner-bl',\n      index: -1,\n      position: { x: -halfW, y: -halfH },\n      angle: Math.PI / 2,\n      eligible: true,\n      maxRadius: defaultMaxRadius,\n      incomingEdgeLength: panelHeight,\n      outgoingEdgeLength: panelWidth,\n    },\n  ];\n};\n\n/**\n * Apply a chamfer to a corner\n *\n * Replaces the corner point with two points creating a 45-degree cut\n */\nexport const applyChamfer = (\n  corner: PathPoint,\n  prevPoint: PathPoint,\n  nextPoint: PathPoint,\n  radius: number\n): PathPoint[] => {\n  // Direction vectors\n  const inVec = { x: corner.x - prevPoint.x, y: corner.y - prevPoint.y };\n  const outVec = { x: nextPoint.x - corner.x, y: nextPoint.y - corner.y };\n\n  // Normalize\n  const inLen = Math.sqrt(inVec.x * inVec.x + inVec.y * inVec.y);\n  const outLen = Math.sqrt(outVec.x * outVec.x + outVec.y * outVec.y);\n\n  if (inLen === 0 || outLen === 0) return [corner];\n\n  const inNorm = { x: inVec.x / inLen, y: inVec.y / inLen };\n  const outNorm = { x: outVec.x / outLen, y: outVec.y / outLen };\n\n  // Clamp radius to not exceed half of either edge\n  const clampedRadius = Math.min(radius, inLen * 0.5, outLen * 0.5);\n\n  // Calculate the two chamfer points\n  const p1: PathPoint = {\n    x: corner.x - inNorm.x * clampedRadius,\n    y: corner.y - inNorm.y * clampedRadius,\n  };\n\n  const p2: PathPoint = {\n    x: corner.x + outNorm.x * clampedRadius,\n    y: corner.y + outNorm.y * clampedRadius,\n  };\n\n  return [p1, p2];\n};\n\n/**\n * Apply a fillet (rounded corner) to a corner\n *\n * Replaces the corner point with an arc approximation\n */\nexport const applyFillet = (\n  corner: PathPoint,\n  prevPoint: PathPoint,\n  nextPoint: PathPoint,\n  radius: number,\n  segments: number = 8\n): PathPoint[] => {\n  // Direction vectors\n  const inVec = { x: corner.x - prevPoint.x, y: corner.y - prevPoint.y };\n  const outVec = { x: nextPoint.x - corner.x, y: nextPoint.y - corner.y };\n\n  // Normalize\n  const inLen = Math.sqrt(inVec.x * inVec.x + inVec.y * inVec.y);\n  const outLen = Math.sqrt(outVec.x * outVec.x + outVec.y * outVec.y);\n\n  if (inLen === 0 || outLen === 0) return [corner];\n\n  const inNorm = { x: inVec.x / inLen, y: inVec.y / inLen };\n  const outNorm = { x: outVec.x / outLen, y: outVec.y / outLen };\n\n  // Clamp radius to not exceed half of either edge\n  const clampedRadius = Math.min(radius, inLen * 0.5, outLen * 0.5);\n\n  // Calculate the two tangent points (where the arc starts and ends)\n  const startPoint: PathPoint = {\n    x: corner.x - inNorm.x * clampedRadius,\n    y: corner.y - inNorm.y * clampedRadius,\n  };\n\n  const endPoint: PathPoint = {\n    x: corner.x + outNorm.x * clampedRadius,\n    y: corner.y + outNorm.y * clampedRadius,\n  };\n\n  // Calculate the arc center\n  // The center is at distance radius from both the start and end points\n  // It's perpendicular to each edge at the tangent points\n\n  // Perpendicular directions (inward toward center)\n  const perpIn = { x: inNorm.y, y: -inNorm.x };\n  const perpOut = { x: -outNorm.y, y: outNorm.x };\n\n  // Cross product to determine which side the center is on\n  const cross = inNorm.x * outNorm.y - inNorm.y * outNorm.x;\n\n  // Adjust perpendicular based on corner direction (convex vs concave)\n  const inwardPerpIn = cross > 0 ? perpIn : { x: -perpIn.x, y: -perpIn.y };\n  const inwardPerpOut = cross > 0 ? perpOut : { x: -perpOut.x, y: -perpOut.y };\n\n  // Calculate center (average of the two perpendicular approaches)\n  const center: PathPoint = {\n    x: (startPoint.x + inwardPerpIn.x * clampedRadius + endPoint.x + inwardPerpOut.x * clampedRadius) / 2,\n    y: (startPoint.y + inwardPerpIn.y * clampedRadius + endPoint.y + inwardPerpOut.y * clampedRadius) / 2,\n  };\n\n  // Calculate start and end angles\n  const startAngle = Math.atan2(startPoint.y - center.y, startPoint.x - center.x);\n  const endAngle = Math.atan2(endPoint.y - center.y, endPoint.x - center.x);\n\n  // Determine arc direction\n  let angleDiff = endAngle - startAngle;\n  if (cross > 0) {\n    if (angleDiff > 0) angleDiff -= 2 * Math.PI;\n  } else {\n    if (angleDiff < 0) angleDiff += 2 * Math.PI;\n  }\n\n  // Generate arc points\n  const points: PathPoint[] = [startPoint];\n\n  for (let i = 1; i < segments; i++) {\n    const t = i / segments;\n    const angle = startAngle + angleDiff * t;\n    points.push({\n      x: center.x + Math.cos(angle) * clampedRadius,\n      y: center.y + Math.sin(angle) * clampedRadius,\n    });\n  }\n\n  points.push(endPoint);\n\n  return points;\n};\n\n/**\n * Apply corner finishes to a panel outline\n */\nexport const applyCornerFinishes = (\n  points: PathPoint[],\n  finishes: CornerFinish[],\n  corners: DetectedCorner[]\n): PathPoint[] => {\n  if (finishes.length === 0) return points;\n\n  const result: PathPoint[] = [];\n  const finishMap = new Map(finishes.map(f => [f.cornerId, f]));\n\n  for (let i = 0; i < points.length; i++) {\n    const corner = corners.find(c => c.index === i);\n    const finish = corner ? finishMap.get(corner.id) : undefined;\n\n    if (finish && finish.type !== 'none' && finish.radius > 0) {\n      const prevIdx = (i - 1 + points.length) % points.length;\n      const nextIdx = (i + 1) % points.length;\n\n      const prevPoint = points[prevIdx];\n      const currPoint = points[i];\n      const nextPoint = points[nextIdx];\n\n      if (finish.type === 'chamfer') {\n        const chamferPoints = applyChamfer(currPoint, prevPoint, nextPoint, finish.radius);\n        result.push(...chamferPoints);\n      } else if (finish.type === 'fillet') {\n        const filletPoints = applyFillet(currPoint, prevPoint, nextPoint, finish.radius);\n        result.push(...filletPoints);\n      }\n    } else {\n      result.push(points[i]);\n    }\n  }\n\n  return result;\n};\n","import React, { useMemo, useState, useRef, useCallback, useEffect } from 'react';\nimport { useBoxStore, getAllSubdivisions } from '../store/useBoxStore';\nimport { PathPoint, PanelPath, FaceId, Face } from '../types';\nimport { getFaceEdgeStatuses, getDividerEdgeStatuses, EdgeStatusInfo } from '../utils/panelGenerator';\nimport { getEditableAreas, EditableArea } from '../utils/editableAreas';\nimport { detectMainCorners, DetectedCorner } from '../utils/cornerFinish';\nimport { EditorToolbar } from './EditorToolbar';\n\ninterface SketchView2DProps {\n  className?: string;\n}\n\ntype EdgePosition = 'top' | 'bottom' | 'left' | 'right';\n\n// Convert path points to SVG path string\nconst pathToSvgD = (points: PathPoint[], closed: boolean): string => {\n  if (points.length === 0) return '';\n  const segments = points.map((p, i) =>\n    i === 0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`\n  );\n  if (closed) segments.push('Z');\n  return segments.join(' ');\n};\n\n// Classify a line segment to an edge based on position\nconst classifySegment = (\n  p1: PathPoint,\n  p2: PathPoint,\n  panelWidth: number,\n  panelHeight: number,\n  tolerance: number = 1\n): EdgePosition | null => {\n  const halfW = panelWidth / 2;\n  const halfH = panelHeight / 2;\n\n  // Check if both points are near the same edge\n  const nearTop = (p: PathPoint) => Math.abs(p.y - halfH) < tolerance;\n  const nearBottom = (p: PathPoint) => Math.abs(p.y + halfH) < tolerance;\n  const nearLeft = (p: PathPoint) => Math.abs(p.x + halfW) < tolerance;\n  const nearRight = (p: PathPoint) => Math.abs(p.x - halfW) < tolerance;\n\n  if (nearTop(p1) && nearTop(p2)) return 'top';\n  if (nearBottom(p1) && nearBottom(p2)) return 'bottom';\n  if (nearLeft(p1) && nearLeft(p2)) return 'left';\n  if (nearRight(p1) && nearRight(p2)) return 'right';\n\n  return null;\n};\n\n// Get segments grouped by edge\nconst getEdgeSegments = (\n  points: PathPoint[],\n  panelWidth: number,\n  panelHeight: number\n): Record<EdgePosition, { start: PathPoint; end: PathPoint }[]> => {\n  const edges: Record<EdgePosition, { start: PathPoint; end: PathPoint }[]> = {\n    top: [],\n    bottom: [],\n    left: [],\n    right: [],\n  };\n\n  for (let i = 0; i < points.length; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % points.length];\n    const edge = classifySegment(p1, p2, panelWidth, panelHeight);\n    if (edge) {\n      edges[edge].push({ start: p1, end: p2 });\n    }\n  }\n\n  return edges;\n};\n\n// Calculate distance from point to line segment\nconst distanceToSegment = (\n  px: number,\n  py: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n): number => {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lengthSq = dx * dx + dy * dy;\n\n  if (lengthSq === 0) {\n    return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);\n  }\n\n  let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;\n  t = Math.max(0, Math.min(1, t));\n\n  const nearX = x1 + t * dx;\n  const nearY = y1 + t * dy;\n\n  return Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2);\n};\n\n// Get the conceptual boundary lines for the panel (where edges would be without joints)\nconst getConceptualBoundary = (\n  panelWidth: number,\n  panelHeight: number\n): Record<EdgePosition, { start: PathPoint; end: PathPoint }> => {\n  const halfW = panelWidth / 2;\n  const halfH = panelHeight / 2;\n\n  return {\n    top: { start: { x: -halfW, y: halfH }, end: { x: halfW, y: halfH } },\n    bottom: { start: { x: -halfW, y: -halfH }, end: { x: halfW, y: -halfH } },\n    left: { start: { x: -halfW, y: -halfH }, end: { x: -halfW, y: halfH } },\n    right: { start: { x: halfW, y: -halfH }, end: { x: halfW, y: halfH } },\n  };\n};\n\n// Identify joint segments (perpendicular to edges, connecting fingers)\nconst getJointSegments = (\n  points: PathPoint[],\n  panelWidth: number,\n  panelHeight: number,\n  tolerance: number = 1\n): { start: PathPoint; end: PathPoint; nearEdge: EdgePosition }[] => {\n  const joints: { start: PathPoint; end: PathPoint; nearEdge: EdgePosition }[] = [];\n  const halfW = panelWidth / 2;\n  const halfH = panelHeight / 2;\n\n  for (let i = 0; i < points.length; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % points.length];\n\n    // Skip if this is an edge segment\n    const edge = classifySegment(p1, p2, panelWidth, panelHeight, tolerance);\n    if (edge) continue;\n\n    // This is a joint segment - determine which edge it's near\n    const avgX = (p1.x + p2.x) / 2;\n    const avgY = (p1.y + p2.y) / 2;\n\n    let nearEdge: EdgePosition = 'top';\n    if (Math.abs(avgY - halfH) < tolerance * 2) nearEdge = 'top';\n    else if (Math.abs(avgY + halfH) < tolerance * 2) nearEdge = 'bottom';\n    else if (Math.abs(avgX + halfW) < tolerance * 2) nearEdge = 'left';\n    else if (Math.abs(avgX - halfW) < tolerance * 2) nearEdge = 'right';\n\n    joints.push({ start: p1, end: p2, nearEdge });\n  }\n\n  return joints;\n};\n\n// Grid pattern component\nconst GridPattern: React.FC<{ gridSize: number; id: string }> = ({ gridSize, id }) => (\n  <defs>\n    <pattern\n      id={id}\n      width={gridSize}\n      height={gridSize}\n      patternUnits=\"userSpaceOnUse\"\n    >\n      <path\n        d={`M ${gridSize} 0 L 0 0 0 ${gridSize}`}\n        fill=\"none\"\n        stroke=\"#2a2a3e\"\n        strokeWidth=\"0.5\"\n      />\n    </pattern>\n    <pattern\n      id={`${id}-major`}\n      width={gridSize * 10}\n      height={gridSize * 10}\n      patternUnits=\"userSpaceOnUse\"\n    >\n      <rect width={gridSize * 10} height={gridSize * 10} fill={`url(#${id})`} />\n      <path\n        d={`M ${gridSize * 10} 0 L 0 0 0 ${gridSize * 10}`}\n        fill=\"none\"\n        stroke=\"#3a3a4e\"\n        strokeWidth=\"1\"\n      />\n    </pattern>\n  </defs>\n);\n\n// Calculate which faces a divider meets (has finger joints with)\nconst getDividerMeetsFaces = (\n  axis: 'x' | 'y' | 'z',\n  bounds: { x: number; y: number; z: number; w: number; h: number; d: number },\n  containerDims: { width: number; height: number; depth: number },\n  faces: Face[]\n): { meetsTop: boolean; meetsBottom: boolean; meetsLeft: boolean; meetsRight: boolean } => {\n  const isFaceSolid = (faceId: FaceId) => faces.find((f) => f.id === faceId)?.solid ?? false;\n  const tolerance = 0.01;\n\n  let meetsTop = false;\n  let meetsBottom = false;\n  let meetsLeft = false;\n  let meetsRight = false;\n\n  switch (axis) {\n    case 'x':\n      meetsTop = isFaceSolid('top') && bounds.y + bounds.h >= containerDims.height - tolerance;\n      meetsBottom = isFaceSolid('bottom') && bounds.y <= tolerance;\n      meetsLeft = isFaceSolid('back') && bounds.z <= tolerance;\n      meetsRight = isFaceSolid('front') && bounds.z + bounds.d >= containerDims.depth - tolerance;\n      break;\n    case 'y':\n      meetsTop = isFaceSolid('back') && bounds.z <= tolerance;\n      meetsBottom = isFaceSolid('front') && bounds.z + bounds.d >= containerDims.depth - tolerance;\n      meetsLeft = isFaceSolid('left') && bounds.x <= tolerance;\n      meetsRight = isFaceSolid('right') && bounds.x + bounds.w >= containerDims.width - tolerance;\n      break;\n    case 'z':\n      meetsTop = isFaceSolid('top') && bounds.y + bounds.h >= containerDims.height - tolerance;\n      meetsBottom = isFaceSolid('bottom') && bounds.y <= tolerance;\n      meetsLeft = isFaceSolid('left') && bounds.x <= tolerance;\n      meetsRight = isFaceSolid('right') && bounds.x + bounds.w >= containerDims.width - tolerance;\n      break;\n  }\n\n  return { meetsTop, meetsBottom, meetsLeft, meetsRight };\n};\n\nexport const SketchView2D: React.FC<SketchView2DProps> = ({ className }) => {\n  const {\n    sketchPanelId,\n    panelCollection,\n    exitSketchView,\n    config,\n    faces,\n    rootVoid,\n    setEdgeExtension,\n  } = useBoxStore();\n\n  // Pan and zoom state\n  const [viewBox, setViewBox] = useState({ x: 0, y: 0, width: 200, height: 200 });\n  const [isPanning, setIsPanning] = useState(false);\n  const [panStart, setPanStart] = useState({ x: 0, y: 0 });\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  // Edge interaction state\n  const [hoveredEdge, setHoveredEdge] = useState<EdgePosition | null>(null);\n  const [isDraggingEdge, setIsDraggingEdge] = useState(false);\n  const [dragEdge, setDragEdge] = useState<EdgePosition | null>(null);\n  const [dragStartPos, setDragStartPos] = useState<number>(0);\n  const [dragStartExtension, setDragStartExtension] = useState<number>(0);\n\n  // Get the panel being edited\n  const panel = useMemo(() => {\n    if (!panelCollection || !sketchPanelId) return null;\n    return panelCollection.panels.find(p => p.id === sketchPanelId) ?? null;\n  }, [panelCollection, sketchPanelId]);\n\n  // Get edge statuses for this panel\n  const edgeStatuses = useMemo((): EdgeStatusInfo[] => {\n    if (!panel) return [];\n\n    if (panel.source.type === 'face' && panel.source.faceId) {\n      return getFaceEdgeStatuses(panel.source.faceId, faces, config.assembly);\n    }\n\n    if (panel.source.type === 'divider' && panel.source.subdivisionId && panel.source.axis) {\n      // Find the subdivision to get its bounds\n      const subdivisions = getAllSubdivisions(rootVoid);\n      const subdivision = subdivisions.find(s => s.id === panel.source.subdivisionId);\n\n      if (subdivision) {\n        const containerDims = {\n          width: rootVoid.bounds.w,\n          height: rootVoid.bounds.h,\n          depth: rootVoid.bounds.d,\n        };\n\n        const { meetsTop, meetsBottom, meetsLeft, meetsRight } = getDividerMeetsFaces(\n          panel.source.axis,\n          subdivision.bounds,\n          containerDims,\n          faces\n        );\n\n        return getDividerEdgeStatuses(meetsTop, meetsBottom, meetsLeft, meetsRight);\n      }\n\n      // Fallback to all locked if subdivision not found\n      return getDividerEdgeStatuses(true, true, true, true);\n    }\n\n    return [];\n  }, [panel, faces, config.assembly, rootVoid]);\n\n  // Get edge segments for rendering\n  // IMPORTANT: Use original dimensions (without extensions) for edge classification\n  // because the outline points are generated from original dims + extensions at corners\n  const edgeSegments = useMemo(() => {\n    if (!panel) return null;\n    const ext = panel.edgeExtensions ?? { top: 0, bottom: 0, left: 0, right: 0 };\n    const originalWidth = panel.width - (ext.left ?? 0) - (ext.right ?? 0);\n    const originalHeight = panel.height - (ext.top ?? 0) - (ext.bottom ?? 0);\n    return getEdgeSegments(panel.outline.points, originalWidth, originalHeight);\n  }, [panel]);\n\n  // Get conceptual boundary (straight lines at ORIGINAL panel edges, before extensions)\n  const conceptualBoundary = useMemo(() => {\n    if (!panel) return null;\n    // Calculate original dimensions by subtracting extensions\n    const ext = panel.edgeExtensions ?? { top: 0, bottom: 0, left: 0, right: 0 };\n    const originalWidth = panel.width - (ext.left ?? 0) - (ext.right ?? 0);\n    const originalHeight = panel.height - (ext.top ?? 0) - (ext.bottom ?? 0);\n    return getConceptualBoundary(originalWidth, originalHeight);\n  }, [panel]);\n\n  // Get joint segments (perpendicular parts of finger joints)\n  // Use original dimensions like edgeSegments\n  const jointSegments = useMemo(() => {\n    if (!panel) return [];\n    const ext = panel.edgeExtensions ?? { top: 0, bottom: 0, left: 0, right: 0 };\n    const originalWidth = panel.width - (ext.left ?? 0) - (ext.right ?? 0);\n    const originalHeight = panel.height - (ext.top ?? 0) - (ext.bottom ?? 0);\n    return getJointSegments(panel.outline.points, originalWidth, originalHeight);\n  }, [panel]);\n\n  // Get editable areas (safe zones for cutouts)\n  const editableAreas = useMemo((): EditableArea[] => {\n    if (!panel) return [];\n    return getEditableAreas(panel, faces, config);\n  }, [panel, faces, config]);\n\n  // Detect corners for potential finishing\n  const detectedCorners = useMemo((): DetectedCorner[] => {\n    if (!panel) return [];\n    return detectMainCorners(panel.width, panel.height, config.materialThickness);\n  }, [panel, config.materialThickness]);\n\n  // Count edge types for display\n  const lockedCount = edgeStatuses.filter(e => e.status === 'locked').length;\n  const editableCount = edgeStatuses.filter(e => e.status !== 'locked').length;\n\n  // Check if an edge is editable (unlocked or outward-only)\n  const isEdgeEditable = useCallback((edge: EdgePosition): boolean => {\n    const status = edgeStatuses.find(e => e.position === edge);\n    return status?.status !== 'locked';\n  }, [edgeStatuses]);\n\n  // Convert screen coordinates to SVG coordinates\n  const screenToSvg = useCallback((clientX: number, clientY: number): { x: number; y: number } | null => {\n    const svg = svgRef.current;\n    if (!svg) return null;\n\n    const rect = svg.getBoundingClientRect();\n    // Note: Y is flipped in our rendering\n    const x = ((clientX - rect.left) / rect.width) * viewBox.width + viewBox.x;\n    const y = -(((clientY - rect.top) / rect.height) * viewBox.height + viewBox.y);\n\n    return { x, y };\n  }, [viewBox]);\n\n  // Find which edge (if any) is near a point\n  const findEdgeAtPoint = useCallback((svgX: number, svgY: number): EdgePosition | null => {\n    if (!edgeSegments || !panel) return null;\n\n    const hitDistance = Math.max(3, viewBox.width / 50); // Scale hit area with zoom\n\n    for (const edge of ['top', 'bottom', 'left', 'right'] as EdgePosition[]) {\n      const segments = edgeSegments[edge];\n      for (const seg of segments) {\n        const dist = distanceToSegment(svgX, svgY, seg.start.x, seg.start.y, seg.end.x, seg.end.y);\n        if (dist < hitDistance) {\n          return edge;\n        }\n      }\n    }\n\n    return null;\n  }, [edgeSegments, panel, viewBox.width]);\n\n  // Initialize viewBox based on panel dimensions\n  useEffect(() => {\n    if (panel) {\n      const padding = 20;\n      const width = panel.width + padding * 2;\n      const height = panel.height + padding * 2;\n      setViewBox({\n        x: -panel.width / 2 - padding,\n        y: -panel.height / 2 - padding,\n        width,\n        height,\n      });\n    }\n  }, [panel?.id]);\n\n  // Handle mouse wheel for zoom\n  const handleWheel = useCallback((e: React.WheelEvent) => {\n    e.preventDefault();\n    const scaleFactor = e.deltaY > 0 ? 1.1 : 0.9;\n\n    const svg = svgRef.current;\n    if (!svg) return;\n\n    const rect = svg.getBoundingClientRect();\n    const mouseX = ((e.clientX - rect.left) / rect.width) * viewBox.width + viewBox.x;\n    const mouseY = ((e.clientY - rect.top) / rect.height) * viewBox.height + viewBox.y;\n\n    const newWidth = viewBox.width * scaleFactor;\n    const newHeight = viewBox.height * scaleFactor;\n    const newX = mouseX - (mouseX - viewBox.x) * scaleFactor;\n    const newY = mouseY - (mouseY - viewBox.y) * scaleFactor;\n\n    setViewBox({ x: newX, y: newY, width: newWidth, height: newHeight });\n  }, [viewBox]);\n\n  // Handle mouse down\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    if (e.button !== 0) return;\n\n    const svgPos = screenToSvg(e.clientX, e.clientY);\n    if (!svgPos) return;\n\n    const edge = findEdgeAtPoint(svgPos.x, svgPos.y);\n\n    if (edge && isEdgeEditable(edge) && panel) {\n      // Start dragging edge\n      setIsDraggingEdge(true);\n      setDragEdge(edge);\n      const currentExtension = panel.edgeExtensions?.[edge] ?? 0;\n      setDragStartExtension(currentExtension);\n      // Store the relevant coordinate for drag calculation\n      if (edge === 'top' || edge === 'bottom') {\n        setDragStartPos(svgPos.y);\n      } else {\n        setDragStartPos(svgPos.x);\n      }\n    } else {\n      // Start panning\n      setIsPanning(true);\n      setPanStart({ x: e.clientX, y: e.clientY });\n    }\n  }, [screenToSvg, findEdgeAtPoint, isEdgeEditable, panel]);\n\n  // Handle mouse move\n  const handleMouseMove = useCallback((e: React.MouseEvent) => {\n    const svgPos = screenToSvg(e.clientX, e.clientY);\n\n    if (isDraggingEdge && dragEdge && svgPos && panel) {\n      // Calculate drag delta\n      let delta: number;\n      if (dragEdge === 'top') {\n        delta = svgPos.y - dragStartPos;\n      } else if (dragEdge === 'bottom') {\n        delta = -(svgPos.y - dragStartPos);\n      } else if (dragEdge === 'right') {\n        delta = svgPos.x - dragStartPos;\n      } else {\n        delta = -(svgPos.x - dragStartPos);\n      }\n\n      // Calculate new extension value\n      const newExtension = dragStartExtension + delta;\n      // Clamp to reasonable range\n      const clampedExtension = Math.max(-config.materialThickness, Math.min(20, newExtension));\n\n      setEdgeExtension(panel.id, dragEdge, clampedExtension);\n    } else if (isPanning) {\n      const svg = svgRef.current;\n      if (!svg) return;\n\n      const rect = svg.getBoundingClientRect();\n      const dx = ((e.clientX - panStart.x) / rect.width) * viewBox.width;\n      const dy = ((e.clientY - panStart.y) / rect.height) * viewBox.height;\n\n      setViewBox(prev => ({\n        ...prev,\n        x: prev.x - dx,\n        y: prev.y - dy,\n      }));\n      setPanStart({ x: e.clientX, y: e.clientY });\n    } else if (svgPos) {\n      // Update hovered edge\n      const edge = findEdgeAtPoint(svgPos.x, svgPos.y);\n      setHoveredEdge(edge);\n    }\n  }, [isDraggingEdge, dragEdge, dragStartPos, dragStartExtension, isPanning, panStart, viewBox, screenToSvg, findEdgeAtPoint, panel, setEdgeExtension, config.materialThickness]);\n\n  // Handle mouse up\n  const handleMouseUp = useCallback(() => {\n    setIsPanning(false);\n    setIsDraggingEdge(false);\n    setDragEdge(null);\n  }, []);\n\n  // Handle keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        exitSketchView();\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [exitSketchView]);\n\n  // Fit view to panel\n  const handleFitView = useCallback(() => {\n    if (panel) {\n      const padding = 20;\n      setViewBox({\n        x: -panel.width / 2 - padding,\n        y: -panel.height / 2 - padding,\n        width: panel.width + padding * 2,\n        height: panel.height + padding * 2,\n      });\n    }\n  }, [panel]);\n\n  if (!panel) {\n    return (\n      <div className={`sketch-view-2d ${className || ''}`}>\n        <div className=\"sketch-empty\">\n          <p>No panel selected for editing</p>\n          <button onClick={exitSketchView}>Return to 3D View</button>\n        </div>\n      </div>\n    );\n  }\n\n  const gridSize = 10;\n  const strokeScale = Math.min(viewBox.width, viewBox.height) / 200;\n  const outlineStrokeWidth = Math.max(0.3, Math.min(1, strokeScale));\n  const holeStrokeWidth = Math.max(0.2, Math.min(0.5, strokeScale * 0.5));\n  const edgeHighlightWidth = Math.max(2, Math.min(5, strokeScale * 3));\n\n  // Get color for an edge based on status and hover state\n  const getEdgeColor = (edge: EdgePosition): string => {\n    const status = edgeStatuses.find(e => e.position === edge);\n    const isLocked = status?.status === 'locked';\n    const isHovered = hoveredEdge === edge;\n    const isDragging = dragEdge === edge;\n\n    if (isLocked) {\n      return isHovered ? '#6ab0f9' : '#4a90d9'; // Blue for locked\n    } else {\n      if (isDragging) return '#ffb060'; // Bright orange when dragging\n      if (isHovered) return '#f0a050'; // Light orange when hovered\n      return '#e09040'; // Orange for editable\n    }\n  };\n\n  // Determine cursor based on hovered edge\n  const getCursor = (): string => {\n    if (isDraggingEdge) {\n      if (dragEdge === 'top' || dragEdge === 'bottom') return 'ns-resize';\n      return 'ew-resize';\n    }\n    if (hoveredEdge && isEdgeEditable(hoveredEdge)) {\n      if (hoveredEdge === 'top' || hoveredEdge === 'bottom') return 'ns-resize';\n      return 'ew-resize';\n    }\n    if (isPanning) return 'grabbing';\n    return 'grab';\n  };\n\n  return (\n    <div className={`sketch-view-2d ${className || ''}`}>\n      {/* Toolbar */}\n      <div className=\"sketch-toolbar\">\n        <div className=\"sketch-toolbar-left\">\n          <span className=\"sketch-panel-name\">{panel.label || panel.id}</span>\n          <span className=\"sketch-panel-dims\">\n            {panel.width.toFixed(1)} x {panel.height.toFixed(1)} mm\n          </span>\n        </div>\n        <div className=\"sketch-toolbar-right\">\n          <button className=\"sketch-btn\" onClick={handleFitView} title=\"Fit to view\">\n            Fit\n          </button>\n          <button className=\"sketch-btn sketch-btn-close\" onClick={exitSketchView} title=\"Return to 3D (Esc)\">\n            Close\n          </button>\n        </div>\n      </div>\n\n      {/* Editor Tools */}\n      <EditorToolbar mode=\"2d\" />\n\n      {/* SVG Canvas */}\n      <svg\n        ref={svgRef}\n        className=\"sketch-canvas\"\n        viewBox={`${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`}\n        onWheel={handleWheel}\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseUp}\n        style={{ cursor: getCursor() }}\n      >\n        {/* Grid pattern */}\n        <GridPattern gridSize={gridSize} id=\"sketch-grid\" />\n        <rect\n          x={viewBox.x - viewBox.width}\n          y={viewBox.y - viewBox.height}\n          width={viewBox.width * 3}\n          height={viewBox.height * 3}\n          fill=\"url(#sketch-grid-major)\"\n        />\n\n        {/* Coordinate axes */}\n        <line\n          x1={viewBox.x - viewBox.width}\n          y1={0}\n          x2={viewBox.x + viewBox.width * 2}\n          y2={0}\n          stroke=\"#4a4a6a\"\n          strokeWidth=\"0.5\"\n          strokeDasharray=\"4 4\"\n        />\n        <line\n          x1={0}\n          y1={viewBox.y - viewBox.height}\n          x2={0}\n          y2={viewBox.y + viewBox.height * 2}\n          stroke=\"#4a4a6a\"\n          strokeWidth=\"0.5\"\n          strokeDasharray=\"4 4\"\n        />\n\n        {/* Y-axis is flipped in SVG, so we apply a transform */}\n        <g transform=\"scale(1, -1)\">\n          {/* Editable areas (safe zones for cutouts) */}\n          {editableAreas.map((area, i) => (\n            <rect\n              key={`editable-${i}`}\n              x={area.x}\n              y={area.y}\n              width={area.width}\n              height={area.height}\n              fill=\"#2ecc71\"\n              fillOpacity={0.08}\n              stroke=\"#2ecc71\"\n              strokeWidth={outlineStrokeWidth * 0.5}\n              strokeDasharray={`${4 * strokeScale} ${2 * strokeScale}`}\n              opacity={0.4}\n            />\n          ))}\n\n          {/* Conceptual boundary lines (dashed, showing ideal panel edges) */}\n          {conceptualBoundary && (['top', 'bottom', 'left', 'right'] as EdgePosition[]).map(edge => {\n            const boundary = conceptualBoundary[edge];\n            const status = edgeStatuses.find(e => e.position === edge);\n            // Edges with joints: locked (male/tabs) or outward-only (female/slots)\n            const hasJoints = status?.status === 'locked' || status?.status === 'outward-only';\n\n            // Only show conceptual boundary if this edge has joints (difference from actual)\n            if (!hasJoints) return null;\n\n            return (\n              <line\n                key={`boundary-${edge}`}\n                x1={boundary.start.x}\n                y1={boundary.start.y}\n                x2={boundary.end.x}\n                y2={boundary.end.y}\n                stroke=\"#6a6a8a\"\n                strokeWidth={outlineStrokeWidth * 0.5}\n                strokeDasharray={`${3 * strokeScale} ${2 * strokeScale}`}\n                opacity={0.6}\n              />\n            );\n          })}\n\n          {/* Edge highlights (rendered under outline) */}\n          {edgeSegments && (['top', 'bottom', 'left', 'right'] as EdgePosition[]).map(edge => {\n            const segments = edgeSegments[edge];\n            const isHovered = hoveredEdge === edge || dragEdge === edge;\n            if (!isHovered || segments.length === 0) return null;\n\n            return (\n              <g key={`highlight-${edge}`}>\n                {segments.map((seg, i) => (\n                  <line\n                    key={i}\n                    x1={seg.start.x}\n                    y1={seg.start.y}\n                    x2={seg.end.x}\n                    y2={seg.end.y}\n                    stroke={getEdgeColor(edge)}\n                    strokeWidth={edgeHighlightWidth}\n                    strokeLinecap=\"round\"\n                    opacity={0.5}\n                  />\n                ))}\n              </g>\n            );\n          })}\n\n          {/* Panel outline with colored edges */}\n          {edgeSegments && (['top', 'bottom', 'left', 'right'] as EdgePosition[]).map(edge => {\n            const segments = edgeSegments[edge];\n            return (\n              <g key={`edge-${edge}`}>\n                {segments.map((seg, i) => (\n                  <line\n                    key={i}\n                    x1={seg.start.x}\n                    y1={seg.start.y}\n                    x2={seg.end.x}\n                    y2={seg.end.y}\n                    stroke={getEdgeColor(edge)}\n                    strokeWidth={outlineStrokeWidth}\n                    strokeLinecap=\"round\"\n                  />\n                ))}\n              </g>\n            );\n          })}\n\n          {/* Joint line segments (perpendicular parts connecting fingers) */}\n          {jointSegments.map((joint, i) => {\n            const edgeColor = getEdgeColor(joint.nearEdge);\n            return (\n              <line\n                key={`joint-${i}`}\n                x1={joint.start.x}\n                y1={joint.start.y}\n                x2={joint.end.x}\n                y2={joint.end.y}\n                stroke={edgeColor}\n                strokeWidth={outlineStrokeWidth}\n                strokeLinecap=\"round\"\n                opacity={0.8}\n              />\n            );\n          })}\n\n          {/* Holes */}\n          {panel.holes.map((hole) => (\n            <path\n              key={hole.id}\n              d={pathToSvgD(hole.path.points, hole.path.closed)}\n              fill=\"#1a1a2e\"\n              stroke=\"#666\"\n              strokeWidth={holeStrokeWidth}\n            />\n          ))}\n\n          {/* Corner indicators */}\n          {detectedCorners.filter(c => c.eligible).map((corner) => (\n            <g key={corner.id}>\n              <circle\n                cx={corner.position.x}\n                cy={corner.position.y}\n                r={Math.max(2, strokeScale * 3)}\n                fill=\"#9b59b6\"\n                fillOpacity={0.3}\n                stroke=\"#9b59b6\"\n                strokeWidth={outlineStrokeWidth * 0.5}\n              />\n            </g>\n          ))}\n        </g>\n\n        {/* Dimension labels */}\n        <text\n          x={0}\n          y={-panel.height / 2 - 8}\n          textAnchor=\"middle\"\n          fill=\"#888\"\n          fontSize=\"10\"\n          fontFamily=\"monospace\"\n        >\n          {panel.width.toFixed(1)}\n        </text>\n        <text\n          x={panel.width / 2 + 8}\n          y={0}\n          textAnchor=\"start\"\n          fill=\"#888\"\n          fontSize=\"10\"\n          fontFamily=\"monospace\"\n          transform={`rotate(-90, ${panel.width / 2 + 8}, 0)`}\n        >\n          {panel.height.toFixed(1)}\n        </text>\n      </svg>\n\n      {/* Legend */}\n      <div className=\"sketch-legend\">\n        <div className=\"legend-item\">\n          <span className=\"legend-color\" style={{ background: '#4a90d9' }}></span>\n          <span>Locked edge (has joints)</span>\n        </div>\n        <div className=\"legend-item\">\n          <span className=\"legend-color\" style={{ background: '#e09040' }}></span>\n          <span>Editable edge (drag to move)</span>\n        </div>\n        <div className=\"legend-item\">\n          <span className=\"legend-line\" style={{ borderTop: '1px dashed #6a6a8a' }}></span>\n          <span>Conceptual boundary</span>\n        </div>\n        <div className=\"legend-item\">\n          <span className=\"legend-color\" style={{ background: '#2ecc71', opacity: 0.5 }}></span>\n          <span>Safe zone (for cutouts)</span>\n        </div>\n        <div className=\"legend-item\">\n          <span className=\"legend-color\" style={{ background: '#9b59b6', borderRadius: '50%' }}></span>\n          <span>Corner (chamfer/fillet)</span>\n        </div>\n        <div className=\"legend-info\">\n          {lockedCount} locked, {editableCount} editable\n        </div>\n        {hoveredEdge && (\n          <div className=\"legend-info\">\n            {hoveredEdge}: {isEdgeEditable(hoveredEdge) ? 'drag to extend' : 'locked'}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n","import React, { useState, useEffect, useRef } from 'react';\n\ninterface NumberInputProps {\n  value: number;\n  onChange: (value: number) => void;\n  min?: number;\n  max?: number;\n  step?: number;\n  className?: string;\n}\n\n/**\n * A number input that:\n * - Allows free-form text editing (can delete and retype)\n * - Updates the store live when the value is valid\n * - Only shows valid values in the preview\n */\nexport const NumberInput: React.FC<NumberInputProps> = ({\n  value,\n  onChange,\n  min,\n  max,\n  step,\n  className,\n}) => {\n  const [localValue, setLocalValue] = useState(String(value));\n  const [isFocused, setIsFocused] = useState(false);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  // Update local value when external value changes (but not while focused)\n  useEffect(() => {\n    if (!isFocused) {\n      setLocalValue(String(value));\n    }\n  }, [value, isFocused]);\n\n  const handleFocus = () => {\n    setIsFocused(true);\n    // Select all text on focus for easy replacement\n    setTimeout(() => inputRef.current?.select(), 0);\n  };\n\n  const handleBlur = () => {\n    setIsFocused(false);\n    // On blur, sync local value with the current store value\n    setLocalValue(String(value));\n  };\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    setLocalValue(inputValue);\n\n    // Try to parse and validate\n    const parsed = parseFloat(inputValue);\n\n    // Only update store if it's a valid number within bounds\n    if (!isNaN(parsed)) {\n      let validValue = parsed;\n      if (min !== undefined && parsed < min) validValue = min;\n      if (max !== undefined && parsed > max) validValue = max;\n\n      // Only call onChange if the clamped value is what the user typed\n      // (or if they typed something out of bounds, use the clamped value)\n      if (parsed === validValue || parsed < (min ?? -Infinity) || parsed > (max ?? Infinity)) {\n        onChange(validValue);\n      }\n    }\n    // If invalid (empty, partial like \"1.\", etc), just keep local state - don't update store\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      inputRef.current?.blur();\n    }\n    if (e.key === 'Escape') {\n      setLocalValue(String(value));\n      inputRef.current?.blur();\n    }\n  };\n\n  return (\n    <input\n      ref={inputRef}\n      type=\"number\"\n      value={localValue}\n      onChange={handleChange}\n      onFocus={handleFocus}\n      onBlur={handleBlur}\n      onKeyDown={handleKeyDown}\n      min={min}\n      max={max}\n      step={step}\n      className={className}\n    />\n  );\n};\n","import React, { useMemo, useCallback, useState, useEffect } from 'react';\nimport { useBoxStore, getAllSubdivisions, calculatePreviewPositions, getMainInteriorVoid } from '../store/useBoxStore';\nimport { Panel } from './UI/Panel';\nimport { NumberInput } from './UI/NumberInput';\nimport { Void, Face, AssemblyAxis, FaceId, FaceOffsets, defaultFaceOffsets, Bounds, PanelPath } from '../types';\n\n// Get the normal axis for a face (the axis perpendicular to the face plane)\nconst getFaceNormalAxis = (faceId: FaceId): 'x' | 'y' | 'z' => {\n  switch (faceId) {\n    case 'left':\n    case 'right':\n      return 'x';  // Left/right faces are in YZ plane, normal is X\n    case 'top':\n    case 'bottom':\n      return 'y';  // Top/bottom faces are in XZ plane, normal is Y\n    case 'front':\n    case 'back':\n      return 'z';  // Front/back faces are in XY plane, normal is Z\n  }\n};\n\n// Get the normal axis for any panel (face or divider)\nconst getPanelNormalAxis = (panel: PanelPath): 'x' | 'y' | 'z' | null => {\n  if (panel.source.type === 'face' && panel.source.faceId) {\n    return getFaceNormalAxis(panel.source.faceId);\n  }\n  if (panel.source.type === 'divider' && panel.source.axis) {\n    // Divider's axis IS its normal axis (e.g., axis 'x' means it's a YZ plane, normal to X)\n    return panel.source.axis;\n  }\n  return null;\n};\n\n// Get the axes perpendicular to a normal axis (valid for subdivision)\nconst getPerpendicularAxes = (normalAxis: 'x' | 'y' | 'z'): ('x' | 'y' | 'z')[] => {\n  switch (normalAxis) {\n    case 'x': return ['y', 'z'];\n    case 'y': return ['x', 'z'];\n    case 'z': return ['x', 'y'];\n  }\n};\n\n// Get panel description for display\nconst getPanelDescription = (panel: PanelPath): string => {\n  if (panel.source.type === 'face' && panel.source.faceId) {\n    const labels: Record<FaceId, string> = {\n      front: 'Front', back: 'Back', left: 'Left',\n      right: 'Right', top: 'Top', bottom: 'Bottom',\n    };\n    return labels[panel.source.faceId];\n  }\n  if (panel.source.type === 'divider') {\n    return 'Divider';\n  }\n  return 'Panel';\n};\n\n// Extract void ID from subdivision ID (removes '-split' suffix)\nconst getVoidIdFromSubdivisionId = (subdivisionId: string): string => {\n  return subdivisionId.replace('-split', '');\n};\n\n// Find the parent void of a child void by the child's ID\nconst findParentVoid = (root: Void, childVoidId: string): Void | null => {\n  for (const child of root.children) {\n    if (child.id === childVoidId) {\n      return root;\n    }\n  }\n  for (const child of root.children) {\n    const found = findParentVoid(child, childVoidId);\n    if (found) return found;\n  }\n  if (root.subAssembly) {\n    const found = findParentVoid(root.subAssembly.rootVoid, childVoidId);\n    if (found) return found;\n  }\n  return null;\n};\n\n// Find a leaf void between two parallel panels\n// TODO: Future enhancement - allow non-adjacent parallel panels to create \"spanning\" dividers\n// that cross multiple voids. This would be useful for creating crossed/grid structures where\n// a divider needs to span several existing voids. Would require:\n// 1. Detecting all voids between the two selected panels\n// 2. Creating a single divider panel that spans all those voids\n// 3. Updating each void with appropriate subdivision info\n// 4. Generating proper finger joints where the spanning divider crosses existing dividers\nconst findVoidBetweenPanels = (\n  panel1: PanelPath,\n  panel2: PanelPath,\n  rootVoid: Void\n): Void | null => {\n  // Case 1: Both are face panels (opposite faces)\n  if (panel1.source.type === 'face' && panel2.source.type === 'face') {\n    const mainVoid = getMainInteriorVoid(rootVoid);\n    if (mainVoid.children.length === 0 && !mainVoid.subAssembly) {\n      return mainVoid;\n    }\n    return null;\n  }\n\n  // Case 2: Both are dividers - find the void between them\n  if (panel1.source.type === 'divider' && panel2.source.type === 'divider') {\n    const subId1 = panel1.source.subdivisionId;\n    const subId2 = panel2.source.subdivisionId;\n    if (!subId1 || !subId2) return null;\n\n    // Extract void IDs from subdivision IDs\n    const voidId1 = getVoidIdFromSubdivisionId(subId1);\n    const voidId2 = getVoidIdFromSubdivisionId(subId2);\n\n    // Find their common parent\n    const parent1 = findParentVoid(rootVoid, voidId1);\n    const parent2 = findParentVoid(rootVoid, voidId2);\n\n    if (!parent1 || !parent2) return null;\n\n    // If same parent, look for a leaf void between the two subdivision positions\n    if (parent1.id === parent2.id) {\n      const childIds = parent1.children.map(c => c.id);\n      const idx1 = childIds.indexOf(voidId1);\n      const idx2 = childIds.indexOf(voidId2);\n\n      if (idx1 === -1 || idx2 === -1) return null;\n\n      const minIdx = Math.min(idx1, idx2);\n      const maxIdx = Math.max(idx1, idx2);\n\n      // If they're adjacent, there's exactly one void between them\n      // The divider at index i is between children[i-1] and children[i]\n      // So if we select dividers at indices i and j (i<j), the void between is children[i]\n      // But wait - children[i] has the split info for divider at position i\n      // Actually: child at idx has splitPosition = position of divider BEFORE it\n      // So if idx1=1, idx2=2: divider1 is between [0] and [1], divider2 is between [1] and [2]\n      // The void between them is children[minIdx] which is the lower-indexed child\n      if (maxIdx - minIdx === 1) {\n        const voidBetween = parent1.children[minIdx];\n        if (voidBetween && voidBetween.children.length === 0 && !voidBetween.subAssembly) {\n          return voidBetween;\n        }\n      }\n    }\n    return null;\n  }\n\n  // Case 3: One face, one divider - find void bounded by both\n  if ((panel1.source.type === 'face' && panel2.source.type === 'divider') ||\n      (panel1.source.type === 'divider' && panel2.source.type === 'face')) {\n    const facePanel = panel1.source.type === 'face' ? panel1 : panel2;\n    const dividerPanel = panel1.source.type === 'divider' ? panel1 : panel2;\n\n    const subId = dividerPanel.source.subdivisionId;\n    if (!subId) return null;\n\n    const faceId = facePanel.source.faceId;\n    const dividerAxis = dividerPanel.source.axis;\n\n    if (!faceId || !dividerAxis) return null;\n\n    // The face and divider must be on the same axis (both perpendicular to that axis)\n    // Face normals: left/right -> x, top/bottom -> y, front/back -> z\n    const faceAxis = (faceId === 'left' || faceId === 'right') ? 'x' :\n                     (faceId === 'top' || faceId === 'bottom') ? 'y' : 'z';\n\n    if (faceAxis !== dividerAxis) return null;\n\n    // For face + divider on the same axis, we need to find the void at the main interior level\n    // The face bounds the outer box, so the divider must be a direct child of main interior\n    const mainInterior = getMainInteriorVoid(rootVoid);\n\n    // The divider's void must be a direct child of main interior\n    const voidId = getVoidIdFromSubdivisionId(subId);\n    const childIds = mainInterior.children.map(c => c.id);\n    const dividerIdx = childIds.indexOf(voidId);\n\n    // If divider is not a direct child of main interior, reject\n    if (dividerIdx === -1) return null;\n\n    // Determine if the face is at the \"low\" or \"high\" end of the axis\n    const isLowFace = faceId === 'left' || faceId === 'bottom' || faceId === 'back';\n    const isHighFace = faceId === 'right' || faceId === 'top' || faceId === 'front';\n\n    // Validate that the divider is actually adjacent to the face\n    // The divider at index i is at the LOW boundary of children[i], so:\n    // - children[i] is the void to the HIGH side of that divider\n    // - children[i-1] is the void to the LOW side of that divider\n    //\n    // For high face (e.g., Right): we need the divider's HIGH-side void to touch the face\n    //   This means children[i] must be the last child, so dividerIdx must be last\n    // For low face (e.g., Left): we need the divider's LOW-side void to touch the face\n    //   This means children[i-1] must be the first child (children[0]), so dividerIdx must be 1\n    if (isHighFace && dividerIdx !== mainInterior.children.length - 1) return null;\n    if (isLowFace && dividerIdx !== 1) return null;\n\n    // After validation:\n    // - For high face: void between divider and face is children[dividerIdx] (the last child)\n    // - For low face: void between face and divider is children[dividerIdx - 1] = children[0]\n    const targetIdx = isLowFace ? dividerIdx - 1 : dividerIdx;\n\n    if (targetIdx < 0 || targetIdx >= mainInterior.children.length) return null;\n\n    const targetVoid = mainInterior.children[targetIdx];\n\n    if (targetVoid && targetVoid.children.length === 0 && !targetVoid.subAssembly) {\n      return targetVoid;\n    }\n    return null;\n  }\n\n  return null;\n};\n\ninterface TwoPanelSubdivisionInfo {\n  isValid: boolean;\n  panels: PanelPath[];\n  panelDescriptions: string[];\n  validAxes: ('x' | 'y' | 'z')[];\n  normalAxis: 'x' | 'y' | 'z';\n  targetVoid: Void | null;\n}\n\n// Analyze two selected panels for subdivision potential\nconst analyzeTwoPanelSelection = (\n  selectedPanelIds: Set<string>,\n  panelCollection: { panels: PanelPath[] } | null,\n  rootVoid: Void\n): TwoPanelSubdivisionInfo => {\n  const invalid: TwoPanelSubdivisionInfo = {\n    isValid: false,\n    panels: [],\n    panelDescriptions: [],\n    validAxes: [],\n    normalAxis: 'x',\n    targetVoid: null,\n  };\n\n  if (selectedPanelIds.size !== 2 || !panelCollection) {\n    return invalid;\n  }\n\n  const panelIds = Array.from(selectedPanelIds);\n  const panels = panelIds\n    .map(id => panelCollection.panels.find(p => p.id === id))\n    .filter((p): p is PanelPath => p !== undefined);\n\n  if (panels.length !== 2) {\n    return invalid;\n  }\n\n  // Get normal axes for both panels\n  const axis1 = getPanelNormalAxis(panels[0]);\n  const axis2 = getPanelNormalAxis(panels[1]);\n\n  // Both must have a valid normal axis and they must match (parallel panels)\n  if (!axis1 || !axis2 || axis1 !== axis2) {\n    return invalid;\n  }\n\n  // Must be from main assembly (not sub-assembly) for now\n  if (panels.some(p => p.source.subAssemblyId)) {\n    return invalid;\n  }\n\n  const normalAxis = axis1;\n  const validAxes = getPerpendicularAxes(normalAxis);\n\n  // Find the void between the two panels\n  const targetVoid = findVoidBetweenPanels(panels[0], panels[1], rootVoid);\n\n  if (!targetVoid) {\n    return invalid;\n  }\n\n  const panelDescriptions = panels.map(getPanelDescription);\n\n  return {\n    isValid: true,\n    panels,\n    panelDescriptions,\n    validAxes,\n    normalAxis,\n    targetVoid,\n  };\n};\n\n// Find a void by ID in the tree (including inside sub-assemblies)\nconst findVoid = (root: Void, id: string): Void | null => {\n  if (root.id === id) return root;\n  for (const child of root.children) {\n    const found = findVoid(child, id);\n    if (found) return found;\n  }\n  // Also search inside sub-assembly's void structure\n  if (root.subAssembly) {\n    const found = findVoid(root.subAssembly.rootVoid, id);\n    if (found) return found;\n  }\n  return null;\n};\n\n// Determine which axes are valid based on open faces\n// Subdivisions parallel to open faces should be disabled\nconst getValidAxes = (faces: Face[]): { x: boolean; y: boolean; z: boolean } => {\n  const isSolid = (id: string) => faces.find(f => f.id === id)?.solid ?? true;\n\n  // X subdivisions create YZ planes (parallel to left/right faces)\n  // Disable if left OR right is open\n  const xValid = isSolid('left') && isSolid('right');\n\n  // Y subdivisions create XZ planes (parallel to top/bottom faces)\n  // Disable if top OR bottom is open\n  const yValid = isSolid('top') && isSolid('bottom');\n\n  // Z subdivisions create XY planes (parallel to front/back faces)\n  // Disable if front OR back is open\n  const zValid = isSolid('front') && isSolid('back');\n\n  return { x: xValid, y: yValid, z: zValid };\n};\n\nexport const SubdivisionControls: React.FC = () => {\n  const {\n    selectedVoidIds,\n    selectedPanelIds,\n    panelCollection,\n    rootVoid,\n    faces,\n    config,\n    subdivisionPreview,\n    setSubdivisionPreview,\n    setSubAssemblyPreview,\n    applySubdivision,\n    removeVoid,\n    createSubAssembly,\n    removeSubAssembly,\n    selectSubAssembly,\n    purgeVoid,\n    selectVoid,\n  } = useBoxStore();\n\n  // Get the single selected void ID (this component only shows when exactly 1 is selected)\n  const selectedVoidId = selectedVoidIds.size === 1 ? Array.from(selectedVoidIds)[0] : null;\n\n  // Track whether user has clicked to enter edit mode (vs just hovering)\n  const [isEditingPreview, setIsEditingPreview] = useState(false);\n\n  // State for create assembly options\n  const [showCreateAssembly, setShowCreateAssembly] = useState(false);\n  const [createClearance, setCreateClearance] = useState(2);\n  const [createAxis, setCreateAxis] = useState<AssemblyAxis>('y');\n  const [createFaceOffsets, setCreateFaceOffsets] = useState<FaceOffsets>(defaultFaceOffsets);\n\n  // Reset edit mode and creation form when selection changes\n  useEffect(() => {\n    setIsEditingPreview(false);\n    setShowCreateAssembly(false);\n    setCreateClearance(2);\n    setCreateAxis('y');\n    setCreateFaceOffsets(defaultFaceOffsets);\n  }, [selectedVoidId]);\n\n  const selectedVoid = useMemo(() => {\n    if (!selectedVoidId) return null;\n    return findVoid(rootVoid, selectedVoidId);\n  }, [selectedVoidId, rootVoid]);\n\n  // Analyze two-panel selection for subdivision\n  const twoPanelInfo = useMemo(() =>\n    analyzeTwoPanelSelection(selectedPanelIds, panelCollection, rootVoid),\n    [selectedPanelIds, panelCollection, rootVoid]\n  );\n\n  const isLeafVoid = selectedVoid && selectedVoid.children.length === 0 && !selectedVoid.subAssembly;\n  const hasSubAssembly = selectedVoid?.subAssembly !== undefined;\n  const hasChildren = selectedVoid && selectedVoid.children.length > 0;\n\n  // Determine which parent faces are open (for face offset controls)\n  // An open face means the sub-assembly can potentially extend/retract in that direction\n  const openParentFaces = useMemo(() => {\n    const result: FaceId[] = [];\n    for (const face of faces) {\n      if (!face.solid) {\n        result.push(face.id);\n      }\n    }\n    return result;\n  }, [faces]);\n\n  const subdivisions = useMemo(() => getAllSubdivisions(rootVoid), [rootVoid]);\n\n  const validAxes = useMemo(() => getValidAxes(faces), [faces]);\n\n  // Update sub-assembly preview when form is shown or values change\n  useEffect(() => {\n    if (!showCreateAssembly || !selectedVoid || !selectedVoidId) {\n      setSubAssemblyPreview(null);\n      return;\n    }\n\n    const { bounds } = selectedVoid;\n    const mt = config.materialThickness;\n\n    // Calculate outer dimensions (same logic as createSubAssembly)\n    const outerWidth = bounds.w - (createClearance * 2) + createFaceOffsets.left + createFaceOffsets.right;\n    const outerHeight = bounds.h - (createClearance * 2) + createFaceOffsets.top + createFaceOffsets.bottom;\n    const outerDepth = bounds.d - (createClearance * 2) + createFaceOffsets.front + createFaceOffsets.back;\n\n    // Check if valid (interior must be positive)\n    const interiorWidth = outerWidth - (2 * mt);\n    const interiorHeight = outerHeight - (2 * mt);\n    const interiorDepth = outerDepth - (2 * mt);\n\n    if (interiorWidth <= 0 || interiorHeight <= 0 || interiorDepth <= 0) {\n      setSubAssemblyPreview(null);\n      return;\n    }\n\n    // Calculate the preview bounds (position within the void)\n    const previewBounds: Bounds = {\n      x: bounds.x + createClearance - createFaceOffsets.left,\n      y: bounds.y + createClearance - createFaceOffsets.bottom,\n      z: bounds.z + createClearance - createFaceOffsets.back,\n      w: outerWidth,\n      h: outerHeight,\n      d: outerDepth,\n    };\n\n    setSubAssemblyPreview({\n      voidId: selectedVoidId,\n      bounds: previewBounds,\n      clearance: createClearance,\n      assemblyAxis: createAxis,\n      faceOffsets: createFaceOffsets,\n    });\n  }, [showCreateAssembly, selectedVoid, selectedVoidId, createClearance, createAxis, createFaceOffsets, config.materialThickness, setSubAssemblyPreview]);\n\n  // Start editing a subdivision (user clicked an axis)\n  const startEditing = useCallback((axis: 'x' | 'y' | 'z') => {\n    if (!selectedVoidId || !selectedVoid) return;\n\n    const positions = calculatePreviewPositions(selectedVoid.bounds, axis, 1);\n    setSubdivisionPreview({\n      voidId: selectedVoidId,\n      axis,\n      count: 1,\n      positions,\n    });\n    setIsEditingPreview(true);\n  }, [selectedVoidId, selectedVoid, setSubdivisionPreview]);\n\n  // Update the count (number of divisions) in the current preview\n  const updatePreviewCount = useCallback((newCount: number) => {\n    if (!subdivisionPreview) return;\n\n    // Use selectedVoid or twoPanelInfo.targetVoid (for two-panel mode)\n    const targetVoid = selectedVoid || twoPanelInfo.targetVoid;\n    if (!targetVoid) return;\n\n    const count = Math.max(1, Math.min(20, newCount));\n    const positions = calculatePreviewPositions(targetVoid.bounds, subdivisionPreview.axis, count);\n    setSubdivisionPreview({\n      ...subdivisionPreview,\n      count,\n      positions,\n    });\n  }, [subdivisionPreview, selectedVoid, twoPanelInfo.targetVoid, setSubdivisionPreview]);\n\n  // Cancel the current preview\n  const cancelPreview = useCallback(() => {\n    setSubdivisionPreview(null);\n    setIsEditingPreview(false);\n  }, [setSubdivisionPreview]);\n\n  // Apply the current preview and create the subdivision\n  const confirmSubdivision = useCallback(() => {\n    applySubdivision();\n    setIsEditingPreview(false);\n  }, [applySubdivision]);\n\n  // Handle mouse enter on axis button (show hover preview only)\n  const handleAxisHover = useCallback((axis: 'x' | 'y' | 'z') => {\n    if (!selectedVoidId || !selectedVoid || !isLeafVoid) return;\n    if (isEditingPreview) return; // Don't override if in edit mode\n\n    const positions = calculatePreviewPositions(selectedVoid.bounds, axis, 1);\n    setSubdivisionPreview({\n      voidId: selectedVoidId,\n      axis,\n      count: 1,\n      positions,\n    });\n  }, [selectedVoidId, selectedVoid, isLeafVoid, isEditingPreview, setSubdivisionPreview]);\n\n  // Handle mouse leave (clear hover preview only if not in edit mode)\n  const handleAxisLeave = useCallback(() => {\n    if (isEditingPreview) return; // Don't clear if in edit mode\n    setSubdivisionPreview(null);\n  }, [isEditingPreview, setSubdivisionPreview]);\n\n  // Start editing from two-panel selection\n  const startTwoPanelSubdivision = useCallback((axis: 'x' | 'y' | 'z') => {\n    if (!twoPanelInfo.isValid || !twoPanelInfo.targetVoid) return;\n\n    const targetVoidId = twoPanelInfo.targetVoid.id;\n    const positions = calculatePreviewPositions(twoPanelInfo.targetVoid.bounds, axis, 1);\n\n    // Set up preview (don't select void - applySubdivision uses preview.voidId)\n    setSubdivisionPreview({\n      voidId: targetVoidId,\n      axis,\n      count: 1,\n      positions,\n    });\n    setIsEditingPreview(true);\n  }, [twoPanelInfo, setSubdivisionPreview]);\n\n  // Hover handler for two-panel mode\n  const handleTwoPanelAxisHover = useCallback((axis: 'x' | 'y' | 'z') => {\n    if (!twoPanelInfo.isValid || !twoPanelInfo.targetVoid || isEditingPreview) return;\n\n    const positions = calculatePreviewPositions(twoPanelInfo.targetVoid.bounds, axis, 1);\n    setSubdivisionPreview({\n      voidId: twoPanelInfo.targetVoid.id,\n      axis,\n      count: 1,\n      positions,\n    });\n  }, [twoPanelInfo, isEditingPreview, setSubdivisionPreview]);\n\n  // Leave handler for two-panel mode\n  const handleTwoPanelAxisLeave = useCallback(() => {\n    if (isEditingPreview) return;\n    setSubdivisionPreview(null);\n  }, [isEditingPreview, setSubdivisionPreview]);\n\n  const getAxisTooltip = (axis: 'x' | 'y' | 'z', isValid: boolean): string => {\n    if (isValid) {\n      switch (axis) {\n        case 'x': return 'Split with vertical divider (left-right)';\n        case 'y': return 'Split with horizontal shelf (top-bottom)';\n        case 'z': return 'Split with vertical divider (front-back)';\n      }\n    }\n    switch (axis) {\n      case 'x': return 'Disabled: left or right face is open';\n      case 'y': return 'Disabled: top or bottom face is open';\n      case 'z': return 'Disabled: front or back face is open';\n    }\n  };\n\n  const getAxisLabel = (axis: 'x' | 'y' | 'z'): string => {\n    switch (axis) {\n      case 'x': return 'X (Left-Right)';\n      case 'y': return 'Y (Top-Bottom)';\n      case 'z': return 'Z (Front-Back)';\n    }\n  };\n\n  const handleCreateAssembly = useCallback(() => {\n    if (!selectedVoidId) return;\n    createSubAssembly(selectedVoidId, {\n      clearance: createClearance,\n      assemblyAxis: createAxis,\n      faceOffsets: createFaceOffsets,\n    });\n    setShowCreateAssembly(false);\n  }, [selectedVoidId, createSubAssembly, createClearance, createAxis, createFaceOffsets]);\n\n  const handleFaceOffsetChange = useCallback((faceId: FaceId, value: number) => {\n    setCreateFaceOffsets(prev => ({ ...prev, [faceId]: value }));\n  }, []);\n\n  const handlePurgeVoid = useCallback(() => {\n    if (!selectedVoidId) return;\n    purgeVoid(selectedVoidId);\n  }, [selectedVoidId, purgeVoid]);\n\n  const getFaceLabel = (faceId: FaceId): string => {\n    const labels: Record<FaceId, string> = {\n      front: 'Front',\n      back: 'Back',\n      left: 'Left',\n      right: 'Right',\n      top: 'Top',\n      bottom: 'Bottom',\n    };\n    return labels[faceId];\n  };\n\n  // Get axis label for display\n  const getAxisDisplayLabel = (axis: 'x' | 'y' | 'z'): string => {\n    switch (axis) {\n      case 'x': return 'X (Left-Right)';\n      case 'y': return 'Y (Top-Bottom)';\n      case 'z': return 'Z (Front-Back)';\n    }\n  };\n\n  // Get panel pair description\n  const getPanelPairDescription = (descriptions: string[]): string => {\n    if (descriptions.length === 2) {\n      return `${descriptions[0]} & ${descriptions[1]}`;\n    }\n    return descriptions.join(' & ');\n  };\n\n  return (\n    <Panel title=\"Subdivisions\">\n      {/* Two-panel subdivision mode */}\n      {twoPanelInfo.isValid && !isEditingPreview && (\n        <div className=\"subdivision-controls\">\n          <div className=\"control-section\">\n            <h4>Subdivide Between Panels</h4>\n            <p className=\"hint\">\n              {getPanelPairDescription(twoPanelInfo.panelDescriptions)} selected\n            </p>\n            <div className=\"button-row\">\n              {twoPanelInfo.validAxes.map(axis => (\n                <button\n                  key={axis}\n                  onClick={() => startTwoPanelSubdivision(axis)}\n                  onMouseEnter={() => handleTwoPanelAxisHover(axis)}\n                  onMouseLeave={handleTwoPanelAxisLeave}\n                  title={`Split with divider along ${axis.toUpperCase()} axis`}\n                >\n                  {axis.toUpperCase()} Axis\n                </button>\n              ))}\n            </div>\n            <p className=\"axis-hint\">\n              Only axes perpendicular to selected panels are available\n            </p>\n          </div>\n          {twoPanelInfo.targetVoid && (\n            <div className=\"void-info\">\n              <p>\n                Target void: {twoPanelInfo.targetVoid.bounds.w.toFixed(1)} x {twoPanelInfo.targetVoid.bounds.h.toFixed(1)} x {twoPanelInfo.targetVoid.bounds.d.toFixed(1)} mm\n              </p>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Editing mode (after axis selected - works for both two-panel and single-void) */}\n      {isEditingPreview && subdivisionPreview && (\n        <div className=\"subdivision-controls\">\n          <div className=\"control-section\">\n            <h4>Configure {getAxisDisplayLabel(subdivisionPreview.axis)} subdivision</h4>\n\n            <div className=\"preview-config\">\n              <div className=\"count-control\">\n                <label>Number of divisions:</label>\n                <div className=\"count-buttons\">\n                  <button\n                    onClick={() => updatePreviewCount(subdivisionPreview.count - 1)}\n                    disabled={subdivisionPreview.count <= 1}\n                  >\n                    -\n                  </button>\n                  <NumberInput\n                    value={subdivisionPreview.count}\n                    onChange={(v) => updatePreviewCount(Math.round(v))}\n                    min={1}\n                    max={20}\n                  />\n                  <button\n                    onClick={() => updatePreviewCount(subdivisionPreview.count + 1)}\n                    disabled={subdivisionPreview.count >= 20}\n                  >\n                    +\n                  </button>\n                </div>\n              </div>\n\n              <p className=\"preview-info\">\n                This will create {subdivisionPreview.count + 1} cells\n              </p>\n\n              <div className=\"confirm-buttons\">\n                <button\n                  className=\"apply-btn\"\n                  onClick={confirmSubdivision}\n                >\n                  Apply\n                </button>\n                <button\n                  className=\"cancel-btn\"\n                  onClick={cancelPreview}\n                >\n                  Cancel\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Single void selection mode (original behavior) */}\n      {selectedVoidId && selectedVoid && !twoPanelInfo.isValid ? (\n        <div className=\"subdivision-controls\">\n          {hasSubAssembly ? (\n            // Void contains a sub-assembly\n            <div className=\"control-section\">\n              <div className=\"subassembly-info\">\n                <h4>Contains: Nested Box</h4>\n                <p className=\"hint\">\n                  Click the sub-assembly in the 3D view to edit it\n                </p>\n                <button\n                  className=\"select-subassembly-btn\"\n                  onClick={() => selectSubAssembly(selectedVoid.subAssembly!.id)}\n                >\n                  Select Nested Box\n                </button>\n                <button\n                  className=\"remove-subassembly-btn\"\n                  onClick={() => removeSubAssembly(selectedVoidId)}\n                >\n                  Remove Nested Box\n                </button>\n              </div>\n            </div>\n          ) : hasChildren ? (\n            // Void has subdivisions\n            <div className=\"control-section\">\n              <div className=\"hint\">\n                This void has been subdivided. Select a child cell to subdivide further.\n              </div>\n              <button\n                className=\"purge-btn\"\n                onClick={handlePurgeVoid}\n                title=\"Remove all subdivisions and nested content from this void\"\n              >\n                Purge Void\n              </button>\n            </div>\n          ) : isLeafVoid ? (\n            <>\n              {!isEditingPreview ? (\n                // Step 1: Select axis (hover to preview, click to select)\n                <>\n                  {!showCreateAssembly && (\n                    <div className=\"control-section\">\n                      <h4>Subdivide</h4>\n                      <div className=\"button-row\">\n                        <button\n                          onClick={() => startEditing('x')}\n                          onMouseEnter={() => handleAxisHover('x')}\n                          onMouseLeave={handleAxisLeave}\n                          disabled={!validAxes.x}\n                          title={getAxisTooltip('x', validAxes.x)}\n                        >\n                          X Axis\n                        </button>\n                        <button\n                          onClick={() => startEditing('y')}\n                          onMouseEnter={() => handleAxisHover('y')}\n                          onMouseLeave={handleAxisLeave}\n                          disabled={!validAxes.y}\n                          title={getAxisTooltip('y', validAxes.y)}\n                        >\n                          Y Axis\n                        </button>\n                        <button\n                          onClick={() => startEditing('z')}\n                          onMouseEnter={() => handleAxisHover('z')}\n                          onMouseLeave={handleAxisLeave}\n                          disabled={!validAxes.z}\n                          title={getAxisTooltip('z', validAxes.z)}\n                        >\n                          Z Axis\n                        </button>\n                      </div>\n                      {(!validAxes.x || !validAxes.y || !validAxes.z) && (\n                        <p className=\"axis-hint\">\n                          Some axes disabled due to open faces\n                        </p>\n                      )}\n                    </div>\n                  )}\n\n                  <div className=\"control-section\">\n                    <h4>Create Assembly</h4>\n                    {!showCreateAssembly ? (\n                      <div className=\"button-row\">\n                        <button\n                          onClick={() => setShowCreateAssembly(true)}\n                          title=\"Create a nested box that fits inside this void\"\n                        >\n                          Create Nested Box\n                        </button>\n                      </div>\n                    ) : (\n                      <div className=\"create-assembly-form\">\n                        <div className=\"form-row\">\n                          <label>Clearance (mm):</label>\n                          <NumberInput\n                            value={createClearance}\n                            onChange={(v) => setCreateClearance(v)}\n                            min={0}\n                            step={0.5}\n                          />\n                        </div>\n                        <div className=\"form-row\">\n                          <label>Assembly Axis:</label>\n                          <select\n                            value={createAxis}\n                            onChange={(e) => setCreateAxis(e.target.value as AssemblyAxis)}\n                          >\n                            <option value=\"y\">Y (Top/Bottom lids)</option>\n                            <option value=\"x\">X (Left/Right lids)</option>\n                            <option value=\"z\">Z (Front/Back lids)</option>\n                          </select>\n                        </div>\n                        {openParentFaces.length > 0 && (\n                          <div className=\"face-offsets-section\">\n                            <label className=\"section-label\">Face Offsets (mm):</label>\n                            <p className=\"offset-hint\">Adjust assembly position relative to open faces</p>\n                            {openParentFaces.map((faceId) => (\n                              <div key={faceId} className=\"form-row offset-row\">\n                                <label>{getFaceLabel(faceId)}:</label>\n                                <div className=\"offset-input-group\">\n                                  <button\n                                    onClick={() => handleFaceOffsetChange(faceId, createFaceOffsets[faceId] - 1)}\n                                    className=\"offset-btn\"\n                                  >\n                                    -\n                                  </button>\n                                  <NumberInput\n                                    value={createFaceOffsets[faceId]}\n                                    onChange={(v) => handleFaceOffsetChange(faceId, v)}\n                                    step={0.5}\n                                    className=\"offset-input\"\n                                  />\n                                  <button\n                                    onClick={() => handleFaceOffsetChange(faceId, createFaceOffsets[faceId] + 1)}\n                                    className=\"offset-btn\"\n                                  >\n                                    +\n                                  </button>\n                                </div>\n                              </div>\n                            ))}\n                          </div>\n                        )}\n                        <div className=\"confirm-buttons\">\n                          <button\n                            className=\"apply-btn\"\n                            onClick={handleCreateAssembly}\n                          >\n                            Create\n                          </button>\n                          <button\n                            className=\"cancel-btn\"\n                            onClick={() => setShowCreateAssembly(false)}\n                          >\n                            Cancel\n                          </button>\n                        </div>\n                      </div>\n                    )}\n                  </div>\n                </>\n              ) : null}\n              {/* Note: Editing UI (count adjustment) is now shown by the unified section above */}\n\n              <div className=\"void-info\">\n                <p>\n                  Size: {selectedVoid.bounds.w.toFixed(1)} x {selectedVoid.bounds.h.toFixed(1)} x {selectedVoid.bounds.d.toFixed(1)} mm\n                </p>\n              </div>\n            </>\n          ) : null}\n\n          {/* Show Remove Subdivision only for non-root voids that were created by subdivision */}\n          {selectedVoidId !== 'root' && selectedVoid.splitAxis && (\n            <div className=\"control-section\">\n              <button\n                className=\"remove-subdivision-btn\"\n                onClick={() => removeVoid(selectedVoidId)}\n                title=\"Remove this subdivision and merge back\"\n              >\n                Remove Subdivision\n              </button>\n            </div>\n          )}\n        </div>\n      ) : !twoPanelInfo.isValid && !isEditingPreview ? (\n        <p className=\"hint\">\n          {selectedPanelIds.size === 2\n            ? 'Selected panels must be opposite faces (e.g., Front & Back) to subdivide between them'\n            : selectedPanelIds.size === 1\n            ? 'Select another opposite panel (Shift+click) to subdivide between them, or select a void'\n            : 'Select a void or two opposite panels to subdivide'}\n        </p>\n      ) : null}\n\n      {subdivisions.length > 0 && (\n        <div className=\"control-section\">\n          <h4>Current subdivisions ({subdivisions.length})</h4>\n          <ul className=\"subdivision-list\">\n            {subdivisions.slice(0, 10).map((sub) => (\n              <li key={sub.id}>\n                <span>\n                  {sub.axis.toUpperCase()} @ {sub.position.toFixed(1)}mm\n                </span>\n              </li>\n            ))}\n            {subdivisions.length > 10 && (\n              <li className=\"more-indicator\">+{subdivisions.length - 10} more...</li>\n            )}\n          </ul>\n        </div>\n      )}\n    </Panel>\n  );\n};\n","import React, { useState, useMemo } from 'react';\nimport { useBoxStore, getAllSubdivisions, getAllSubAssemblies } from '../store/useBoxStore';\nimport { Panel } from './UI/Panel';\nimport { NumberInput } from './UI/NumberInput';\nimport { FaceId, Face, AssemblyConfig, SplitPositionMode } from '../types';\nimport {\n  getFaceEdgeStatuses,\n  getDividerEdgeStatuses,\n  EdgeStatusInfo,\n} from '../utils/panelGenerator';\n\ntype EdgePosition = 'top' | 'bottom' | 'left' | 'right';\n\ninterface EdgePreviewProps {\n  width: number;\n  height: number;\n  edgeStatuses: EdgeStatusInfo[];\n  selectedEdge: EdgePosition | null;\n  onEdgeClick: (edge: EdgePosition) => void;\n  edgeExtensions: { top: number; bottom: number; left: number; right: number };\n}\n\nconst EdgePreview: React.FC<EdgePreviewProps> = ({\n  width,\n  height,\n  edgeStatuses,\n  selectedEdge,\n  onEdgeClick,\n  edgeExtensions,\n}) => {\n  const padding = 15;\n  const strokeWidth = 6;\n\n  // Normalize dimensions for display (max 100 in either direction)\n  const scale = Math.min(80 / width, 80 / height);\n  const displayW = width * scale;\n  const displayH = height * scale;\n\n  const viewBoxWidth = displayW + padding * 2;\n  const viewBoxHeight = displayH + padding * 2;\n\n  const getEdgeStatus = (pos: EdgePosition): 'locked' | 'unlocked' => {\n    const edge = edgeStatuses.find((e) => e.position === pos);\n    return edge?.status ?? 'locked';\n  };\n\n  const getEdgeClass = (pos: EdgePosition): string => {\n    const status = getEdgeStatus(pos);\n    const isSelected = selectedEdge === pos;\n    const classes = [`edge-${status}`];\n    if (isSelected) classes.push('edge-selected');\n    if (status === 'unlocked') classes.push('edge-clickable');\n    return classes.join(' ');\n  };\n\n  // Apply extensions to corner positions\n  const ext = {\n    top: edgeExtensions.top * scale,\n    bottom: edgeExtensions.bottom * scale,\n    left: edgeExtensions.left * scale,\n    right: edgeExtensions.right * scale,\n  };\n\n  // Calculate corners with extensions\n  const topY = padding - ext.top;\n  const bottomY = padding + displayH + ext.bottom;\n  const leftX = padding - ext.left;\n  const rightX = padding + displayW + ext.right;\n\n  // Edge definitions\n  const edges = {\n    top: { x1: leftX, y1: topY, x2: rightX, y2: topY },\n    bottom: { x1: rightX, y1: bottomY, x2: leftX, y2: bottomY },\n    left: { x1: leftX, y1: bottomY, x2: leftX, y2: topY },\n    right: { x1: rightX, y1: topY, x2: rightX, y2: bottomY },\n  };\n\n  const handleEdgeClick = (pos: EdgePosition) => {\n    if (getEdgeStatus(pos) === 'unlocked') {\n      onEdgeClick(pos);\n    }\n  };\n\n  return (\n    <svg\n      className=\"edge-preview-svg\"\n      viewBox={`0 0 ${viewBoxWidth} ${viewBoxHeight}`}\n      preserveAspectRatio=\"xMidYMid meet\"\n    >\n      {/* Background fill */}\n      <rect\n        x={leftX}\n        y={topY}\n        width={rightX - leftX}\n        height={bottomY - topY}\n        fill=\"#252545\"\n        stroke=\"none\"\n      />\n\n      {/* Edges */}\n      {(['top', 'right', 'bottom', 'left'] as EdgePosition[]).map((pos) => (\n        <line\n          key={pos}\n          {...edges[pos]}\n          className={getEdgeClass(pos)}\n          strokeWidth={strokeWidth}\n          strokeLinecap=\"round\"\n          onClick={() => handleEdgeClick(pos)}\n          style={{ cursor: getEdgeStatus(pos) === 'unlocked' ? 'pointer' : 'default' }}\n        />\n      ))}\n\n      {/* Extension indicators */}\n      {edgeExtensions.top !== 0 && (\n        <text x={viewBoxWidth / 2} y={topY - 5} className=\"extension-label\" textAnchor=\"middle\">\n          {edgeExtensions.top > 0 ? '+' : ''}{edgeExtensions.top}\n        </text>\n      )}\n      {edgeExtensions.bottom !== 0 && (\n        <text x={viewBoxWidth / 2} y={bottomY + 12} className=\"extension-label\" textAnchor=\"middle\">\n          {edgeExtensions.bottom > 0 ? '+' : ''}{edgeExtensions.bottom}\n        </text>\n      )}\n      {edgeExtensions.left !== 0 && (\n        <text x={leftX - 5} y={viewBoxHeight / 2} className=\"extension-label\" textAnchor=\"end\" dominantBaseline=\"middle\">\n          {edgeExtensions.left > 0 ? '+' : ''}{edgeExtensions.left}\n        </text>\n      )}\n      {edgeExtensions.right !== 0 && (\n        <text x={rightX + 5} y={viewBoxHeight / 2} className=\"extension-label\" textAnchor=\"start\" dominantBaseline=\"middle\">\n          {edgeExtensions.right > 0 ? '+' : ''}{edgeExtensions.right}\n        </text>\n      )}\n    </svg>\n  );\n};\n\nconst EdgeLegend: React.FC = () => (\n  <div className=\"edge-legend\">\n    <div className=\"legend-item\">\n      <span className=\"legend-color locked\" />\n      <span>Locked (finger joints)</span>\n    </div>\n    <div className=\"legend-item\">\n      <span className=\"legend-color unlocked\" />\n      <span>Unlocked (extendable)</span>\n    </div>\n  </div>\n);\n\ninterface EdgeControlsProps {\n  edge: EdgePosition;\n  value: number;\n  status: 'locked' | 'unlocked';\n  onChange: (value: number) => void;\n}\n\nconst EdgeControls: React.FC<EdgeControlsProps> = ({ edge, value, status, onChange }) => {\n  const edgeNames: Record<EdgePosition, string> = {\n    top: 'Top',\n    bottom: 'Bottom',\n    left: 'Left',\n    right: 'Right',\n  };\n\n  if (status === 'locked') {\n    return (\n      <div className=\"edge-controls\">\n        <div className=\"edge-controls-header\">\n          <span className=\"edge-name\">{edgeNames[edge]} Edge</span>\n          <span className=\"edge-status-badge locked\">Locked</span>\n        </div>\n        <p className=\"edge-controls-hint\">\n          This edge has finger joints and cannot be extended in V1.\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"edge-controls\">\n      <div className=\"edge-controls-header\">\n        <span className=\"edge-name\">{edgeNames[edge]} Edge</span>\n        <span className=\"edge-status-badge unlocked\">Unlocked</span>\n      </div>\n      <div className=\"edge-controls-row\">\n        <button\n          className=\"edge-btn\"\n          onClick={() => onChange(value - 1)}\n          title=\"Extend inward (shrink)\"\n        >\n          -\n        </button>\n        <NumberInput\n          className=\"edge-input\"\n          value={value}\n          onChange={onChange}\n          step={1}\n        />\n        <button\n          className=\"edge-btn\"\n          onClick={() => onChange(value + 1)}\n          title=\"Extend outward (grow)\"\n        >\n          +\n        </button>\n        <span className=\"edge-unit\">mm</span>\n      </div>\n      <p className=\"edge-controls-hint\">\n        Positive = outward (grow), Negative = inward (shrink)\n      </p>\n    </div>\n  );\n};\n\nconst faceNames: Record<string, string> = {\n  front: 'Front',\n  back: 'Back',\n  left: 'Left',\n  right: 'Right',\n  top: 'Top',\n  bottom: 'Bottom',\n};\n\nconst axisNames: Record<string, string> = {\n  x: 'Vertical (X)',\n  y: 'Horizontal (Y)',\n  z: 'Vertical (Z)',\n};\n\nconst axisLabels: Record<string, string> = {\n  x: 'X Position (left/right)',\n  y: 'Y Position (up/down)',\n  z: 'Z Position (front/back)',\n};\n\n// Calculate face panel dimensions\nconst getFaceDimensions = (\n  faceId: FaceId,\n  width: number,\n  height: number,\n  depth: number,\n  materialThickness: number\n): { panelWidth: number; panelHeight: number } => {\n  switch (faceId) {\n    case 'front':\n    case 'back':\n      return { panelWidth: width, panelHeight: height };\n    case 'left':\n    case 'right':\n      return { panelWidth: depth, panelHeight: height };\n    case 'top':\n    case 'bottom':\n      return { panelWidth: width, panelHeight: depth };\n    default:\n      return { panelWidth: 0, panelHeight: 0 };\n  }\n};\n\n// Calculate divider panel dimensions and which faces it meets\nconst getDividerDimensions = (\n  axis: 'x' | 'y' | 'z',\n  bounds: { x: number; y: number; z: number; w: number; h: number; d: number },\n  containerDims: { width: number; height: number; depth: number },\n  faces: Face[]\n): {\n  panelWidth: number;\n  panelHeight: number;\n  meetsTop: boolean;\n  meetsBottom: boolean;\n  meetsLeft: boolean;\n  meetsRight: boolean;\n} => {\n  const isFaceSolid = (faceId: FaceId) => faces.find((f) => f.id === faceId)?.solid ?? false;\n  const tolerance = 0.01;\n\n  let panelWidth = 0;\n  let panelHeight = 0;\n  let meetsTop = false;\n  let meetsBottom = false;\n  let meetsLeft = false;\n  let meetsRight = false;\n\n  switch (axis) {\n    case 'x':\n      panelWidth = bounds.d;\n      panelHeight = bounds.h;\n      meetsTop = isFaceSolid('top') && bounds.y + bounds.h >= containerDims.height - tolerance;\n      meetsBottom = isFaceSolid('bottom') && bounds.y <= tolerance;\n      meetsLeft = isFaceSolid('back') && bounds.z <= tolerance;\n      meetsRight = isFaceSolid('front') && bounds.z + bounds.d >= containerDims.depth - tolerance;\n      break;\n    case 'y':\n      panelWidth = bounds.w;\n      panelHeight = bounds.d;\n      meetsTop = isFaceSolid('back') && bounds.z <= tolerance;\n      meetsBottom = isFaceSolid('front') && bounds.z + bounds.d >= containerDims.depth - tolerance;\n      meetsLeft = isFaceSolid('left') && bounds.x <= tolerance;\n      meetsRight = isFaceSolid('right') && bounds.x + bounds.w >= containerDims.width - tolerance;\n      break;\n    case 'z':\n      panelWidth = bounds.w;\n      panelHeight = bounds.h;\n      meetsTop = isFaceSolid('top') && bounds.y + bounds.h >= containerDims.height - tolerance;\n      meetsBottom = isFaceSolid('bottom') && bounds.y <= tolerance;\n      meetsLeft = isFaceSolid('left') && bounds.x <= tolerance;\n      meetsRight = isFaceSolid('right') && bounds.x + bounds.w >= containerDims.width - tolerance;\n      break;\n  }\n\n  return { panelWidth, panelHeight, meetsTop, meetsBottom, meetsLeft, meetsRight };\n};\n\nexport const PanelProperties: React.FC = () => {\n  const {\n    selectedPanelIds,\n    faces,\n    config,\n    rootVoid,\n    toggleFace,\n    toggleSubAssemblyFace,\n    panelCollection,\n    setEdgeExtension,\n    setDividerPosition,\n    setDividerPositionMode,\n    enterSketchView,\n  } = useBoxStore();\n\n  const [selectedEdge, setSelectedEdge] = useState<EdgePosition | null>(null);\n\n  // Get the first selected panel ID (for multi-select, show properties of the first one)\n  const selectedPanelId = selectedPanelIds.size > 0 ? Array.from(selectedPanelIds)[0] : null;\n\n  // Get the selected panel from panelCollection\n  const selectedPanel = useMemo(() => {\n    if (!panelCollection || !selectedPanelId) return null;\n    return panelCollection.panels.find((p) => p.id === selectedPanelId) ?? null;\n  }, [panelCollection, selectedPanelId]);\n\n  // Get sub-assembly data if this is a sub-assembly panel\n  const subAssemblyData = useMemo(() => {\n    if (!selectedPanel?.source.subAssemblyId) return null;\n    const subAssemblies = getAllSubAssemblies(rootVoid);\n    return subAssemblies.find((s) => s.subAssembly.id === selectedPanel.source.subAssemblyId) ?? null;\n  }, [selectedPanel, rootVoid]);\n\n  if (!selectedPanelId || !selectedPanel) {\n    return null;\n  }\n\n  const { source } = selectedPanel;\n  const isSubAssembly = !!source.subAssemblyId;\n\n  // Determine which faces and config to use\n  const activeFaces = isSubAssembly && subAssemblyData\n    ? subAssemblyData.subAssembly.faces\n    : faces;\n  const activeConfig = isSubAssembly && subAssemblyData\n    ? {\n        width: subAssemblyData.subAssembly.rootVoid.bounds.w + 2 * subAssemblyData.subAssembly.materialThickness,\n        height: subAssemblyData.subAssembly.rootVoid.bounds.h + 2 * subAssemblyData.subAssembly.materialThickness,\n        depth: subAssemblyData.subAssembly.rootVoid.bounds.d + 2 * subAssemblyData.subAssembly.materialThickness,\n        materialThickness: subAssemblyData.subAssembly.materialThickness,\n        assembly: subAssemblyData.subAssembly.assembly,\n      }\n    : config;\n  const activeRootVoid = isSubAssembly && subAssemblyData\n    ? subAssemblyData.subAssembly.rootVoid\n    : rootVoid;\n\n  const edgeExtensions = selectedPanel.edgeExtensions ?? { top: 0, bottom: 0, left: 0, right: 0 };\n\n  const handleEdgeExtensionChange = (value: number) => {\n    if (selectedEdge && selectedPanel) {\n      setEdgeExtension(selectedPanel.id, selectedEdge, value);\n    }\n  };\n\n  // Handle face panels\n  if (source.type === 'face' && source.faceId) {\n    const faceId = source.faceId;\n    const face = activeFaces.find((f) => f.id === faceId);\n\n    if (!face) return null;\n\n    const { panelWidth, panelHeight } = getFaceDimensions(\n      faceId,\n      activeConfig.width,\n      activeConfig.height,\n      activeConfig.depth,\n      activeConfig.materialThickness\n    );\n\n    const edgeStatuses = getFaceEdgeStatuses(faceId, activeFaces, activeConfig.assembly);\n\n    const selectedEdgeStatus = selectedEdge\n      ? edgeStatuses.find((e) => e.position === selectedEdge)?.status ?? 'locked'\n      : null;\n\n    const titleSuffix = isSubAssembly ? ' (Nested)' : '';\n    const typeLabel = isSubAssembly ? 'Sub-Assembly Face' : 'Outer Face';\n\n    return (\n      <Panel title=\"Panel Properties\">\n        <div className=\"panel-properties\">\n          <div className=\"property-header\">\n            <span className=\"property-icon\"></span>\n            <span className=\"property-title\">{faceNames[faceId]} Face{titleSuffix}</span>\n          </div>\n\n          <div className=\"property-group\">\n            <div className=\"property-row\">\n              <span className=\"property-label\">Type:</span>\n              <span className=\"property-value\">{typeLabel}</span>\n            </div>\n            <div className=\"property-row\">\n              <span className=\"property-label\">Dimensions:</span>\n              <span className=\"property-value\">\n                {panelWidth.toFixed(1)} x {panelHeight.toFixed(1)} mm\n              </span>\n            </div>\n            <div className=\"property-row\">\n              <span className=\"property-label\">Thickness:</span>\n              <span className=\"property-value\">{activeConfig.materialThickness} mm</span>\n            </div>\n          </div>\n\n          <div className=\"property-group\">\n            <label className=\"toggle-row\">\n              <input\n                type=\"checkbox\"\n                checked={face.solid}\n                onChange={() => {\n                  if (isSubAssembly && source.subAssemblyId) {\n                    toggleSubAssemblyFace(source.subAssemblyId, faceId);\n                  } else {\n                    toggleFace(faceId);\n                  }\n                }}\n              />\n              <span>Solid (include in cut)</span>\n            </label>\n          </div>\n\n          {face.solid && (\n            <>\n              <div className=\"property-section\">\n                <h4>Edge Status</h4>\n                <EdgePreview\n                  width={panelWidth}\n                  height={panelHeight}\n                  edgeStatuses={edgeStatuses}\n                  selectedEdge={selectedEdge}\n                  onEdgeClick={setSelectedEdge}\n                  edgeExtensions={edgeExtensions}\n                />\n                <EdgeLegend />\n              </div>\n\n              {selectedEdge && selectedEdgeStatus && (\n                <EdgeControls\n                  edge={selectedEdge}\n                  value={edgeExtensions[selectedEdge]}\n                  status={selectedEdgeStatus}\n                  onChange={handleEdgeExtensionChange}\n                />\n              )}\n            </>\n          )}\n\n          <div className=\"panel-actions\">\n            <button\n              className=\"edit-2d-btn\"\n              onClick={() => enterSketchView(selectedPanel.id)}\n            >\n              Edit in 2D\n            </button>\n          </div>\n        </div>\n      </Panel>\n    );\n  }\n\n  // Handle divider panels\n  if (source.type === 'divider' && source.subdivisionId && source.axis) {\n    const subdivisions = getAllSubdivisions(activeRootVoid);\n    const subdivision = subdivisions.find((s) => s.id === source.subdivisionId);\n\n    if (!subdivision) return null;\n\n    const { axis, position, bounds } = subdivision;\n\n    const containerDims = {\n      width: activeRootVoid.bounds.w,\n      height: activeRootVoid.bounds.h,\n      depth: activeRootVoid.bounds.d,\n    };\n\n    const { panelWidth, panelHeight, meetsTop, meetsBottom, meetsLeft, meetsRight } =\n      getDividerDimensions(axis, bounds, containerDims, activeFaces);\n\n    const edgeStatuses = getDividerEdgeStatuses(meetsTop, meetsBottom, meetsLeft, meetsRight);\n\n    const selectedEdgeStatus = selectedEdge\n      ? edgeStatuses.find((e) => e.position === selectedEdge)?.status ?? 'locked'\n      : null;\n\n    // Calculate position bounds based on parent void\n    const parentDimStart = axis === 'x' ? bounds.x : axis === 'y' ? bounds.y : bounds.z;\n    const parentDimEnd = axis === 'x' ? bounds.x + bounds.w :\n                         axis === 'y' ? bounds.y + bounds.h :\n                         bounds.z + bounds.d;\n    const mt = activeConfig.materialThickness;\n    const minPosition = parentDimStart + mt;\n    const maxPosition = parentDimEnd - mt;\n\n    const handlePositionChange = (newPosition: number) => {\n      setDividerPosition(subdivision.id, newPosition);\n    };\n\n    const titleSuffix = isSubAssembly ? ' (Nested)' : '';\n\n    return (\n      <Panel title=\"Panel Properties\">\n        <div className=\"panel-properties\">\n          <div className=\"property-header\">\n            <span className=\"property-icon\"></span>\n            <span className=\"property-title\">Divider Panel{titleSuffix}</span>\n          </div>\n\n          <div className=\"property-group\">\n            <div className=\"property-row\">\n              <span className=\"property-label\">Type:</span>\n              <span className=\"property-value\">{axisNames[axis]} Divider</span>\n            </div>\n            <div className=\"property-row\">\n              <span className=\"property-label\">Dimensions:</span>\n              <span className=\"property-value\">\n                {panelWidth.toFixed(1)} x {panelHeight.toFixed(1)} mm\n              </span>\n            </div>\n            <div className=\"property-row\">\n              <span className=\"property-label\">Thickness:</span>\n              <span className=\"property-value\">{activeConfig.materialThickness} mm</span>\n            </div>\n          </div>\n\n          {!isSubAssembly && (\n            <div className=\"property-section\">\n              <h4>{axisLabels[axis]}</h4>\n              <div className=\"position-controls\">\n                <div className=\"position-slider-row\">\n                  <input\n                    type=\"range\"\n                    className=\"position-slider\"\n                    min={minPosition}\n                    max={maxPosition}\n                    step={0.5}\n                    value={position}\n                    onChange={(e) => handlePositionChange(parseFloat(e.target.value))}\n                  />\n                </div>\n                <div className=\"position-input-row\">\n                  <button\n                    className=\"position-btn\"\n                    onClick={() => handlePositionChange(position - 1)}\n                    disabled={position <= minPosition}\n                  >\n                    -\n                  </button>\n                  <NumberInput\n                    className=\"position-input\"\n                    value={position}\n                    onChange={handlePositionChange}\n                    min={minPosition}\n                    max={maxPosition}\n                    step={0.5}\n                  />\n                  <button\n                    className=\"position-btn\"\n                    onClick={() => handlePositionChange(position + 1)}\n                    disabled={position >= maxPosition}\n                  >\n                    +\n                  </button>\n                  <span className=\"position-unit\">mm</span>\n                </div>\n              </div>\n              <div className=\"position-mode-toggle\">\n                <label className=\"toggle-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={subdivision.positionMode === 'percentage'}\n                    onChange={(e) => setDividerPositionMode(\n                      subdivision.id,\n                      e.target.checked ? 'percentage' : 'absolute'\n                    )}\n                  />\n                  <span className=\"toggle-text\">Scale with box dimensions</span>\n                </label>\n                {subdivision.positionMode === 'percentage' && subdivision.percentage !== undefined && (\n                  <span className=\"percentage-display\">\n                    ({(subdivision.percentage * 100).toFixed(1)}%)\n                  </span>\n                )}\n              </div>\n            </div>\n          )}\n\n          {isSubAssembly && (\n            <div className=\"property-group\">\n              <div className=\"property-row\">\n                <span className=\"property-label\">Position:</span>\n                <span className=\"property-value\">{position.toFixed(1)} mm</span>\n              </div>\n            </div>\n          )}\n\n          <div className=\"property-section\">\n            <h4>Edge Status</h4>\n            <EdgePreview\n              width={panelWidth}\n              height={panelHeight}\n              edgeStatuses={edgeStatuses}\n              selectedEdge={selectedEdge}\n              onEdgeClick={setSelectedEdge}\n              edgeExtensions={edgeExtensions}\n            />\n            <EdgeLegend />\n          </div>\n\n          {selectedEdge && selectedEdgeStatus && (\n            <EdgeControls\n              edge={selectedEdge}\n              value={edgeExtensions[selectedEdge]}\n              status={selectedEdgeStatus}\n              onChange={handleEdgeExtensionChange}\n            />\n          )}\n\n          <div className=\"panel-actions\">\n            <button\n              className=\"edit-2d-btn\"\n              onClick={() => enterSketchView(selectedPanel.id)}\n            >\n              Edit in 2D\n            </button>\n          </div>\n        </div>\n      </Panel>\n    );\n  }\n\n  return null;\n};\n","import React from 'react';\nimport { useBoxStore, getAllSubAssemblies } from '../store/useBoxStore';\nimport { Panel } from './UI/Panel';\nimport { NumberInput } from './UI/NumberInput';\nimport { FaceId, AssemblyAxis, LidTabDirection, getLidFaceId, defaultFeetConfig } from '../types';\n\nconst faceOrder: FaceId[] = ['front', 'back', 'left', 'right', 'top', 'bottom'];\n\nexport const AssemblyProperties: React.FC = () => {\n  const {\n    selectedAssemblyId,\n    selectedSubAssemblyIds,\n    config,\n    faces,\n    rootVoid,\n    setConfig,\n    toggleFace,\n    toggleSubAssemblyFace,\n    setSubAssemblyClearance,\n    setAssemblyAxis,\n    setLidTabDirection,\n    setLidInset,\n    setSubAssemblyAxis,\n    setSubAssemblyLidTabDirection,\n    setSubAssemblyLidInset,\n    setFeetConfig,\n  } = useBoxStore();\n\n  // Use selectedAssemblyId if set, otherwise use first selected sub-assembly\n  const effectiveAssemblyId = selectedAssemblyId ??\n    (selectedSubAssemblyIds.size > 0 ? Array.from(selectedSubAssemblyIds)[0] : null);\n\n  if (!effectiveAssemblyId) {\n    return null;\n  }\n\n  // Main assembly selected\n  if (effectiveAssemblyId === 'main') {\n    return (\n      <Panel title=\"Assembly Properties\">\n        <div className=\"assembly-properties\">\n          <div className=\"property-header\">\n            <span className=\"property-icon\"></span>\n            <span className=\"property-title\">Main Box</span>\n          </div>\n\n          <div className=\"property-section\">\n            <h4>Dimensions</h4>\n            <div className=\"form-grid\">\n              <label>\n                <span>Width (mm)</span>\n                <NumberInput\n                  value={config.width}\n                  onChange={(v) => setConfig({ width: v })}\n                  min={1}\n                />\n              </label>\n              <label>\n                <span>Height (mm)</span>\n                <NumberInput\n                  value={config.height}\n                  onChange={(v) => setConfig({ height: v })}\n                  min={1}\n                />\n              </label>\n              <label>\n                <span>Depth (mm)</span>\n                <NumberInput\n                  value={config.depth}\n                  onChange={(v) => setConfig({ depth: v })}\n                  min={1}\n                />\n              </label>\n              <label>\n                <span>Material Thickness (mm)</span>\n                <NumberInput\n                  value={config.materialThickness}\n                  onChange={(v) => setConfig({ materialThickness: v })}\n                  min={0.1}\n                  step={0.5}\n                />\n              </label>\n              <label>\n                <span>Finger Width (mm)</span>\n                <NumberInput\n                  value={config.fingerWidth}\n                  onChange={(v) => setConfig({ fingerWidth: v })}\n                  min={1}\n                />\n              </label>\n            </div>\n          </div>\n\n          <div className=\"property-section\">\n            <h4>Faces</h4>\n            <div className=\"face-grid compact\">\n              <div className=\"face-row\">\n                <div className=\"face-spacer small\" />\n                <FaceButton faceId=\"top\" face={faces.find(f => f.id === 'top')!} onToggle={toggleFace} />\n                <div className=\"face-spacer small\" />\n              </div>\n              <div className=\"face-row\">\n                <FaceButton faceId=\"left\" face={faces.find(f => f.id === 'left')!} onToggle={toggleFace} />\n                <FaceButton faceId=\"front\" face={faces.find(f => f.id === 'front')!} onToggle={toggleFace} />\n                <FaceButton faceId=\"right\" face={faces.find(f => f.id === 'right')!} onToggle={toggleFace} />\n              </div>\n              <div className=\"face-row\">\n                <div className=\"face-spacer small\" />\n                <FaceButton faceId=\"bottom\" face={faces.find(f => f.id === 'bottom')!} onToggle={toggleFace} />\n                <div className=\"face-spacer small\" />\n              </div>\n              <div className=\"face-row\">\n                <div className=\"face-spacer small\" />\n                <FaceButton faceId=\"back\" face={faces.find(f => f.id === 'back')!} onToggle={toggleFace} />\n                <div className=\"face-spacer small\" />\n              </div>\n            </div>\n          </div>\n\n          <div className=\"property-section\">\n            <h4>Assembly</h4>\n            <div className=\"form-grid\">\n              <label>\n                <span>Assembly Axis</span>\n                <select\n                  value={config.assembly.assemblyAxis}\n                  onChange={(e) => setAssemblyAxis(e.target.value as AssemblyAxis)}\n                >\n                  <option value=\"y\">Y (top/bottom lids)</option>\n                  <option value=\"x\">X (left/right lids)</option>\n                  <option value=\"z\">Z (front/back lids)</option>\n                </select>\n              </label>\n            </div>\n\n            <div className=\"lid-config-section\">\n              <h5>\n                {getLidFaceId(config.assembly.assemblyAxis, 'positive').charAt(0).toUpperCase() +\n                  getLidFaceId(config.assembly.assemblyAxis, 'positive').slice(1)} Lid\n              </h5>\n              <div className=\"form-grid\">\n                <label>\n                  <span>Tab Direction</span>\n                  <select\n                    value={config.assembly.lids.positive.tabDirection}\n                    onChange={(e) => setLidTabDirection('positive', e.target.value as LidTabDirection)}\n                    disabled={config.assembly.lids.positive.inset > 0}\n                  >\n                    <option value=\"tabs-out\">Tabs Out (into walls)</option>\n                    <option value=\"tabs-in\">Tabs In (from walls)</option>\n                  </select>\n                </label>\n                <label>\n                  <span>Inset (mm)</span>\n                  <NumberInput\n                    value={config.assembly.lids.positive.inset}\n                    onChange={(v) => setLidInset('positive', v)}\n                    min={0}\n                    step={1}\n                  />\n                </label>\n              </div>\n            </div>\n\n            <div className=\"lid-config-section\">\n              <h5>\n                {getLidFaceId(config.assembly.assemblyAxis, 'negative').charAt(0).toUpperCase() +\n                  getLidFaceId(config.assembly.assemblyAxis, 'negative').slice(1)} Lid\n              </h5>\n              <div className=\"form-grid\">\n                <label>\n                  <span>Tab Direction</span>\n                  <select\n                    value={config.assembly.lids.negative.tabDirection}\n                    onChange={(e) => setLidTabDirection('negative', e.target.value as LidTabDirection)}\n                    disabled={config.assembly.lids.negative.inset > 0}\n                  >\n                    <option value=\"tabs-out\">Tabs Out (into walls)</option>\n                    <option value=\"tabs-in\">Tabs In (from walls)</option>\n                  </select>\n                </label>\n                <label>\n                  <span>Inset (mm)</span>\n                  <NumberInput\n                    value={config.assembly.lids.negative.inset}\n                    onChange={(v) => setLidInset('negative', v)}\n                    min={0}\n                    step={1}\n                  />\n                </label>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"property-section\">\n            <h4>Feet</h4>\n            <div className=\"form-grid\">\n              <label className=\"checkbox-label\">\n                <input\n                  type=\"checkbox\"\n                  checked={config.assembly.feet?.enabled ?? false}\n                  onChange={(e) => setFeetConfig({\n                    ...defaultFeetConfig,\n                    ...config.assembly.feet,\n                    enabled: e.target.checked,\n                  })}\n                />\n                <span>Add feet to box</span>\n              </label>\n            </div>\n            {config.assembly.feet?.enabled && (\n              <div className=\"form-grid\">\n                <label>\n                  <span>Height (mm)</span>\n                  <NumberInput\n                    value={config.assembly.feet.height}\n                    onChange={(v) => setFeetConfig({\n                      ...config.assembly.feet!,\n                      height: v,\n                    })}\n                    min={5}\n                    max={100}\n                    step={5}\n                  />\n                </label>\n                <label>\n                  <span>Foot width (mm)</span>\n                  <NumberInput\n                    value={config.assembly.feet.width}\n                    onChange={(v) => setFeetConfig({\n                      ...config.assembly.feet!,\n                      width: v,\n                    })}\n                    min={10}\n                    max={100}\n                    step={5}\n                  />\n                </label>\n                <label>\n                  <span>Inset from edge (mm)</span>\n                  <NumberInput\n                    value={config.assembly.feet.inset}\n                    onChange={(v) => setFeetConfig({\n                      ...config.assembly.feet!,\n                      inset: v,\n                    })}\n                    min={0}\n                    max={50}\n                    step={1}\n                  />\n                </label>\n              </div>\n            )}\n            {config.assembly.feet?.enabled && (\n              <p className=\"hint\">Feet extend wall panels below the bottom face.</p>\n            )}\n          </div>\n        </div>\n      </Panel>\n    );\n  }\n\n  // Sub-assembly selected\n  const subAssemblies = getAllSubAssemblies(rootVoid);\n  const subAssemblyData = subAssemblies.find(s => s.subAssembly.id === effectiveAssemblyId);\n\n  if (!subAssemblyData) {\n    return (\n      <Panel title=\"Assembly Properties\">\n        <p className=\"hint\">Assembly not found</p>\n      </Panel>\n    );\n  }\n\n  const { subAssembly, bounds } = subAssemblyData;\n\n  return (\n    <Panel title=\"Assembly Properties\">\n      <div className=\"assembly-properties\">\n        <div className=\"property-header\">\n          <span className=\"property-icon\"></span>\n          <span className=\"property-title\">Nested Box</span>\n        </div>\n\n        <div className=\"property-section\">\n          <h4>Dimensions</h4>\n          <div className=\"property-group\">\n            <div className=\"property-row\">\n              <span className=\"property-label\">Outer Width:</span>\n              <span className=\"property-value\">{(bounds.w - subAssembly.clearance * 2).toFixed(1)} mm</span>\n            </div>\n            <div className=\"property-row\">\n              <span className=\"property-label\">Outer Height:</span>\n              <span className=\"property-value\">{(bounds.h - subAssembly.clearance * 2).toFixed(1)} mm</span>\n            </div>\n            <div className=\"property-row\">\n              <span className=\"property-label\">Outer Depth:</span>\n              <span className=\"property-value\">{(bounds.d - subAssembly.clearance * 2).toFixed(1)} mm</span>\n            </div>\n            <div className=\"property-row\">\n              <span className=\"property-label\">Material:</span>\n              <span className=\"property-value\">{subAssembly.materialThickness} mm</span>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"property-section\">\n          <h4>Clearance</h4>\n          <div className=\"form-grid\">\n            <label>\n              <span>Gap from parent void (mm)</span>\n              <NumberInput\n                value={subAssembly.clearance}\n                onChange={(v) => setSubAssemblyClearance(subAssembly.id, v)}\n                min={0}\n                max={Math.min(bounds.w, bounds.h, bounds.d) / 2 - 1}\n                step={0.5}\n              />\n            </label>\n          </div>\n        </div>\n\n        <div className=\"property-section\">\n          <h4>Faces</h4>\n          <div className=\"face-grid compact\">\n            <div className=\"face-row\">\n              <div className=\"face-spacer small\" />\n              <FaceButton\n                faceId=\"top\"\n                face={subAssembly.faces.find(f => f.id === 'top')!}\n                onToggle={(id) => toggleSubAssemblyFace(subAssembly.id, id)}\n              />\n              <div className=\"face-spacer small\" />\n            </div>\n            <div className=\"face-row\">\n              <FaceButton\n                faceId=\"left\"\n                face={subAssembly.faces.find(f => f.id === 'left')!}\n                onToggle={(id) => toggleSubAssemblyFace(subAssembly.id, id)}\n              />\n              <FaceButton\n                faceId=\"front\"\n                face={subAssembly.faces.find(f => f.id === 'front')!}\n                onToggle={(id) => toggleSubAssemblyFace(subAssembly.id, id)}\n              />\n              <FaceButton\n                faceId=\"right\"\n                face={subAssembly.faces.find(f => f.id === 'right')!}\n                onToggle={(id) => toggleSubAssemblyFace(subAssembly.id, id)}\n              />\n            </div>\n            <div className=\"face-row\">\n              <div className=\"face-spacer small\" />\n              <FaceButton\n                faceId=\"bottom\"\n                face={subAssembly.faces.find(f => f.id === 'bottom')!}\n                onToggle={(id) => toggleSubAssemblyFace(subAssembly.id, id)}\n              />\n              <div className=\"face-spacer small\" />\n            </div>\n            <div className=\"face-row\">\n              <div className=\"face-spacer small\" />\n              <FaceButton\n                faceId=\"back\"\n                face={subAssembly.faces.find(f => f.id === 'back')!}\n                onToggle={(id) => toggleSubAssemblyFace(subAssembly.id, id)}\n              />\n              <div className=\"face-spacer small\" />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"property-section\">\n          <h4>Assembly</h4>\n          <div className=\"form-grid\">\n            <label>\n              <span>Assembly Axis</span>\n              <select\n                value={subAssembly.assembly.assemblyAxis}\n                onChange={(e) => setSubAssemblyAxis(subAssembly.id, e.target.value as AssemblyAxis)}\n              >\n                <option value=\"y\">Y (top/bottom lids)</option>\n                <option value=\"x\">X (left/right lids)</option>\n                <option value=\"z\">Z (front/back lids)</option>\n              </select>\n            </label>\n          </div>\n\n          <div className=\"lid-config-section\">\n            <h5>\n              {getLidFaceId(subAssembly.assembly.assemblyAxis, 'positive').charAt(0).toUpperCase() +\n                getLidFaceId(subAssembly.assembly.assemblyAxis, 'positive').slice(1)} Lid\n            </h5>\n            <div className=\"form-grid\">\n              <label>\n                <span>Tab Direction</span>\n                <select\n                  value={subAssembly.assembly.lids.positive.tabDirection}\n                  onChange={(e) => setSubAssemblyLidTabDirection(subAssembly.id, 'positive', e.target.value as LidTabDirection)}\n                  disabled={subAssembly.assembly.lids.positive.inset > 0}\n                >\n                  <option value=\"tabs-out\">Tabs Out (into walls)</option>\n                  <option value=\"tabs-in\">Tabs In (from walls)</option>\n                </select>\n              </label>\n              <label>\n                <span>Inset (mm)</span>\n                <NumberInput\n                  value={subAssembly.assembly.lids.positive.inset}\n                  onChange={(v) => setSubAssemblyLidInset(subAssembly.id, 'positive', v)}\n                  min={0}\n                  step={1}\n                />\n              </label>\n            </div>\n          </div>\n\n          <div className=\"lid-config-section\">\n            <h5>\n              {getLidFaceId(subAssembly.assembly.assemblyAxis, 'negative').charAt(0).toUpperCase() +\n                getLidFaceId(subAssembly.assembly.assemblyAxis, 'negative').slice(1)} Lid\n            </h5>\n            <div className=\"form-grid\">\n              <label>\n                <span>Tab Direction</span>\n                <select\n                  value={subAssembly.assembly.lids.negative.tabDirection}\n                  onChange={(e) => setSubAssemblyLidTabDirection(subAssembly.id, 'negative', e.target.value as LidTabDirection)}\n                  disabled={subAssembly.assembly.lids.negative.inset > 0}\n                >\n                  <option value=\"tabs-out\">Tabs Out (into walls)</option>\n                  <option value=\"tabs-in\">Tabs In (from walls)</option>\n                </select>\n              </label>\n              <label>\n                <span>Inset (mm)</span>\n                <NumberInput\n                  value={subAssembly.assembly.lids.negative.inset}\n                  onChange={(v) => setSubAssemblyLidInset(subAssembly.id, 'negative', v)}\n                  min={0}\n                  step={1}\n                />\n              </label>\n            </div>\n          </div>\n        </div>\n      </div>\n    </Panel>\n  );\n};\n\n// Compact face button for assembly properties\nconst FaceButton: React.FC<{\n  faceId: FaceId;\n  face: { id: FaceId; solid: boolean };\n  onToggle: (faceId: FaceId) => void;\n}> = ({ faceId, face, onToggle }) => {\n  const labels: Record<FaceId, string> = {\n    front: 'F',\n    back: 'Bk',\n    left: 'L',\n    right: 'R',\n    top: 'T',\n    bottom: 'Bt',\n  };\n\n  return (\n    <button\n      className={`face-button small ${face.solid ? 'solid' : 'open'}`}\n      onClick={() => onToggle(faceId)}\n      title={`${faceId}: ${face.solid ? 'Solid' : 'Open'}`}\n    >\n      {labels[faceId]}\n    </button>\n  );\n};\n","import React from 'react';\nimport { useBoxStore } from '../store/useBoxStore';\nimport { Panel } from './UI/Panel';\nimport { NumberInput } from './UI/NumberInput';\n\nexport const DimensionForm: React.FC = () => {\n  const { config, setConfig } = useBoxStore();\n\n  return (\n    <Panel title=\"Dimensions\">\n      <div className=\"form-grid\">\n        <label>\n          <span>Width (mm)</span>\n          <NumberInput\n            value={config.width}\n            onChange={(v) => setConfig({ width: v })}\n            min={1}\n            step={1}\n          />\n        </label>\n        <label>\n          <span>Height (mm)</span>\n          <NumberInput\n            value={config.height}\n            onChange={(v) => setConfig({ height: v })}\n            min={1}\n            step={1}\n          />\n        </label>\n        <label>\n          <span>Depth (mm)</span>\n          <NumberInput\n            value={config.depth}\n            onChange={(v) => setConfig({ depth: v })}\n            min={1}\n            step={1}\n          />\n        </label>\n        <label>\n          <span>Material Thickness (mm)</span>\n          <NumberInput\n            value={config.materialThickness}\n            onChange={(v) => setConfig({ materialThickness: v })}\n            min={0.1}\n            step={0.1}\n          />\n        </label>\n        <label>\n          <span>Finger Width (mm)</span>\n          <NumberInput\n            value={config.fingerWidth}\n            onChange={(v) => setConfig({ fingerWidth: v })}\n            min={1}\n            step={1}\n          />\n        </label>\n        <label>\n          <span>Corner Gap ( finger width)</span>\n          <NumberInput\n            value={config.fingerGap}\n            onChange={(v) => setConfig({ fingerGap: v })}\n            min={0}\n            max={5}\n            step={0.1}\n          />\n        </label>\n      </div>\n    </Panel>\n  );\n};\n","import React, { useEffect } from 'react';\n\ninterface ModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  title: string;\n  children: React.ReactNode;\n}\n\nexport const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {\n  // Close on escape key\n  useEffect(() => {\n    const handleEscape = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') onClose();\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n      document.body.style.overflow = 'hidden';\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n      document.body.style.overflow = '';\n    };\n  }, [isOpen, onClose]);\n\n  if (!isOpen) return null;\n\n  return (\n    <div className=\"modal-overlay\" onClick={onClose}>\n      <div className=\"modal-content\" onClick={(e) => e.stopPropagation()}>\n        <div className=\"modal-header\">\n          <h2>{title}</h2>\n          <button className=\"modal-close\" onClick={onClose}></button>\n        </div>\n        <div className=\"modal-body\">\n          {children}\n        </div>\n      </div>\n    </div>\n  );\n};\n","import { BoxConfig, Face, FaceId, Void, SubdivisionPanel, SubdivisionIntersection, Subdivision, Bounds, getFaceRole, getLidSide, getWallPriority, getLidFaceId, AssemblyConfig, PanelPath, PanelCollection, PathPoint } from '../types';\nimport { EdgeType, getEdgePath, Point } from './fingerJoints';\nimport { getAllSubdivisions } from '../store/useBoxStore';\n\n// =============================================================================\n// Bin Packing Algorithm (MaxRects with Best Short Side Fit)\n// =============================================================================\n\ninterface Rect {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\ninterface PackedItem {\n  panel: PanelPath;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotated: boolean;\n}\n\ninterface PackedBed {\n  items: PackedItem[];\n  width: number;\n  height: number;\n}\n\n// MaxRects bin packing implementation\nclass MaxRectsBin {\n  private binWidth: number;\n  private binHeight: number;\n  private freeRectangles: Rect[] = [];\n  public packedItems: PackedItem[] = [];\n\n  constructor(width: number, height: number) {\n    this.binWidth = width;\n    this.binHeight = height;\n    this.freeRectangles = [{ x: 0, y: 0, width, height }];\n  }\n\n  // Try to insert a rectangle, returns true if successful\n  insert(panel: PanelPath, itemWidth: number, itemHeight: number, allowRotation: boolean = true): boolean {\n    // Find the best position using Best Short Side Fit\n    let bestScore = Infinity;\n    let bestRect: Rect | null = null;\n    let bestRotated = false;\n\n    for (const freeRect of this.freeRectangles) {\n      // Try without rotation\n      if (itemWidth <= freeRect.width && itemHeight <= freeRect.height) {\n        const leftover = Math.min(freeRect.width - itemWidth, freeRect.height - itemHeight);\n        if (leftover < bestScore) {\n          bestScore = leftover;\n          bestRect = freeRect;\n          bestRotated = false;\n        }\n      }\n\n      // Try with rotation\n      if (allowRotation && itemHeight <= freeRect.width && itemWidth <= freeRect.height) {\n        const leftover = Math.min(freeRect.width - itemHeight, freeRect.height - itemWidth);\n        if (leftover < bestScore) {\n          bestScore = leftover;\n          bestRect = freeRect;\n          bestRotated = true;\n        }\n      }\n    }\n\n    if (!bestRect) return false;\n\n    const placedWidth = bestRotated ? itemHeight : itemWidth;\n    const placedHeight = bestRotated ? itemWidth : itemHeight;\n\n    this.packedItems.push({\n      panel,\n      x: bestRect.x,\n      y: bestRect.y,\n      width: placedWidth,\n      height: placedHeight,\n      rotated: bestRotated,\n    });\n\n    // Split the free rectangle\n    this.splitFreeRect(bestRect, placedWidth, placedHeight);\n    this.pruneFreeRectangles();\n\n    return true;\n  }\n\n  private splitFreeRect(rect: Rect, usedWidth: number, usedHeight: number): void {\n    // Remove the used rectangle from free list\n    const index = this.freeRectangles.indexOf(rect);\n    if (index !== -1) {\n      this.freeRectangles.splice(index, 1);\n    }\n\n    // Create new free rectangles from the remaining space\n    // Right remainder\n    if (usedWidth < rect.width) {\n      this.freeRectangles.push({\n        x: rect.x + usedWidth,\n        y: rect.y,\n        width: rect.width - usedWidth,\n        height: rect.height,\n      });\n    }\n\n    // Top remainder\n    if (usedHeight < rect.height) {\n      this.freeRectangles.push({\n        x: rect.x,\n        y: rect.y + usedHeight,\n        width: usedWidth,\n        height: rect.height - usedHeight,\n      });\n    }\n  }\n\n  private pruneFreeRectangles(): void {\n    // Remove rectangles that are fully contained in other rectangles\n    for (let i = 0; i < this.freeRectangles.length; i++) {\n      for (let j = i + 1; j < this.freeRectangles.length; j++) {\n        if (this.isContainedIn(this.freeRectangles[i], this.freeRectangles[j])) {\n          this.freeRectangles.splice(i, 1);\n          i--;\n          break;\n        }\n        if (this.isContainedIn(this.freeRectangles[j], this.freeRectangles[i])) {\n          this.freeRectangles.splice(j, 1);\n          j--;\n        }\n      }\n    }\n  }\n\n  private isContainedIn(a: Rect, b: Rect): boolean {\n    return a.x >= b.x && a.y >= b.y &&\n           a.x + a.width <= b.x + b.width &&\n           a.y + a.height <= b.y + b.height;\n  }\n}\n\n// Minimal padding for labels (just enough for text below panel)\nconst LABEL_PADDING = 5; // mm below panel for label text\n\n// Pack panels into beds of specified size\nexport const packPanelsIntoBeds = (\n  panels: PanelPath[],\n  bedWidth: number,\n  bedHeight: number,\n  gap: number = 5,\n  allowRotation: boolean = true,\n  showLabels: boolean = true\n): PackedBed[] => {\n  const beds: PackedBed[] = [];\n  const labelSpace = showLabels ? LABEL_PADDING : 0;\n\n  // Filter visible panels and calculate their sizes\n  // Only add gap between items, no extra padding\n  const itemsToPlace = panels\n    .filter(p => p.visible)\n    .map(panel => {\n      return {\n        panel,\n        width: panel.width + gap,\n        height: panel.height + labelSpace + gap,\n      };\n    })\n    // Sort by area (largest first) for better packing\n    .sort((a, b) => (b.width * b.height) - (a.width * a.height));\n\n  // Effective bed size (accounting for edge gap)\n  const effectiveWidth = bedWidth - gap;\n  const effectiveHeight = bedHeight - gap;\n\n  let remainingItems = [...itemsToPlace];\n\n  while (remainingItems.length > 0) {\n    const bin = new MaxRectsBin(effectiveWidth, effectiveHeight);\n    const placedIndices: number[] = [];\n\n    for (let i = 0; i < remainingItems.length; i++) {\n      const item = remainingItems[i];\n      if (bin.insert(item.panel, item.width, item.height, allowRotation)) {\n        placedIndices.push(i);\n      }\n    }\n\n    if (placedIndices.length === 0) {\n      // Can't fit any remaining items - they're too large for the bed\n      // Create oversized beds for each remaining item\n      for (const item of remainingItems) {\n        beds.push({\n          items: [{\n            panel: item.panel,\n            x: gap,\n            y: gap,\n            width: item.width,\n            height: item.height,\n            rotated: false,\n          }],\n          width: item.width + gap * 2,\n          height: item.height + gap * 2,\n        });\n      }\n      break;\n    }\n\n    // Adjust positions to account for initial gap offset\n    const adjustedItems = bin.packedItems.map(item => ({\n      ...item,\n      x: item.x + gap,\n      y: item.y + gap,\n    }));\n\n    beds.push({\n      items: adjustedItems,\n      width: bedWidth,\n      height: bedHeight,\n    });\n\n    // Remove placed items from remaining\n    remainingItems = remainingItems.filter((_, i) => !placedIndices.includes(i));\n  }\n\n  return beds;\n};\n\n// Pack panels efficiently without a specific bed size (auto-size)\nexport const packPanelsAuto = (\n  panels: PanelPath[],\n  gap: number = 5,\n  showLabels: boolean = true\n): PackedBed => {\n  const visiblePanels = panels.filter(p => p.visible);\n  if (visiblePanels.length === 0) {\n    return { items: [], width: 0, height: 0 };\n  }\n\n  const labelSpace = showLabels ? LABEL_PADDING : 0;\n\n  // Calculate sizes - minimal padding, just gap between items\n  const items = visiblePanels.map(panel => {\n    return {\n      panel,\n      width: panel.width,\n      height: panel.height + labelSpace,\n    };\n  });\n\n  // Sort by height (tallest first) for shelf packing\n  items.sort((a, b) => b.height - a.height);\n\n  // Use a simple shelf-based algorithm for auto-sizing\n  // This tends to produce compact rectangular layouts\n  const shelves: { y: number; height: number; items: PackedItem[] }[] = [];\n  let maxWidth = 0;\n\n  for (const item of items) {\n    // Try to fit on an existing shelf\n    let placed = false;\n    for (const shelf of shelves) {\n      const shelfWidth = shelf.items.reduce((sum, i) => sum + i.width + gap, gap);\n      if (item.height <= shelf.height) {\n        shelf.items.push({\n          panel: item.panel,\n          x: shelfWidth,\n          y: shelf.y,\n          width: item.width,\n          height: item.height,\n          rotated: false,\n        });\n        maxWidth = Math.max(maxWidth, shelfWidth + item.width + gap);\n        placed = true;\n        break;\n      }\n    }\n\n    // Create a new shelf\n    if (!placed) {\n      const shelfY = shelves.length === 0\n        ? gap\n        : shelves[shelves.length - 1].y + shelves[shelves.length - 1].height + gap;\n      shelves.push({\n        y: shelfY,\n        height: item.height,\n        items: [{\n          panel: item.panel,\n          x: gap,\n          y: shelfY,\n          width: item.width,\n          height: item.height,\n          rotated: false,\n        }],\n      });\n      maxWidth = Math.max(maxWidth, gap + item.width + gap);\n    }\n  }\n\n  const allItems = shelves.flatMap(s => s.items);\n  const totalHeight = shelves.length === 0\n    ? 0\n    : shelves[shelves.length - 1].y + shelves[shelves.length - 1].height + gap;\n\n  return {\n    items: allItems,\n    width: maxWidth,\n    height: totalHeight,\n  };\n};\n\n// =============================================================================\n// Panel Path based SVG generation (uses stored paths)\n// =============================================================================\n\n// Convert PathPoints to SVG path data string\n// The points are in panel-local coordinates (centered at 0,0)\n// offsetX/offsetY shift the center to the SVG coordinate space\nconst pathPointsToSVGPath = (\n  points: PathPoint[],\n  offsetX: number,\n  offsetY: number\n): string => {\n  if (points.length === 0) return '';\n\n  // Note: SVG Y-axis is flipped (positive Y is down), so we negate Y\n  let path = `M ${(points[0].x + offsetX).toFixed(3)} ${(-points[0].y + offsetY).toFixed(3)} `;\n  for (let i = 1; i < points.length; i++) {\n    path += `L ${(points[i].x + offsetX).toFixed(3)} ${(-points[i].y + offsetY).toFixed(3)} `;\n  }\n  path += 'Z';\n  return path;\n};\n\n// Generate SVG for a single panel using stored PanelPath\nexport const generatePanelPathSVG = (\n  panel: PanelPath,\n  kerf: number = 0\n): string => {\n  const padding = panel.thickness * 4;\n  const svgWidth = panel.width + padding * 2;\n  const svgHeight = panel.height + padding * 2;\n\n  // Offset to center the panel in the SVG (panel coords are centered at 0,0)\n  const offsetX = svgWidth / 2;\n  const offsetY = svgHeight / 2;\n\n  const outlinePath = pathPointsToSVGPath(panel.outline.points, offsetX, offsetY);\n\n  let svg = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"${svgWidth}mm\"\n     height=\"${svgHeight}mm\"\n     viewBox=\"0 0 ${svgWidth} ${svgHeight}\">\n  <title>${panel.label || panel.id}</title>\n  <g stroke=\"#000\" stroke-width=\"0.1\" fill=\"none\">\n    <path d=\"${outlinePath}\" />\n`;\n\n  // Add hole paths\n  for (const hole of panel.holes) {\n    const holePath = pathPointsToSVGPath(hole.path.points, offsetX, offsetY);\n    svg += `    <path d=\"${holePath}\" />\\n`;\n  }\n\n  svg += `  </g>\n  <text x=\"${svgWidth / 2}\" y=\"${svgHeight - 2}\"\n        text-anchor=\"middle\" font-size=\"3\" fill=\"red\" stroke=\"red\">\n    ${panel.label || panel.id} - ${panel.width.toFixed(1)}mm x ${panel.height.toFixed(1)}mm\n  </text>\n</svg>`;\n\n  return svg;\n};\n\n// Export options for bed-based packing\nexport interface BedExportOptions {\n  bedWidth?: number;       // Bed width in mm (undefined = auto-size)\n  bedHeight?: number;      // Bed height in mm (undefined = auto-size)\n  gap?: number;            // Gap between pieces in mm (default: 5)\n  allowRotation?: boolean; // Allow 90 rotation for better fit (default: true)\n  kerf?: number;           // Kerf compensation in mm (default: 0)\n  showLabels?: boolean;    // Show labels on panels (default: true)\n}\n\n// Generate SVG for a single packed bed\nconst generatePackedBedSVG = (\n  bed: PackedBed,\n  bedIndex: number,\n  totalBeds: number,\n  kerf: number = 0,\n  showLabels: boolean = true\n): string => {\n  const title = totalBeds > 1\n    ? `Boxen Export - Bed ${bedIndex + 1} of ${totalBeds}`\n    : 'Boxen Export - All Pieces';\n\n  let svg = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"${bed.width}mm\"\n     height=\"${bed.height}mm\"\n     viewBox=\"0 0 ${bed.width} ${bed.height}\">\n  <title>${title}</title>\n`;\n\n  for (const item of bed.items) {\n    // Panel paths are centered at (0,0), offset to position in allocated space\n    const panelW = item.panel.width;\n    const panelH = item.panel.height;\n    const offsetX = panelW / 2;\n    const offsetY = panelH / 2;\n\n    // Generate path with potential rotation\n    let outlinePath: string;\n    let holePaths: string[] = [];\n\n    if (item.rotated) {\n      // Rotate points 90 clockwise: (x, y) -> (y, -x)\n      const rotatedOutline = item.panel.outline.points.map(p => ({\n        x: p.y,\n        y: -p.x,\n      }));\n      // For rotated panels, swap width/height for offset\n      outlinePath = pathPointsToSVGPath(rotatedOutline, panelH / 2, panelW / 2);\n\n      for (const hole of item.panel.holes) {\n        const rotatedHole = hole.path.points.map(p => ({\n          x: p.y,\n          y: -p.x,\n        }));\n        holePaths.push(pathPointsToSVGPath(rotatedHole, panelH / 2, panelW / 2));\n      }\n    } else {\n      outlinePath = pathPointsToSVGPath(item.panel.outline.points, offsetX, offsetY);\n\n      for (const hole of item.panel.holes) {\n        holePaths.push(pathPointsToSVGPath(hole.path.points, offsetX, offsetY));\n      }\n    }\n\n    const displayWidth = item.rotated ? panelH : panelW;\n    const displayHeight = item.rotated ? panelW : panelH;\n\n    svg += `  <g transform=\"translate(${item.x}, ${item.y})\" stroke=\"#000\" stroke-width=\"0.1\" fill=\"none\">\n    <path d=\"${outlinePath}\" />\n`;\n\n    for (const holePath of holePaths) {\n      svg += `    <path d=\"${holePath}\" />\\n`;\n    }\n\n    if (showLabels) {\n      const rotatedIndicator = item.rotated ? ' (R)' : '';\n      svg += `    <text x=\"${displayWidth / 2}\" y=\"${displayHeight + LABEL_PADDING - 1}\"\n          text-anchor=\"middle\" font-size=\"2\" fill=\"red\" stroke=\"red\">\n      ${item.panel.label || item.panel.id}${rotatedIndicator}\n    </text>\n`;\n    }\n    svg += `  </g>\n`;\n  }\n\n  svg += '</svg>';\n  return svg;\n};\n\n// Generate SVG containing all panels from a PanelCollection with efficient packing\nexport const generateAllPanelPathsSVG = (\n  collection: PanelCollection,\n  kerf: number = 0,\n  options?: BedExportOptions\n): string => {\n  const gap = options?.gap ?? 5;\n  const allowRotation = options?.allowRotation ?? true;\n  const showLabels = options?.showLabels ?? true;\n\n  // Use bed-based packing if bed size is specified\n  if (options?.bedWidth && options?.bedHeight) {\n    const beds = packPanelsIntoBeds(\n      collection.panels,\n      options.bedWidth,\n      options.bedHeight,\n      gap,\n      allowRotation,\n      showLabels\n    );\n\n    if (beds.length === 0) {\n      return generatePackedBedSVG({ items: [], width: 100, height: 100 }, 0, 1, kerf, showLabels);\n    }\n\n    // For single bed, just return it\n    if (beds.length === 1) {\n      return generatePackedBedSVG(beds[0], 0, 1, kerf, showLabels);\n    }\n\n    // For multiple beds, stack them vertically with a separator\n    const bedSeparator = 20;\n    let totalHeight = 0;\n    let maxWidth = 0;\n\n    for (const bed of beds) {\n      totalHeight += bed.height + bedSeparator;\n      maxWidth = Math.max(maxWidth, bed.width);\n    }\n\n    let svg = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"${maxWidth}mm\"\n     height=\"${totalHeight}mm\"\n     viewBox=\"0 0 ${maxWidth} ${totalHeight}\">\n  <title>Boxen Export - ${beds.length} Beds</title>\n`;\n\n    let currentY = 0;\n    for (let i = 0; i < beds.length; i++) {\n      const bed = beds[i];\n\n      // Add bed boundary rectangle (dashed)\n      svg += `  <rect x=\"0\" y=\"${currentY}\" width=\"${bed.width}\" height=\"${bed.height}\"\n        stroke=\"red\" stroke-width=\"0.5\" stroke-dasharray=\"5,5\" fill=\"none\" />\n  <text x=\"5\" y=\"${currentY + 10}\" font-size=\"4\" fill=\"red\" stroke=\"red\">Bed ${i + 1}</text>\n`;\n\n      // Add panels in this bed\n      for (const item of bed.items) {\n        const panelW = item.panel.width;\n        const panelH = item.panel.height;\n        const offsetX = panelW / 2;\n        const offsetY = panelH / 2;\n\n        let outlinePath: string;\n        let holePaths: string[] = [];\n\n        if (item.rotated) {\n          const rotatedOutline = item.panel.outline.points.map(p => ({\n            x: p.y,\n            y: -p.x,\n          }));\n          outlinePath = pathPointsToSVGPath(rotatedOutline, panelH / 2, panelW / 2);\n\n          for (const hole of item.panel.holes) {\n            const rotatedHole = hole.path.points.map(p => ({\n              x: p.y,\n              y: -p.x,\n            }));\n            holePaths.push(pathPointsToSVGPath(rotatedHole, panelH / 2, panelW / 2));\n          }\n        } else {\n          outlinePath = pathPointsToSVGPath(item.panel.outline.points, offsetX, offsetY);\n\n          for (const hole of item.panel.holes) {\n            holePaths.push(pathPointsToSVGPath(hole.path.points, offsetX, offsetY));\n          }\n        }\n\n        const displayWidth = item.rotated ? panelH : panelW;\n        const displayHeight = item.rotated ? panelW : panelH;\n\n        svg += `  <g transform=\"translate(${item.x}, ${currentY + item.y})\" stroke=\"#000\" stroke-width=\"0.1\" fill=\"none\">\n    <path d=\"${outlinePath}\" />\n`;\n\n        for (const holePath of holePaths) {\n          svg += `    <path d=\"${holePath}\" />\\n`;\n        }\n\n        if (showLabels) {\n          const rotatedIndicator = item.rotated ? ' (R)' : '';\n          svg += `    <text x=\"${displayWidth / 2}\" y=\"${displayHeight + LABEL_PADDING - 1}\"\n          text-anchor=\"middle\" font-size=\"2\" fill=\"red\" stroke=\"red\">\n      ${item.panel.label || item.panel.id}${rotatedIndicator}\n    </text>\n`;\n        }\n        svg += `  </g>\n`;\n      }\n\n      currentY += bed.height + bedSeparator;\n    }\n\n    svg += '</svg>';\n    return svg;\n  }\n\n  // Auto-size packing (no bed size specified)\n  const packed = packPanelsAuto(collection.panels, gap, showLabels);\n\n  if (packed.items.length === 0) {\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100mm\" height=\"100mm\" viewBox=\"0 0 100 100\">\n  <title>Boxen Export - No Pieces</title>\n</svg>`;\n  }\n\n  return generatePackedBedSVG(packed, 0, 1, kerf, showLabels);\n};\n\n// Generate multiple SVG files for multiple beds\nexport const generateMultipleBedSVGs = (\n  collection: PanelCollection,\n  options: BedExportOptions\n): string[] => {\n  const gap = options?.gap ?? 5;\n  const allowRotation = options?.allowRotation ?? true;\n  const kerf = options?.kerf ?? 0;\n  const showLabels = options?.showLabels ?? true;\n\n  if (!options.bedWidth || !options.bedHeight) {\n    // No bed size - return single auto-packed SVG\n    return [generateAllPanelPathsSVG(collection, kerf, options)];\n  }\n\n  const beds = packPanelsIntoBeds(\n    collection.panels,\n    options.bedWidth,\n    options.bedHeight,\n    gap,\n    allowRotation,\n    showLabels\n  );\n\n  return beds.map((bed, i) => generatePackedBedSVG(bed, i, beds.length, kerf, showLabels));\n};\n\n// =============================================================================\n// Legacy SVG generation (computes paths on-the-fly)\n// These functions are kept for backwards compatibility\n// =============================================================================\n\ninterface FaceDimensions {\n  width: number;\n  height: number;\n}\n\nexport const getFaceDimensions = (\n  faceId: FaceId,\n  config: BoxConfig\n): FaceDimensions => {\n  switch (faceId) {\n    case 'front':\n    case 'back':\n      return { width: config.width, height: config.height };\n    case 'left':\n    case 'right':\n      return { width: config.depth, height: config.height };\n    case 'top':\n    case 'bottom':\n      return { width: config.width, height: config.depth };\n  }\n};\n\ninterface EdgeInfo {\n  adjacentFaceId: FaceId;\n  isHorizontal: boolean;\n  position: 'top' | 'bottom' | 'left' | 'right';\n}\n\nconst getFaceEdges = (faceId: FaceId): EdgeInfo[] => {\n  switch (faceId) {\n    case 'front':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'right' },\n      ];\n    case 'back':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'right' },\n      ];\n    case 'left':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'back', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'front', isHorizontal: false, position: 'right' },\n      ];\n    case 'right':\n      return [\n        { adjacentFaceId: 'top', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'bottom', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'front', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'back', isHorizontal: false, position: 'right' },\n      ];\n    case 'top':\n      return [\n        { adjacentFaceId: 'back', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'front', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'right' },\n      ];\n    case 'bottom':\n      return [\n        { adjacentFaceId: 'front', isHorizontal: true, position: 'top' },\n        { adjacentFaceId: 'back', isHorizontal: true, position: 'bottom' },\n        { adjacentFaceId: 'left', isHorizontal: false, position: 'left' },\n        { adjacentFaceId: 'right', isHorizontal: false, position: 'right' },\n      ];\n  }\n};\n\n// Dynamic tab direction logic based on assembly configuration\n// Returns true if this face should have tabs extending outward at the edge meeting adjacentFaceId\n// Returns null if the edge should be straight (no finger joint) - e.g., wall edges for inset lids\nconst shouldTabOut = (\n  faceId: FaceId,\n  adjacentFaceId: FaceId,\n  assembly: AssemblyConfig\n): boolean | null => {\n  const myRole = getFaceRole(faceId, assembly.assemblyAxis);\n  const adjRole = getFaceRole(adjacentFaceId, assembly.assemblyAxis);\n\n  // Wall-to-Wall: use priority system (lower priority tabs OUT)\n  if (myRole === 'wall' && adjRole === 'wall') {\n    return getWallPriority(faceId) < getWallPriority(adjacentFaceId);\n  }\n\n  // Lid-to-Wall interactions\n  if (myRole === 'lid') {\n    const side = getLidSide(faceId, assembly.assemblyAxis);\n    if (side) {\n      // Inset lids still have tabs (like dividers) that fit into wall slot holes\n      return assembly.lids[side].tabDirection === 'tabs-out';\n    }\n    return false;\n  }\n\n  // Wall-to-Lid interactions\n  if (adjRole === 'lid') {\n    const side = getLidSide(adjacentFaceId, assembly.assemblyAxis);\n    if (side) {\n      // If lid is inset, wall edge should be straight (no fingers)\n      // Wall will have slot holes for the inset lid's tabs instead\n      if (assembly.lids[side].inset > 0) {\n        return null;  // Straight edge, no fingers - slots are cut as holes\n      }\n      return assembly.lids[side].tabDirection === 'tabs-in';\n    }\n    return false;\n  }\n\n  return false;\n};\n\nexport const generateFaceSVGPath = (\n  faceId: FaceId,\n  faces: Face[],\n  config: BoxConfig,\n  kerf: number = 0\n): string => {\n  const face = faces.find((f) => f.id === faceId);\n  if (!face || !face.solid) return '';\n\n  const dims = getFaceDimensions(faceId, config);\n  const edges = getFaceEdges(faceId);\n  const padding = config.materialThickness * 2;\n\n  const corners: Record<string, Point> = {\n    topLeft: { x: padding, y: padding },\n    topRight: { x: padding + dims.width, y: padding },\n    bottomRight: { x: padding + dims.width, y: padding + dims.height },\n    bottomLeft: { x: padding, y: padding + dims.height },\n  };\n\n  const edgeConfigs: { start: Point; end: Point; edgeInfo: EdgeInfo }[] = [\n    { start: corners.topLeft, end: corners.topRight, edgeInfo: edges.find((e) => e.position === 'top')! },\n    { start: corners.topRight, end: corners.bottomRight, edgeInfo: edges.find((e) => e.position === 'right')! },\n    { start: corners.bottomRight, end: corners.bottomLeft, edgeInfo: edges.find((e) => e.position === 'bottom')! },\n    { start: corners.bottomLeft, end: corners.topLeft, edgeInfo: edges.find((e) => e.position === 'left')! },\n  ];\n\n  let pathData = '';\n  let isFirst = true;\n\n  for (const { start, end, edgeInfo } of edgeConfigs) {\n    const adjacentFace = faces.find((f) => f.id === edgeInfo.adjacentFaceId);\n    const isSolidAdjacent = adjacentFace?.solid ?? false;\n\n    let edgeType: EdgeType = 'straight';\n    if (isSolidAdjacent) {\n      const tabOutResult = shouldTabOut(faceId, edgeInfo.adjacentFaceId, config.assembly);\n      // tabOutResult === null means straight edge (for inset lids)\n      if (tabOutResult !== null) {\n        edgeType = tabOutResult ? 'finger-out' : 'finger-in';\n      }\n    }\n\n    const points = getEdgePath(start, end, edgeType, {\n      edgeLength: Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)),\n      fingerWidth: config.fingerWidth,\n      materialThickness: config.materialThickness,\n      kerf,\n      cornerGapMultiplier: config.fingerGap,\n    });\n\n    for (let i = 0; i < points.length; i++) {\n      const pt = points[i];\n      if (isFirst && i === 0) {\n        pathData += `M ${pt.x.toFixed(3)} ${pt.y.toFixed(3)} `;\n        isFirst = false;\n      } else {\n        pathData += `L ${pt.x.toFixed(3)} ${pt.y.toFixed(3)} `;\n      }\n    }\n  }\n\n  pathData += 'Z';\n  return pathData;\n};\n\n// Calculate subdivision panels from hierarchical void structure\nexport const getSubdivisionPanels = (\n  rootVoid: Void,\n  faces: Face[],\n  config: BoxConfig\n): SubdivisionPanel[] => {\n  const subdivisions = getAllSubdivisions(rootVoid);\n  const panels: SubdivisionPanel[] = [];\n  const isFaceSolid = (faceId: FaceId) => faces.find(f => f.id === faceId)?.solid ?? false;\n\n  for (const sub of subdivisions) {\n    let width: number;\n    let height: number;\n    let meetsTop: boolean;\n    let meetsBottom: boolean;\n    let meetsLeft: boolean;\n    let meetsRight: boolean;\n\n    const { bounds } = sub;\n\n    // Panel dimensions based on the parent void's bounds at the split point\n    switch (sub.axis) {\n      case 'x':\n        // X-axis subdivision: panel is parallel to YZ plane\n        width = bounds.d;\n        height = bounds.h;\n        meetsTop = isFaceSolid('top') && bounds.y + bounds.h >= config.height - 0.01;\n        meetsBottom = isFaceSolid('bottom') && bounds.y <= 0.01;\n        meetsLeft = isFaceSolid('back') && bounds.z <= 0.01;\n        meetsRight = isFaceSolid('front') && bounds.z + bounds.d >= config.depth - 0.01;\n        break;\n      case 'y':\n        // Y-axis subdivision: panel is parallel to XZ plane\n        width = bounds.w;\n        height = bounds.d;\n        meetsTop = isFaceSolid('back') && bounds.z <= 0.01;\n        meetsBottom = isFaceSolid('front') && bounds.z + bounds.d >= config.depth - 0.01;\n        meetsLeft = isFaceSolid('left') && bounds.x <= 0.01;\n        meetsRight = isFaceSolid('right') && bounds.x + bounds.w >= config.width - 0.01;\n        break;\n      case 'z':\n        // Z-axis subdivision: panel is parallel to XY plane\n        width = bounds.w;\n        height = bounds.h;\n        meetsTop = isFaceSolid('top') && bounds.y + bounds.h >= config.height - 0.01;\n        meetsBottom = isFaceSolid('bottom') && bounds.y <= 0.01;\n        meetsLeft = isFaceSolid('left') && bounds.x <= 0.01;\n        meetsRight = isFaceSolid('right') && bounds.x + bounds.w >= config.width - 0.01;\n        break;\n    }\n\n    // Find intersecting subdivisions\n    const intersections: SubdivisionIntersection[] = [];\n    for (const other of subdivisions) {\n      if (other.id === sub.id) continue;\n\n      // Check if they intersect based on their bounds and axes\n      if (sub.axis !== other.axis && boundsOverlap(sub.bounds, other.bounds)) {\n        const intersection = calculateIntersection(sub, other);\n        if (intersection) {\n          intersections.push(intersection);\n        }\n      }\n    }\n\n    panels.push({\n      id: sub.id,\n      axis: sub.axis,\n      position: sub.position,\n      parentBounds: sub.bounds,\n      width,\n      height,\n      meetsTop,\n      meetsBottom,\n      meetsLeft,\n      meetsRight,\n      intersections,\n    });\n  }\n\n  return panels;\n};\n\nconst boundsOverlap = (a: Bounds, b: Bounds): boolean => {\n  return (\n    a.x < b.x + b.w && a.x + a.w > b.x &&\n    a.y < b.y + b.h && a.y + a.h > b.y &&\n    a.z < b.z + b.d && a.z + a.d > b.z\n  );\n};\n\nconst calculateIntersection = (\n  sub: Subdivision,\n  other: Subdivision\n): SubdivisionIntersection | null => {\n  // Calculate where the other subdivision crosses this one\n  let position: number;\n  let fromTop: boolean;\n\n  if (sub.axis === 'x') {\n    if (other.axis === 'y') {\n      // Y panel crosses X panel - position along depth\n      position = other.position - sub.bounds.z;\n      fromTop = true;\n    } else {\n      // Z panel crosses X panel\n      position = other.position - sub.bounds.z;\n      fromTop = false;\n    }\n  } else if (sub.axis === 'y') {\n    if (other.axis === 'x') {\n      // X panel crosses Y panel - position along width\n      position = other.position - sub.bounds.x;\n      fromTop = false;\n    } else {\n      // Z panel crosses Y panel\n      position = other.position - sub.bounds.z;\n      fromTop = true;\n    }\n  } else {\n    // sub.axis === 'z'\n    if (other.axis === 'x') {\n      // X panel crosses Z panel\n      position = other.position - sub.bounds.x;\n      fromTop = true;\n    } else {\n      // Y panel crosses Z panel\n      position = other.position - sub.bounds.y;\n      fromTop = false;\n    }\n  }\n\n  // Check if intersection is within the panel bounds\n  if (position < 0 || position > getSubdivisionWidth(sub)) {\n    return null;\n  }\n\n  return {\n    subdivisionId: other.id,\n    axis: other.axis,\n    position,\n    fromTop,\n  };\n};\n\nconst getSubdivisionWidth = (sub: Subdivision): number => {\n  switch (sub.axis) {\n    case 'x': return sub.bounds.d;\n    case 'y': return sub.bounds.w;\n    case 'z': return sub.bounds.w;\n  }\n};\n\n// Generate SVG path for a subdivision panel\nexport const generateSubdivisionPanelPath = (\n  panel: SubdivisionPanel,\n  config: BoxConfig,\n  kerf: number = 0\n): string => {\n  const padding = config.materialThickness * 2;\n  const { width, height, meetsTop, meetsBottom, meetsLeft, meetsRight } = panel;\n\n  const corners: Record<string, Point> = {\n    topLeft: { x: padding, y: padding },\n    topRight: { x: padding + width, y: padding },\n    bottomRight: { x: padding + width, y: padding + height },\n    bottomLeft: { x: padding, y: padding + height },\n  };\n\n  const edgeConfigs: { start: Point; end: Point; hasFinger: boolean }[] = [\n    { start: corners.topLeft, end: corners.topRight, hasFinger: meetsTop },\n    { start: corners.topRight, end: corners.bottomRight, hasFinger: meetsRight },\n    { start: corners.bottomRight, end: corners.bottomLeft, hasFinger: meetsBottom },\n    { start: corners.bottomLeft, end: corners.topLeft, hasFinger: meetsLeft },\n  ];\n\n  let pathData = '';\n  let isFirst = true;\n\n  for (const { start, end, hasFinger } of edgeConfigs) {\n    const edgeType: EdgeType = hasFinger ? 'finger-out' : 'straight';\n\n    const points = getEdgePath(start, end, edgeType, {\n      edgeLength: Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)),\n      fingerWidth: config.fingerWidth,\n      materialThickness: config.materialThickness,\n      kerf,\n      cornerGapMultiplier: config.fingerGap,\n    });\n\n    for (let i = 0; i < points.length; i++) {\n      const pt = points[i];\n      if (isFirst && i === 0) {\n        pathData += `M ${pt.x.toFixed(3)} ${pt.y.toFixed(3)} `;\n        isFirst = false;\n      } else {\n        pathData += `L ${pt.x.toFixed(3)} ${pt.y.toFixed(3)} `;\n      }\n    }\n  }\n\n  pathData += 'Z';\n  return pathData;\n};\n\n// Generate slot paths for intersecting subdivisions\nexport const generateSlotPaths = (\n  panel: SubdivisionPanel,\n  config: BoxConfig\n): string[] => {\n  const paths: string[] = [];\n  const padding = config.materialThickness * 2;\n  const mt = config.materialThickness;\n  const slotDepth = panel.height / 2 + 0.5;\n\n  for (const intersection of panel.intersections) {\n    const slotX = padding + intersection.position;\n    const slotWidth = mt;\n\n    if (slotX < padding || slotX > padding + panel.width) continue;\n\n    let slotPath: string;\n    if (intersection.fromTop) {\n      slotPath = `M ${(slotX - slotWidth / 2).toFixed(3)} ${padding.toFixed(3)} `;\n      slotPath += `L ${(slotX - slotWidth / 2).toFixed(3)} ${(padding + slotDepth).toFixed(3)} `;\n      slotPath += `L ${(slotX + slotWidth / 2).toFixed(3)} ${(padding + slotDepth).toFixed(3)} `;\n      slotPath += `L ${(slotX + slotWidth / 2).toFixed(3)} ${padding.toFixed(3)}`;\n    } else {\n      const bottomY = padding + panel.height;\n      slotPath = `M ${(slotX - slotWidth / 2).toFixed(3)} ${bottomY.toFixed(3)} `;\n      slotPath += `L ${(slotX - slotWidth / 2).toFixed(3)} ${(bottomY - slotDepth).toFixed(3)} `;\n      slotPath += `L ${(slotX + slotWidth / 2).toFixed(3)} ${(bottomY - slotDepth).toFixed(3)} `;\n      slotPath += `L ${(slotX + slotWidth / 2).toFixed(3)} ${bottomY.toFixed(3)}`;\n    }\n\n    paths.push(slotPath);\n  }\n\n  return paths;\n};\n\n// Generate complete SVG for a subdivision panel\nexport const generateSubdivisionPanelSVG = (\n  panel: SubdivisionPanel,\n  config: BoxConfig,\n  kerf: number = 0\n): string => {\n  const padding = config.materialThickness * 4;\n  const svgWidth = panel.width + padding * 2;\n  const svgHeight = panel.height + padding * 2;\n\n  const outlinePath = generateSubdivisionPanelPath(panel, config, kerf);\n  const slotPaths = generateSlotPaths(panel, config);\n\n  const axisLabel = panel.axis.toUpperCase();\n  const posLabel = panel.position.toFixed(1);\n\n  let svg = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"${svgWidth}mm\"\n     height=\"${svgHeight}mm\"\n     viewBox=\"0 0 ${svgWidth} ${svgHeight}\">\n  <title>Subdivision ${axisLabel} @ ${posLabel}mm</title>\n  <g stroke=\"#000\" stroke-width=\"0.1\" fill=\"none\">\n    <path d=\"${outlinePath}\" />\n`;\n\n  for (const slotPath of slotPaths) {\n    svg += `    <path d=\"${slotPath}\" stroke=\"#000\" fill=\"none\" />\\n`;\n  }\n\n  svg += `  </g>\n  <text x=\"${svgWidth / 2}\" y=\"${svgHeight - 2}\"\n        text-anchor=\"middle\" font-size=\"3\" fill=\"red\" stroke=\"red\">\n    DIV-${axisLabel}@${posLabel}mm - ${panel.width.toFixed(1)}mm x ${panel.height.toFixed(1)}mm\n  </text>\n</svg>`;\n\n  return svg;\n};\n\n// Generate slot paths on outer faces where subdivision panels meet them\nexport const generateFaceSlotPaths = (\n  faceId: FaceId,\n  rootVoid: Void,\n  config: BoxConfig\n): string[] => {\n  const paths: string[] = [];\n  const dims = getFaceDimensions(faceId, config);\n  const padding = config.materialThickness * 2;\n  const mt = config.materialThickness;\n  const fingerWidth = config.fingerWidth;\n\n  const subdivisions = getAllSubdivisions(rootVoid);\n\n  for (const sub of subdivisions) {\n    let slotX: number | null = null;\n    let slotY: number | null = null;\n    let slotLength: number = 0;\n\n    // Check if this subdivision touches this face\n    const { bounds, position, axis } = sub;\n\n    switch (faceId) {\n      case 'front':\n        if (bounds.z + bounds.d >= config.depth - 0.01) {\n          if (axis === 'x') {\n            slotX = padding + position;\n            slotLength = bounds.h;\n          } else if (axis === 'y') {\n            slotY = padding + position;\n            slotLength = bounds.w;\n          }\n        }\n        break;\n      case 'back':\n        if (bounds.z <= 0.01) {\n          if (axis === 'x') {\n            slotX = padding + (config.width - position);\n            slotLength = bounds.h;\n          } else if (axis === 'y') {\n            slotY = padding + position;\n            slotLength = bounds.w;\n          }\n        }\n        break;\n      case 'left':\n        if (bounds.x <= 0.01) {\n          if (axis === 'z') {\n            slotX = padding + position;\n            slotLength = bounds.h;\n          } else if (axis === 'y') {\n            slotY = padding + position;\n            slotLength = bounds.d;\n          }\n        }\n        break;\n      case 'right':\n        if (bounds.x + bounds.w >= config.width - 0.01) {\n          if (axis === 'z') {\n            slotX = padding + (config.depth - position);\n            slotLength = bounds.h;\n          } else if (axis === 'y') {\n            slotY = padding + position;\n            slotLength = bounds.d;\n          }\n        }\n        break;\n      case 'top':\n        if (bounds.y + bounds.h >= config.height - 0.01) {\n          if (axis === 'x') {\n            slotX = padding + position;\n            slotLength = bounds.d;\n          } else if (axis === 'z') {\n            slotY = padding + position;\n            slotLength = bounds.w;\n          }\n        }\n        break;\n      case 'bottom':\n        if (bounds.y <= 0.01) {\n          if (axis === 'x') {\n            slotX = padding + position;\n            slotLength = bounds.d;\n          } else if (axis === 'z') {\n            slotY = padding + (config.depth - position);\n            slotLength = bounds.w;\n          }\n        }\n        break;\n    }\n\n    // Generate finger joint slots\n    if (slotX !== null) {\n      const numFingers = Math.max(1, Math.floor(slotLength / fingerWidth));\n      const actualFingerWidth = slotLength / numFingers;\n\n      for (let i = 0; i < numFingers; i++) {\n        if (i % 2 === 0) {\n          const y1 = padding + i * actualFingerWidth;\n          const y2 = padding + (i + 1) * actualFingerWidth;\n          const path = `M ${(slotX - mt / 2).toFixed(3)} ${y1.toFixed(3)} ` +\n            `L ${(slotX - mt / 2).toFixed(3)} ${y2.toFixed(3)} ` +\n            `L ${(slotX + mt / 2).toFixed(3)} ${y2.toFixed(3)} ` +\n            `L ${(slotX + mt / 2).toFixed(3)} ${y1.toFixed(3)} Z`;\n          paths.push(path);\n        }\n      }\n    } else if (slotY !== null) {\n      const numFingers = Math.max(1, Math.floor(slotLength / fingerWidth));\n      const actualFingerWidth = slotLength / numFingers;\n\n      for (let i = 0; i < numFingers; i++) {\n        if (i % 2 === 0) {\n          const x1 = padding + i * actualFingerWidth;\n          const x2 = padding + (i + 1) * actualFingerWidth;\n          const path = `M ${x1.toFixed(3)} ${(slotY - mt / 2).toFixed(3)} ` +\n            `L ${x2.toFixed(3)} ${(slotY - mt / 2).toFixed(3)} ` +\n            `L ${x2.toFixed(3)} ${(slotY + mt / 2).toFixed(3)} ` +\n            `L ${x1.toFixed(3)} ${(slotY + mt / 2).toFixed(3)} Z`;\n          paths.push(path);\n        }\n      }\n    }\n  }\n\n  return paths;\n};\n\n// Generate slot paths for lid tabs on wall faces (when lids have tabs-out)\nexport const generateLidSlotPaths = (\n  faceId: FaceId,\n  config: BoxConfig\n): string[] => {\n  const paths: string[] = [];\n  const { assembly, materialThickness, fingerWidth, width, height, depth } = config;\n  const padding = materialThickness * 2;\n\n  // Only walls get slots for lid tabs\n  if (getFaceRole(faceId, assembly.assemblyAxis) !== 'wall') return [];\n\n  // Check each lid\n  for (const side of ['positive', 'negative'] as const) {\n    const lidConfig = assembly.lids[side];\n\n    // Only process if lid has tabs-out\n    if (lidConfig.tabDirection !== 'tabs-out') continue;\n\n    // For SVG export, we assume the lid face exists (caller should check)\n\n    let slotPosition: number;  // Position in SVG coordinates\n    let slotLength: number;\n    let isHorizontal: boolean;\n\n    // Determine slot position based on assembly axis and face\n    switch (assembly.assemblyAxis) {\n      case 'y':\n        // Top/bottom are lids - walls get horizontal slots at top/bottom\n        if (side === 'positive') {\n          // Top lid - slot near top of wall\n          slotPosition = padding + materialThickness / 2 + lidConfig.inset;\n        } else {\n          // Bottom lid - slot near bottom of wall\n          const faceHeight = (faceId === 'front' || faceId === 'back') ? height : height;\n          slotPosition = padding + faceHeight - materialThickness / 2 - lidConfig.inset;\n        }\n        isHorizontal = true;\n        slotLength = (faceId === 'front' || faceId === 'back') ? width : depth;\n        break;\n\n      case 'x':\n        // Left/right are lids - walls get vertical slots at left/right\n        if (side === 'positive') {\n          // Right lid - slot near right of wall\n          const faceWidth = (faceId === 'front' || faceId === 'back') ? width : depth;\n          slotPosition = padding + faceWidth - materialThickness / 2 - lidConfig.inset;\n        } else {\n          // Left lid - slot near left of wall\n          slotPosition = padding + materialThickness / 2 + lidConfig.inset;\n        }\n        isHorizontal = false;\n        slotLength = (faceId === 'front' || faceId === 'back') ? height : height;\n        break;\n\n      case 'z':\n        // Front/back are lids - walls get vertical slots at front/back\n        if (faceId === 'left' || faceId === 'right') {\n          const faceWidth = depth;\n          if (side === 'positive') {\n            // Front lid\n            slotPosition = padding + faceWidth - materialThickness / 2 - lidConfig.inset;\n          } else {\n            // Back lid\n            slotPosition = padding + materialThickness / 2 + lidConfig.inset;\n          }\n          isHorizontal = false;\n          slotLength = height;\n        } else {\n          // top/bottom\n          const faceHeight = depth;\n          if (side === 'positive') {\n            slotPosition = padding + faceHeight - materialThickness / 2 - lidConfig.inset;\n          } else {\n            slotPosition = padding + materialThickness / 2 + lidConfig.inset;\n          }\n          isHorizontal = true;\n          slotLength = width;\n        }\n        break;\n\n      default:\n        continue;\n    }\n\n    // Generate finger slots\n    const numFingers = Math.max(1, Math.floor(slotLength / fingerWidth));\n    const actualFingerWidth = slotLength / numFingers;\n\n    for (let i = 0; i < numFingers; i++) {\n      if (i % 2 === 0) {  // Only even positions have tabs\n        if (isHorizontal) {\n          const x1 = padding + i * actualFingerWidth;\n          const x2 = padding + (i + 1) * actualFingerWidth;\n          const path = `M ${x1.toFixed(3)} ${(slotPosition - materialThickness / 2).toFixed(3)} ` +\n            `L ${x2.toFixed(3)} ${(slotPosition - materialThickness / 2).toFixed(3)} ` +\n            `L ${x2.toFixed(3)} ${(slotPosition + materialThickness / 2).toFixed(3)} ` +\n            `L ${x1.toFixed(3)} ${(slotPosition + materialThickness / 2).toFixed(3)} Z`;\n          paths.push(path);\n        } else {\n          const y1 = padding + i * actualFingerWidth;\n          const y2 = padding + (i + 1) * actualFingerWidth;\n          const path = `M ${(slotPosition - materialThickness / 2).toFixed(3)} ${y1.toFixed(3)} ` +\n            `L ${(slotPosition - materialThickness / 2).toFixed(3)} ${y2.toFixed(3)} ` +\n            `L ${(slotPosition + materialThickness / 2).toFixed(3)} ${y2.toFixed(3)} ` +\n            `L ${(slotPosition + materialThickness / 2).toFixed(3)} ${y1.toFixed(3)} Z`;\n          paths.push(path);\n        }\n      }\n    }\n  }\n\n  return paths;\n};\n\nexport const generateFaceSVG = (\n  faceId: FaceId,\n  faces: Face[],\n  rootVoid: Void,\n  config: BoxConfig,\n  kerf: number = 0\n): string => {\n  const face = faces.find((f) => f.id === faceId);\n  if (!face || !face.solid) return '';\n\n  const dims = getFaceDimensions(faceId, config);\n  const padding = config.materialThickness * 4;\n  const svgWidth = dims.width + padding * 2;\n  const svgHeight = dims.height + padding * 2;\n\n  const outlinePath = generateFaceSVGPath(faceId, faces, config, kerf);\n  const dividerSlotPaths = generateFaceSlotPaths(faceId, rootVoid, config);\n  const lidSlotPaths = generateLidSlotPaths(faceId, config);\n  const allSlotPaths = [...dividerSlotPaths, ...lidSlotPaths];\n\n  let svg = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"${svgWidth}mm\"\n     height=\"${svgHeight}mm\"\n     viewBox=\"0 0 ${svgWidth} ${svgHeight}\">\n  <title>${faceId} face</title>\n  <g stroke=\"#000\" stroke-width=\"0.1\" fill=\"none\">\n    <path d=\"${outlinePath}\" />\n`;\n\n  for (const slotPath of allSlotPaths) {\n    svg += `    <path d=\"${slotPath}\" stroke=\"#000\" fill=\"none\" />\\n`;\n  }\n\n  svg += `  </g>\n  <text x=\"${svgWidth / 2}\" y=\"${svgHeight - 2}\"\n        text-anchor=\"middle\" font-size=\"3\" fill=\"red\" stroke=\"red\">\n    ${faceId.toUpperCase()} - ${dims.width}mm x ${dims.height}mm\n  </text>\n</svg>`;\n\n  return svg;\n};\n\nexport const generateAllFacesSVG = (\n  faces: Face[],\n  rootVoid: Void,\n  config: BoxConfig,\n  kerf: number = 0\n): string => {\n  const solidFaces = faces.filter((f) => f.solid);\n  const panels = getSubdivisionPanels(rootVoid, faces, config);\n  const gap = 10;\n  let currentY = gap;\n  let maxWidth = 0;\n\n  interface SvgItem {\n    label: string;\n    pathData: string;\n    slotPaths: string[];\n    width: number;\n    height: number;\n    y: number;\n    dims: { width: number; height: number };\n  }\n\n  const svgItems: SvgItem[] = [];\n\n  // Add outer faces\n  for (const face of solidFaces) {\n    const dims = getFaceDimensions(face.id, config);\n    const padding = config.materialThickness * 4;\n    const width = dims.width + padding * 2;\n    const height = dims.height + padding * 2;\n\n    const dividerSlots = generateFaceSlotPaths(face.id, rootVoid, config);\n    const lidSlots = generateLidSlotPaths(face.id, config);\n    svgItems.push({\n      label: face.id.toUpperCase(),\n      pathData: generateFaceSVGPath(face.id, faces, config, kerf),\n      slotPaths: [...dividerSlots, ...lidSlots],\n      width,\n      height,\n      y: currentY,\n      dims,\n    });\n\n    maxWidth = Math.max(maxWidth, width);\n    currentY += height + gap;\n  }\n\n  // Add subdivision panels\n  for (const panel of panels) {\n    const padding = config.materialThickness * 4;\n    const width = panel.width + padding * 2;\n    const height = panel.height + padding * 2;\n\n    svgItems.push({\n      label: `DIV-${panel.axis.toUpperCase()}@${panel.position.toFixed(1)}mm`,\n      pathData: generateSubdivisionPanelPath(panel, config, kerf),\n      slotPaths: generateSlotPaths(panel, config),\n      width,\n      height,\n      y: currentY,\n      dims: { width: panel.width, height: panel.height },\n    });\n\n    maxWidth = Math.max(maxWidth, width);\n    currentY += height + gap;\n  }\n\n  const totalHeight = currentY;\n\n  let svg = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"${maxWidth + gap * 2}mm\"\n     height=\"${totalHeight}mm\"\n     viewBox=\"0 0 ${maxWidth + gap * 2} ${totalHeight}\">\n  <title>Boxen Export - All Pieces</title>\n`;\n\n  for (const item of svgItems) {\n    const x = (maxWidth - item.width) / 2 + gap;\n\n    svg += `  <g transform=\"translate(${x}, ${item.y})\" stroke=\"#000\" stroke-width=\"0.1\" fill=\"none\">\n    <path d=\"${item.pathData}\" />\n`;\n\n    for (const slotPath of item.slotPaths) {\n      svg += `    <path d=\"${slotPath}\" />\\n`;\n    }\n\n    svg += `    <text x=\"${item.width / 2}\" y=\"${item.height - 2}\"\n          text-anchor=\"middle\" font-size=\"3\" fill=\"red\" stroke=\"red\">\n      ${item.label} - ${item.dims.width.toFixed(1)}mm x ${item.dims.height.toFixed(1)}mm\n    </text>\n  </g>\n`;\n  }\n\n  svg += '</svg>';\n  return svg;\n};\n\nexport const downloadSVG = (svgContent: string, filename: string) => {\n  const blob = new Blob([svgContent], { type: 'image/svg+xml' });\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n};\n","import React, { useState } from 'react';\nimport { useBoxStore } from '../store/useBoxStore';\nimport { Modal } from './UI/Modal';\nimport { NumberInput } from './UI/NumberInput';\nimport { FaceId, PanelPath } from '../types';\nimport {\n  generatePanelPathSVG,\n  generateAllPanelPathsSVG,\n  generateMultipleBedSVGs,\n  downloadSVG,\n  BedExportOptions,\n} from '../utils/svgExport';\n\nconst faceOrder: FaceId[] = ['front', 'back', 'left', 'right', 'top', 'bottom'];\n\n// Common laser cutter bed sizes (in mm)\nconst PRESET_BED_SIZES = [\n  { label: 'Auto (no limit)', width: 0, height: 0 },\n  { label: 'K40 (300 x 200)', width: 300, height: 200 },\n  { label: 'Glowforge (495 x 279)', width: 495, height: 279 },\n  { label: 'Full Sheet (600 x 400)', width: 600, height: 400 },\n  { label: 'Custom', width: -1, height: -1 },\n];\n\ninterface ExportModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\nexport const ExportModal: React.FC<ExportModalProps> = ({ isOpen, onClose }) => {\n  const { faces, panelCollection } = useBoxStore();\n  const [kerf, setKerf] = useState(0.1);\n  const [bedPreset, setBedPreset] = useState(0); // Index into PRESET_BED_SIZES\n  const [customBedWidth, setCustomBedWidth] = useState(300);\n  const [customBedHeight, setCustomBedHeight] = useState(200);\n  const [allowRotation, setAllowRotation] = useState(true);\n  const [gap, setGap] = useState(5);\n  const [showLabels, setShowLabels] = useState(true);\n  const [separateFiles, setSeparateFiles] = useState(false);\n\n  // Get panels from stored collection\n  const panels = panelCollection?.panels ?? [];\n  const facePanels = panels.filter(p => p.source.type === 'face');\n  const dividerPanels = panels.filter(p => p.source.type === 'divider');\n\n  const totalPieces = panels.filter(p => p.visible).length;\n\n  const handleExportPanel = (panel: PanelPath) => {\n    const svg = generatePanelPathSVG(panel, kerf);\n    if (svg) {\n      const filename = panel.source.type === 'face'\n        ? `boxen-${panel.source.faceId}.svg`\n        : `boxen-${panel.id}.svg`;\n      downloadSVG(svg, filename);\n    }\n  };\n\n  // Get current bed dimensions\n  const getBedDimensions = (): { width?: number; height?: number } => {\n    const preset = PRESET_BED_SIZES[bedPreset];\n    if (preset.width === 0) {\n      // Auto - no bed size limit\n      return {};\n    }\n    if (preset.width === -1) {\n      // Custom\n      return { width: customBedWidth, height: customBedHeight };\n    }\n    return { width: preset.width, height: preset.height };\n  };\n\n  const handleExportAll = () => {\n    if (!panelCollection) return;\n\n    const bedDims = getBedDimensions();\n    const options: BedExportOptions = {\n      bedWidth: bedDims.width,\n      bedHeight: bedDims.height,\n      gap,\n      allowRotation,\n      kerf,\n      showLabels,\n    };\n\n    if (separateFiles && bedDims.width && bedDims.height) {\n      // Export as separate SVG files per bed\n      const svgs = generateMultipleBedSVGs(panelCollection, options);\n      if (svgs.length === 1) {\n        downloadSVG(svgs[0], 'boxen-all-pieces.svg');\n      } else {\n        svgs.forEach((svg, i) => {\n          downloadSVG(svg, `boxen-bed-${i + 1}.svg`);\n        });\n      }\n    } else {\n      // Default: single SVG with all beds as groups\n      const svg = generateAllPanelPathsSVG(panelCollection, kerf, options);\n      downloadSVG(svg, 'boxen-all-pieces.svg');\n    }\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} title=\"Export SVG\">\n      <div className=\"export-modal-content\">\n        <div className=\"export-controls\">\n          <div className=\"export-settings\">\n            <div className=\"export-setting-row\">\n              <label>\n                <span>Bed Size:</span>\n                <select\n                  value={bedPreset}\n                  onChange={(e) => setBedPreset(parseInt(e.target.value))}\n                >\n                  {PRESET_BED_SIZES.map((preset, i) => (\n                    <option key={i} value={i}>{preset.label}</option>\n                  ))}\n                </select>\n              </label>\n            </div>\n\n            {bedPreset === PRESET_BED_SIZES.length - 1 && (\n              <div className=\"export-setting-row custom-bed-size\">\n                <label>\n                  <span>Width (mm):</span>\n                  <NumberInput\n                    value={customBedWidth}\n                    onChange={setCustomBedWidth}\n                    min={50}\n                    step={10}\n                  />\n                </label>\n                <label>\n                  <span>Height (mm):</span>\n                  <NumberInput\n                    value={customBedHeight}\n                    onChange={setCustomBedHeight}\n                    min={50}\n                    step={10}\n                  />\n                </label>\n              </div>\n            )}\n\n            <div className=\"export-setting-row\">\n              <label>\n                <span>Gap between pieces (mm):</span>\n                <NumberInput\n                  value={gap}\n                  onChange={setGap}\n                  min={0}\n                  step={1}\n                />\n              </label>\n            </div>\n\n            <div className=\"export-setting-row\">\n              <label className=\"checkbox-label\">\n                <input\n                  type=\"checkbox\"\n                  checked={allowRotation}\n                  onChange={(e) => setAllowRotation(e.target.checked)}\n                />\n                <span>Allow rotation for better packing</span>\n              </label>\n            </div>\n\n            <div className=\"export-setting-row\">\n              <label className=\"checkbox-label\">\n                <input\n                  type=\"checkbox\"\n                  checked={showLabels}\n                  onChange={(e) => setShowLabels(e.target.checked)}\n                />\n                <span>Show panel labels</span>\n              </label>\n            </div>\n\n            {bedPreset !== 0 && (\n              <div className=\"export-setting-row\">\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={separateFiles}\n                    onChange={(e) => setSeparateFiles(e.target.checked)}\n                  />\n                  <span>Export beds as separate files</span>\n                </label>\n              </div>\n            )}\n\n            <div className=\"export-setting-row\">\n              <label>\n                <span>Kerf compensation (mm):</span>\n                <NumberInput\n                  value={kerf}\n                  onChange={setKerf}\n                  min={0}\n                  step={0.01}\n                />\n              </label>\n            </div>\n          </div>\n\n          <div className=\"export-section\">\n            <h4>Outer Faces ({facePanels.length})</h4>\n            <div className=\"export-buttons\">\n              {faceOrder.map((faceId) => {\n                const face = faces.find((f) => f.id === faceId);\n                const isSolid = face?.solid ?? true;\n                const facePanel = facePanels.find(\n                  p => p.source.type === 'face' && p.source.faceId === faceId\n                );\n                return (\n                  <button\n                    key={faceId}\n                    onClick={() => facePanel && handleExportPanel(facePanel)}\n                    disabled={!isSolid || !facePanel}\n                    title={isSolid ? `Export ${faceId} face` : `${faceId} face is open`}\n                  >\n                    {faceId.charAt(0).toUpperCase() + faceId.slice(1)}\n                  </button>\n                );\n              })}\n            </div>\n          </div>\n\n          {dividerPanels.length > 0 && (\n            <div className=\"export-section\">\n              <h4>Subdivision Panels ({dividerPanels.length})</h4>\n              <div className=\"export-buttons\">\n                {dividerPanels.map((panel) => {\n                  const label = panel.source.type === 'divider'\n                    ? `${panel.source.axis?.toUpperCase()}@${panel.label?.split('@')[1]?.split('mm')[0] ?? '?'}`\n                    : panel.id;\n                  return (\n                    <button\n                      key={panel.id}\n                      onClick={() => handleExportPanel(panel)}\n                      title={`Export ${panel.label || panel.id}`}\n                    >\n                      {label}\n                    </button>\n                  );\n                })}\n              </div>\n            </div>\n          )}\n\n          <div className=\"export-section export-all-section\">\n            <button\n              className=\"export-all-btn\"\n              onClick={handleExportAll}\n              disabled={totalPieces === 0}\n            >\n              Download All Pieces ({totalPieces})\n            </button>\n          </div>\n\n          <div className=\"export-info\">\n            <p>SVG files include:</p>\n            <ul>\n              <li>Finger joints on outer face edges</li>\n              <li>Slots for subdivision panel tabs</li>\n              <li>Interlocking slots for crossing dividers</li>\n              <li>Dimensions in mm</li>\n            </ul>\n          </div>\n        </div>\n      </div>\n    </Modal>\n  );\n};\n","import { serializeProject, deserializeProject, ProjectState } from './urlState';\n\nexport interface SavedProject {\n  id: string;\n  name: string;\n  thumbnail: string;  // Base64 data URL\n  data: string;       // Same format as URL encoded state\n  createdAt: number;\n  updatedAt: number;\n}\n\nconst STORAGE_KEY = 'boxen-projects';\n\n// Generate a unique ID\nconst generateId = (): string => {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);\n};\n\n// Get all saved projects\nexport const getSavedProjects = (): SavedProject[] => {\n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (!stored) return [];\n    return JSON.parse(stored);\n  } catch (e) {\n    console.error('Failed to load projects from localStorage:', e);\n    return [];\n  }\n};\n\n// Save a project\nexport const saveProject = (\n  name: string,\n  state: ProjectState,\n  thumbnail: string,\n  existingId?: string\n): SavedProject => {\n  const projects = getSavedProjects();\n  const now = Date.now();\n\n  // Serialize using same format as URL\n  const data = serializeProject(state);\n\n  if (existingId) {\n    // Update existing project\n    const index = projects.findIndex(p => p.id === existingId);\n    if (index !== -1) {\n      projects[index] = {\n        ...projects[index],\n        name,\n        thumbnail,\n        data,\n        updatedAt: now,\n      };\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(projects));\n      return projects[index];\n    }\n  }\n\n  // Create new project\n  const project: SavedProject = {\n    id: generateId(),\n    name,\n    thumbnail,\n    data,\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  projects.unshift(project);  // Add to beginning\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(projects));\n\n  return project;\n};\n\n// Load a project\nexport const loadProject = (id: string): ProjectState | null => {\n  const projects = getSavedProjects();\n  const project = projects.find(p => p.id === id);\n\n  if (!project) return null;\n\n  return deserializeProject(project.data);\n};\n\n// Delete a project\nexport const deleteProject = (id: string): boolean => {\n  const projects = getSavedProjects();\n  const filtered = projects.filter(p => p.id !== id);\n\n  if (filtered.length === projects.length) return false;\n\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));\n  return true;\n};\n\n// Rename a project\nexport const renameProject = (id: string, newName: string): boolean => {\n  const projects = getSavedProjects();\n  const index = projects.findIndex(p => p.id === id);\n\n  if (index === -1) return false;\n\n  projects[index] = {\n    ...projects[index],\n    name: newName,\n    updatedAt: Date.now(),\n  };\n\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(projects));\n  return true;\n};\n\n// Get project by ID\nexport const getProject = (id: string): SavedProject | null => {\n  const projects = getSavedProjects();\n  return projects.find(p => p.id === id) || null;\n};\n\n// Capture thumbnail from canvas\n// Target thumbnail dimensions match the CSS (.project-thumbnail is ~290px wide, 120px tall)\nconst THUMBNAIL_WIDTH = 580;  // 2x for retina\nconst THUMBNAIL_HEIGHT = 240; // 2x for retina\nconst THUMBNAIL_ASPECT = THUMBNAIL_WIDTH / THUMBNAIL_HEIGHT;\n\nexport const captureThumbnail = (canvas: HTMLCanvasElement): string => {\n  const tempCanvas = document.createElement('canvas');\n  const ctx = tempCanvas.getContext('2d');\n\n  if (!ctx) return '';\n\n  // Set output size (high res for crisp display)\n  tempCanvas.width = THUMBNAIL_WIDTH;\n  tempCanvas.height = THUMBNAIL_HEIGHT;\n\n  // Calculate crop area from source canvas to match thumbnail aspect ratio\n  const sourceAspect = canvas.width / canvas.height;\n  let sourceX = 0;\n  let sourceY = 0;\n  let sourceWidth = canvas.width;\n  let sourceHeight = canvas.height;\n\n  if (sourceAspect > THUMBNAIL_ASPECT) {\n    // Canvas is wider than thumbnail - crop sides\n    sourceWidth = canvas.height * THUMBNAIL_ASPECT;\n    sourceX = (canvas.width - sourceWidth) / 2;\n  } else {\n    // Canvas is taller than thumbnail - crop top/bottom\n    sourceHeight = canvas.width / THUMBNAIL_ASPECT;\n    sourceY = (canvas.height - sourceHeight) / 2;\n  }\n\n  // Enable high quality scaling\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n\n  // Draw cropped and scaled image\n  ctx.drawImage(\n    canvas,\n    sourceX, sourceY, sourceWidth, sourceHeight,  // Source crop\n    0, 0, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT        // Destination\n  );\n\n  // Return as PNG for crisp quality\n  return tempCanvas.toDataURL('image/png');\n};\n","import React, { useState, useEffect } from 'react';\nimport { Modal } from './UI/Modal';\nimport { SavedProject, getSavedProjects, deleteProject, renameProject } from '../utils/projectStorage';\n\ninterface ProjectBrowserModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onLoadProject: (projectId: string) => void;\n}\n\nexport const ProjectBrowserModal: React.FC<ProjectBrowserModalProps> = ({\n  isOpen,\n  onClose,\n  onLoadProject,\n}) => {\n  const [projects, setProjects] = useState<SavedProject[]>([]);\n  const [editingId, setEditingId] = useState<string | null>(null);\n  const [editName, setEditName] = useState('');\n  const [deleteConfirmId, setDeleteConfirmId] = useState<string | null>(null);\n\n  // Load projects when modal opens\n  useEffect(() => {\n    if (isOpen) {\n      setProjects(getSavedProjects());\n      setEditingId(null);\n      setDeleteConfirmId(null);\n    }\n  }, [isOpen]);\n\n  const handleDelete = (id: string) => {\n    if (deleteProject(id)) {\n      setProjects(getSavedProjects());\n      setDeleteConfirmId(null);\n    }\n  };\n\n  const handleStartRename = (project: SavedProject) => {\n    setEditingId(project.id);\n    setEditName(project.name);\n    setDeleteConfirmId(null);\n  };\n\n  const handleSaveRename = () => {\n    if (editingId && editName.trim()) {\n      if (renameProject(editingId, editName.trim())) {\n        setProjects(getSavedProjects());\n      }\n    }\n    setEditingId(null);\n    setEditName('');\n  };\n\n  const handleCancelRename = () => {\n    setEditingId(null);\n    setEditName('');\n  };\n\n  const handleLoad = (id: string) => {\n    onLoadProject(id);\n    onClose();\n  };\n\n  const formatDate = (timestamp: number) => {\n    const date = new Date(timestamp);\n    return date.toLocaleDateString(undefined, {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} title=\"My Projects\">\n      <div className=\"project-browser\">\n        {projects.length === 0 ? (\n          <div className=\"no-projects\">\n            <p>No saved projects yet.</p>\n            <p className=\"hint\">Use the \"Save\" button to save your current project.</p>\n          </div>\n        ) : (\n          <div className=\"project-grid\">\n            {projects.map((project) => (\n              <div key={project.id} className=\"project-card\">\n                <div\n                  className=\"project-thumbnail\"\n                  onClick={() => handleLoad(project.id)}\n                >\n                  {project.thumbnail ? (\n                    <img src={project.thumbnail} alt={project.name} />\n                  ) : (\n                    <div className=\"no-thumbnail\">No preview</div>\n                  )}\n                </div>\n                <div className=\"project-info\">\n                  {editingId === project.id ? (\n                    <div className=\"project-name-edit\">\n                      <input\n                        type=\"text\"\n                        value={editName}\n                        onChange={(e) => setEditName(e.target.value)}\n                        onKeyDown={(e) => {\n                          if (e.key === 'Enter') handleSaveRename();\n                          if (e.key === 'Escape') handleCancelRename();\n                        }}\n                        autoFocus\n                      />\n                      <div className=\"edit-buttons\">\n                        <button onClick={handleSaveRename} title=\"Save\">\n                          &#10003;\n                        </button>\n                        <button onClick={handleCancelRename} title=\"Cancel\">\n                          &#10005;\n                        </button>\n                      </div>\n                    </div>\n                  ) : (\n                    <div className=\"project-name\" onClick={() => handleLoad(project.id)}>\n                      {project.name}\n                    </div>\n                  )}\n                  <div className=\"project-date\">\n                    {formatDate(project.updatedAt)}\n                  </div>\n                </div>\n                <div className=\"project-actions\">\n                  {deleteConfirmId === project.id ? (\n                    <div className=\"delete-confirm\">\n                      <span>Delete?</span>\n                      <button\n                        className=\"confirm-yes\"\n                        onClick={() => handleDelete(project.id)}\n                      >\n                        Yes\n                      </button>\n                      <button\n                        className=\"confirm-no\"\n                        onClick={() => setDeleteConfirmId(null)}\n                      >\n                        No\n                      </button>\n                    </div>\n                  ) : (\n                    <>\n                      <button\n                        className=\"action-btn load-btn\"\n                        onClick={() => handleLoad(project.id)}\n                        title=\"Load project\"\n                      >\n                        Open\n                      </button>\n                      <button\n                        className=\"action-btn rename-btn\"\n                        onClick={() => handleStartRename(project)}\n                        title=\"Rename project\"\n                      >\n                        Rename\n                      </button>\n                      <button\n                        className=\"action-btn delete-btn\"\n                        onClick={() => setDeleteConfirmId(project.id)}\n                        title=\"Delete project\"\n                      >\n                        Delete\n                      </button>\n                    </>\n                  )}\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </Modal>\n  );\n};\n","import React, { useState, useEffect } from 'react';\nimport { Modal } from './UI/Modal';\n\ninterface SaveProjectModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSave: (name: string) => void;\n  defaultName?: string;\n}\n\nexport const SaveProjectModal: React.FC<SaveProjectModalProps> = ({\n  isOpen,\n  onClose,\n  onSave,\n  defaultName = '',\n}) => {\n  const [name, setName] = useState(defaultName);\n\n  useEffect(() => {\n    if (isOpen) {\n      setName(defaultName || `Project ${new Date().toLocaleDateString()}`);\n    }\n  }, [isOpen, defaultName]);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (name.trim()) {\n      onSave(name.trim());\n      onClose();\n    }\n  };\n\n  return (\n    <Modal isOpen={isOpen} onClose={onClose} title=\"Save Project\">\n      <form className=\"save-project-form\" onSubmit={handleSubmit}>\n        <div className=\"form-group\">\n          <label htmlFor=\"project-name\">Project Name</label>\n          <input\n            id=\"project-name\"\n            type=\"text\"\n            value={name}\n            onChange={(e) => setName(e.target.value)}\n            placeholder=\"Enter project name...\"\n            autoFocus\n          />\n        </div>\n        <div className=\"form-actions\">\n          <button type=\"button\" className=\"cancel-btn\" onClick={onClose}>\n            Cancel\n          </button>\n          <button type=\"submit\" className=\"save-btn\" disabled={!name.trim()}>\n            Save Project\n          </button>\n        </div>\n      </form>\n    </Modal>\n  );\n};\n","import { useState, useEffect, useRef, useMemo } from 'react';\nimport { BoxTree } from './components/BoxTree';\nimport { Viewport3D, Viewport3DHandle } from './components/Viewport3D';\nimport { SketchView2D } from './components/SketchView2D';\nimport { SubdivisionControls } from './components/SubdivisionControls';\nimport { PanelProperties } from './components/PanelProperties';\nimport { AssemblyProperties } from './components/AssemblyProperties';\nimport { DimensionForm } from './components/DimensionForm';\nimport { ExportModal } from './components/ExportModal';\nimport { ProjectBrowserModal } from './components/ProjectBrowserModal';\nimport { SaveProjectModal } from './components/SaveProjectModal';\nimport { useBoxStore } from './store/useBoxStore';\nimport { saveProject, loadProject, captureThumbnail } from './utils/projectStorage';\nimport { ProjectState } from './utils/urlState';\nimport { defaultEdgeExtensions, EdgeExtensions, FaceId, PanelPath } from './types';\nimport './App.css';\n\n// Get the normal axis for any panel (face or divider)\nconst getPanelNormalAxis = (panel: PanelPath): 'x' | 'y' | 'z' | null => {\n  if (panel.source.type === 'face' && panel.source.faceId) {\n    const faceNormals: Record<FaceId, 'x' | 'y' | 'z'> = {\n      left: 'x', right: 'x',\n      top: 'y', bottom: 'y',\n      front: 'z', back: 'z',\n    };\n    return faceNormals[panel.source.faceId];\n  }\n  if (panel.source.type === 'divider' && panel.source.axis) {\n    return panel.source.axis;\n  }\n  return null;\n};\n\n// Check if two selected panels can potentially be subdivided between\n// This is a quick check - detailed validation happens in SubdivisionControls\nconst canSubdivideBetweenPanels = (\n  selectedPanelIds: Set<string>,\n  panelCollection: { panels: PanelPath[] } | null\n): boolean => {\n  if (selectedPanelIds.size !== 2 || !panelCollection) return false;\n\n  const panelIds = Array.from(selectedPanelIds);\n  const panels = panelIds\n    .map(id => panelCollection.panels.find(p => p.id === id))\n    .filter((p): p is PanelPath => p !== undefined);\n\n  if (panels.length !== 2) return false;\n\n  // Both must be from main assembly (not sub-assembly)\n  if (panels.some(p => p.source.subAssemblyId)) return false;\n\n  // Get normal axes for both panels\n  const axis1 = getPanelNormalAxis(panels[0]);\n  const axis2 = getPanelNormalAxis(panels[1]);\n\n  // Both must have valid normal axes and they must match (parallel panels)\n  return axis1 !== null && axis1 === axis2;\n};\n\nfunction App() {\n  const [isExportModalOpen, setIsExportModalOpen] = useState(false);\n  const [isProjectBrowserOpen, setIsProjectBrowserOpen] = useState(false);\n  const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);\n  const [shareStatus, setShareStatus] = useState<'idle' | 'copied'>('idle');\n  const [saveStatus, setSaveStatus] = useState<'idle' | 'saved'>('idle');\n  const viewportRef = useRef<Viewport3DHandle>(null);\n\n  const {\n    config,\n    faces,\n    rootVoid,\n    panelCollection,\n    selectedVoidIds,\n    selectedPanelIds,\n    selectedAssemblyId,\n    selectedSubAssemblyIds,\n    viewMode,\n    loadFromUrl,\n    getShareableUrl,\n    saveToUrl,\n    generatePanels,\n    setConfig,\n  } = useBoxStore();\n\n  // Load state from URL on initial mount\n  useEffect(() => {\n    const loaded = loadFromUrl();\n    if (loaded) {\n      // Regenerate panels after loading state\n      generatePanels();\n    }\n  }, []);\n\n  // Handle share button click\n  const handleShare = async () => {\n    const url = getShareableUrl();\n    try {\n      await navigator.clipboard.writeText(url);\n      setShareStatus('copied');\n      setTimeout(() => setShareStatus('idle'), 2000);\n    } catch (err) {\n      // Fallback for browsers that don't support clipboard API\n      const textArea = document.createElement('textarea');\n      textArea.value = url;\n      document.body.appendChild(textArea);\n      textArea.select();\n      document.execCommand('copy');\n      document.body.removeChild(textArea);\n      setShareStatus('copied');\n      setTimeout(() => setShareStatus('idle'), 2000);\n    }\n  };\n\n  // Handle save project\n  const handleSaveProject = (name: string) => {\n    // Get thumbnail from canvas\n    let thumbnail = '';\n    const canvas = viewportRef.current?.getCanvas();\n    if (canvas) {\n      thumbnail = captureThumbnail(canvas);\n    }\n\n    // Collect edge extensions from panels\n    const edgeExtensions: Record<string, EdgeExtensions> = {};\n    if (panelCollection) {\n      for (const panel of panelCollection.panels) {\n        if (panel.edgeExtensions &&\n            (panel.edgeExtensions.top !== 0 ||\n             panel.edgeExtensions.bottom !== 0 ||\n             panel.edgeExtensions.left !== 0 ||\n             panel.edgeExtensions.right !== 0)) {\n          edgeExtensions[panel.id] = panel.edgeExtensions;\n        }\n      }\n    }\n\n    const projectState: ProjectState = {\n      config,\n      faces,\n      rootVoid,\n      edgeExtensions,\n    };\n\n    saveProject(name, projectState, thumbnail);\n    setSaveStatus('saved');\n    setTimeout(() => setSaveStatus('idle'), 2000);\n  };\n\n  // Handle load project from browser\n  const handleLoadProject = (projectId: string) => {\n    const loaded = loadProject(projectId);\n    if (loaded) {\n      // Update store with loaded state\n      const state = useBoxStore.getState();\n\n      // Collect edge extensions\n      const edgeExtensionsMap = loaded.edgeExtensions;\n\n      // Set config first (this resets rootVoid)\n      state.setConfig(loaded.config);\n\n      // Then manually set the loaded rootVoid and faces\n      useBoxStore.setState({\n        config: loaded.config,\n        faces: loaded.faces,\n        rootVoid: loaded.rootVoid,\n        panelsDirty: true,\n      });\n\n      // Generate panels\n      generatePanels();\n\n      // Apply edge extensions after panel generation\n      if (Object.keys(edgeExtensionsMap).length > 0) {\n        const currentPanels = useBoxStore.getState().panelCollection?.panels;\n        if (currentPanels) {\n          const updatedPanels = currentPanels.map(panel => ({\n            ...panel,\n            edgeExtensions: edgeExtensionsMap[panel.id] ?? panel.edgeExtensions ?? defaultEdgeExtensions,\n          }));\n          useBoxStore.setState({\n            panelCollection: {\n              ...useBoxStore.getState().panelCollection!,\n              panels: updatedPanels,\n            },\n          });\n        }\n      }\n\n      // Update URL to reflect loaded project (same as share)\n      saveToUrl();\n    }\n  };\n\n  // Handle new project\n  const handleNewProject = () => {\n    // Reset to default state\n    useBoxStore.setState({\n      config: {\n        width: 100,\n        height: 100,\n        depth: 100,\n        materialThickness: 3,\n        fingerWidth: 10,\n        fingerGap: 1.5,\n        assembly: {\n          assemblyAxis: 'y',\n          lids: {\n            positive: { enabled: true, tabDirection: 'tabs-out', inset: 0 },\n            negative: { enabled: true, tabDirection: 'tabs-out', inset: 0 },\n          },\n        },\n      },\n      faces: [\n        { id: 'front', solid: true },\n        { id: 'back', solid: true },\n        { id: 'left', solid: true },\n        { id: 'right', solid: true },\n        { id: 'top', solid: true },\n        { id: 'bottom', solid: true },\n      ],\n      rootVoid: {\n        id: 'root',\n        bounds: { x: 0, y: 0, z: 0, w: 100, h: 100, d: 100 },\n        children: [],\n      },\n      selectedVoidIds: new Set<string>(),\n      selectedPanelIds: new Set<string>(),\n      selectedAssemblyId: null,\n      selectedSubAssemblyIds: new Set<string>(),\n      panelsDirty: true,\n    });\n    generatePanels();\n\n    // Clear URL state\n    const url = new URL(window.location.href);\n    url.searchParams.delete('p');\n    url.hash = '';\n    window.history.replaceState(null, '', url.toString());\n  };\n\n  // Check if two parallel panels are selected (for subdivision)\n  const showTwoPanelSubdivision = useMemo(() =>\n    canSubdivideBetweenPanels(selectedPanelIds, panelCollection),\n    [selectedPanelIds, panelCollection]\n  );\n\n  // Determine what to show in the right sidebar based on selection\n  const renderRightSidebar = () => {\n    // Void selected - show subdivision controls (only for single selection)\n    if (selectedVoidIds.size === 1) {\n      return <SubdivisionControls />;\n    }\n\n    // Two opposite panels selected - show subdivision controls\n    if (showTwoPanelSubdivision) {\n      return <SubdivisionControls />;\n    }\n\n    // Panel selected - show panel properties\n    if (selectedPanelIds.size > 0) {\n      return <PanelProperties />;\n    }\n\n    // Assembly or sub-assembly selected - show assembly properties\n    if (selectedAssemblyId || selectedSubAssemblyIds.size > 0) {\n      return <AssemblyProperties />;\n    }\n\n    // Nothing selected - show default dimension form\n    return <DimensionForm />;\n  };\n\n  return (\n    <div className=\"app\">\n      <header className=\"app-header\">\n        <div className=\"header-content\">\n          <h1>Boxen</h1>\n          <p>3D Laser-Cut Box Designer</p>\n        </div>\n        <div className=\"header-menu\">\n          <button\n            className=\"header-btn secondary\"\n            onClick={handleNewProject}\n          >\n            <span className=\"header-btn-icon\">+</span>\n            New\n          </button>\n          <button\n            className=\"header-btn secondary\"\n            onClick={() => setIsProjectBrowserOpen(true)}\n          >\n            <span className=\"header-btn-icon\"></span>\n            Open\n          </button>\n          <button\n            className=\"header-btn\"\n            onClick={() => setIsSaveModalOpen(true)}\n          >\n            <span className=\"header-btn-icon\">{saveStatus === 'saved' ? '' : ''}</span>\n            {saveStatus === 'saved' ? 'Saved!' : 'Save'}\n          </button>\n          <button\n            className=\"header-btn secondary\"\n            onClick={handleShare}\n          >\n            <span className=\"header-btn-icon\">{shareStatus === 'copied' ? '' : ''}</span>\n            {shareStatus === 'copied' ? 'Copied!' : 'Share'}\n          </button>\n          <button\n            className=\"header-btn\"\n            onClick={() => setIsExportModalOpen(true)}\n          >\n            <span className=\"header-btn-icon\"></span>\n            Export\n          </button>\n        </div>\n      </header>\n\n      <main className=\"app-main\">\n        <aside className=\"sidebar left-sidebar\">\n          <BoxTree />\n        </aside>\n\n        <section className=\"viewport\">\n          {viewMode === '3d' ? (\n            <Viewport3D ref={viewportRef} />\n          ) : (\n            <SketchView2D />\n          )}\n        </section>\n\n        <aside className=\"sidebar right-sidebar\">\n          {renderRightSidebar()}\n        </aside>\n      </main>\n\n      <ExportModal\n        isOpen={isExportModalOpen}\n        onClose={() => setIsExportModalOpen(false)}\n      />\n\n      <ProjectBrowserModal\n        isOpen={isProjectBrowserOpen}\n        onClose={() => setIsProjectBrowserOpen(false)}\n        onLoadProject={handleLoadProject}\n      />\n\n      <SaveProjectModal\n        isOpen={isSaveModalOpen}\n        onClose={() => setIsSaveModalOpen(false)}\n        onSave={handleSaveProject}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App'\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n)\n"],"names":["defaultFeetConfig","getFaceRole","faceId","axis","getLidSide","mapping","getLidFaceId","side","getWallPriority","defaultAssemblyConfig","defaultFaceOffsets","defaultEdgeExtensions","getEdgeAxis","edgePosition","LZString","f","keyStrBase64","keyStrUriSafe","baseReverseDic","getBaseValue","alphabet","character","i","input","res","a","index","compressed","uncompressed","buf","TotalLen","current_value","result","c","bitsPerChar","getCharFromInt","value","context_dictionary","context_dictionaryToCreate","context_c","context_wc","context_w","context_enlargeIn","context_dictSize","context_numBits","context_data","context_data_val","context_data_position","ii","length","resetValue","getNextValue","dictionary","enlargeIn","dictSize","numBits","entry","w","bits","resb","maxpower","power","data","module","FACE_ORDER","r","n","serializeFaces","faces","bitmap","face","deserializeFaces","id","serializeFaceOffsets","fo","deserializeFaceOffsets","sfo","serializeSubAssembly","sub","serializeVoid","serializeAssembly","deserializeSubAssembly","ssub","deserializeVoid","deserializeAssembly","v","sv","sa","_a","_b","_c","_d","serializeExtensions","extensions","hasAny","panelId","ext","deserializeExtensions","se","top","bottom","left","right","serializeProject","state","serialized","json","compressToEncodedURIComponent","deserializeProject","encoded","decompressFromEncodedURIComponent","e","URL_PARAM","saveToUrl","url","loadFromUrl","hash","getShareableUrl","generateFingerJointPath","start","end","config","fingerWidth","materialThickness","dx","dy","actualLength","unitX","unitY","perpSign","perpX","perpY","patternLength","patternOffset","gapMultiplier","baseCornerGap","startCornerGap","endCornerGap","usableLength","numFingers","actualFingerWidth","depth","patternToActual","patternPos","actualPos","points","cornerGapActual","isEvenPosition","fingerStartPattern","fingerEndPattern","fingerStartActual","fingerEndActual","clampedStart","clampedEnd","offsetX","offsetY","fStartPt","fEndPt","startVisible","endVisible","lastPt","endGapPattern","endGapActual","gapPt","generateFingerJointPathV2","fingerPoints","gender","transitionPoints","innerOffset","fingerLength","maxJointLength","yUp","depthSign","edgeStartPos","edgeEndPos","edgeAxisLength","isPositiveDirection","axisToEdge","axisPos","pointAtEdge","edgePos","offset","clampedPos","minAxisPos","maxAxisPos","fingerRegionStart","fingerRegionEnd","allBoundaries","allSections","validSections","section","s","pathPoints","sortedSections","b","currentEdgePos","sectionStartEdge","sectionEndEdge","endPt","cleanedPoints","prev","curr","calculateAxisFingerPoints","axisLength","minDistance","numSections","actualFingerLength","calculateAssemblyFingerPoints","boxConfig","getAdjacentFace","getLidGender","assembly","getEdgeGender","adjacentFaceId","adjacentFace","thisRole","adjacentRole","lidGender","thisPriority","adjacentPriority","getEdgeAxisPositions","lowHasTabs","highHasTabs","width","height","mt","lowPos","highPos","maxJoint","getEdgeOutwardDirection","getFaceDimensions","getFaceEdges","getDividerEdgeStatuses","meetsTop","meetsBottom","meetsLeft","meetsRight","getFaceEdgeStatuses","edge","tabsOut","shouldTabOut","status","myRole","adjRole","getFaceTransform","scale","halfW","halfH","halfD","getLidInset","generateFeetPath","startX","endX","baseY","feetConfig","feetHeight","footWidth","inset","jointClearanceY","feetBottomY","rightFootOuterX","rightFootInnerX","leftFootInnerX","leftFootOuterX","generateFacePanelOutline","edgeExtensions","existingPanels","fingerData","feetEdge","dims","edges","fingerGap","edgeHasTabs","position","edgeInfo","isSolidAdjacent","tabOut","edgeIsUnlocked","edgeHasFingers","topHasTabs","bottomHasTabs","leftHasTabs","rightHasTabs","topIsSolid","bottomIsSolid","leftIsSolid","rightIsSolid","getExtension","isOpen","hasTabs","extTop","extBottom","extLeft","extRight","fingerCorners","outlineCorners","edgeConfigs","outlinePoints","fingerStart","fingerEnd","startExt","endExt","hasFingers","hasParallelExtension","axisFingerPoints","outwardDirection","isHorizontalEdge","startPos","endPos","fingerPathPoints","adjustedPoints","startDiffX","startDiffY","endDiffX","endDiffY","lastOutlinePoint","edgeStartPoint","tolerance","bottomRightX","bottomLeftX","bottomRightIdx","bottomLeftIdx","p","feetPath","beforeBottom","afterBottom","generateDividerSlotHoles","rootVoid","holes","subdivisions","getAllSubdivisions","isFaceSolid","topInset","bottomInset","leftInset","rightInset","frontInset","backInset","getDividerExtensions","subId","dividerPanel","slotX","slotY","slotLength","isHorizontal","startInset","endInset","extensionStart","extensionEnd","slotCenterOffset","bounds","meetsBack","meetsFront","getExtForEdge","edgeName","meetsCondition","slotAxis","axisDim","boundsStart","boundsEnd","atLowWall","atHighWall","effectiveLow","effectiveHigh","slotIndex","sectionStart","sectionEnd","clippedStart","clippedEnd","offsetStart","offsetEnd","holePoints","y","x","effectiveLength","halfSlotLength","cornerGapBase","maxInset","adjustedCornerGap","actualStart","actualEnd","patternStart","patternEnd","generateLidSlotHoles","lidConfig","slotPosition","slotStart","slotEnd","generateExtensionSlotHoles","extension","isFemaleEdge","minPos","maxPos","generateFacePanel","existingExtensions","isWall","shouldHaveFeet","feetParams","feetExtension","extensionsWithFeet","dividerHoles","lidHoles","extensionHoles","rotation","source","actualWidth","actualHeight","generateDividerToSlotHoles","subdivision","allSubdivisions","child","connectsToThis","cornerInsetStart","cornerInsetEnd","childYMin","childYMax","childXMin","childXMax","childZMin","childZMax","halfEffectiveLength","maxCornerInset","cornerGap","centerOffset","generateDividerPanel","meetsOtherDivider","edgeAxis","thisPosition","thisAxis","other","containsThis","panelWidth","panelHeight","meetsFaceTop","meetsFaceBottom","meetsFaceLeft","meetsFaceRight","meetsDividerTop","meetsDividerBottom","meetsDividerLeft","meetsDividerRight","origCorners","corners","origTopLength","origBottomLength","origLeftLength","origRightLength","getEdgeAxisInfo","maxJointX","maxJointY","maxJointZ","calcAxisPositions","boundsLow","boundsSize","meetsLow","meetsHigh","meetsFace","originalLength","axisInfo","runsNegative","axisLowAdjust","axisHighAdjust","adjustedStartPos","adjustedEndPos","cornerInset","adjustedGapMultiplier","startIndex","panelPosition","panelRotation","scaledPos","halfWidth","halfHeight","halfDepth","boundsCenterX","boundsCenterY","boundsCenterZ","dividerSlots","generatePanelCollection","panels","getExistingExtensions","existing","dividerPanels","panel","faceIds","generateId","createSimpleRootVoid","createRootVoidWithInsets","existingChildren","positiveInset","negativeInset","mainBounds","positiveCapBounds","negativeCapBounds","children","getMainInteriorVoid","root","getUserSubdivisions","mainInterior","initialFaces","findVoid","found","findParent","recalculateVoidBounds","node","parentBounds","firstChildWithSplit","parentStart","parentSize","parentEnd","newChildren","splitPositions","newPosition","regionStart","regionSize","childBounds","updatedChild","getLeafVoids","getVoidSubtreeIds","ids","isVoidVisible","voidId","_rootVoid","hiddenVoidIds","_isolatedVoidId","isSubAssemblyVisible","subAssemblyId","hiddenSubAssemblyIds","_isolatedSubAssemblyId","traverse","calculatePreviewPositions","count","positions","fraction","cloneVoid","findSubAssembly","getAllSubAssemblies","updateVoidInTree","updater","useBoxStore","create","set","get","newConfig","oldConfig","assemblyStructureChanged","dimensionsChanged","newRootBounds","hasInsets","newRootVoid","recalculatedMainInterior","newMainInterior","mode","additive","newSet","assemblyId","preview","targetVoid","dimSize","dimStart","splitPos","splitAxis","splitPercentage","parent","options","clearance","assemblyAxis","faceOffsets","outerWidth","outerHeight","outerDepth","interiorWidth","interiorHeight","interiorDepth","defaultFaces","subAssembly","updateSubAssemblyInVoid","newClearance","newHiddenVoidIds","newHiddenFaceIds","newHiddenSubAssemblyIds","isolatedVoid","visibleVoidIds","allVoidIds","newIsolateHiddenVoidIds","newIsolateHiddenFaceIds","newIsolateHiddenSubAssemblyIds","dividerId","mainFaceIds","allSubAssemblies","parentVoidId","getAllDividerIds","allDividerIds","subFaceId","newAssembly","userSubdivisions","direction","newInset","collection","subAssemblies","subConfig","subCollection","mainCenterX","mainCenterY","mainCenterZ","subOuterW","subOuterH","subOuterD","offsets","subCenterX","subCenterY","subCenterZ","offsetZ","offsetPanel","updates","hole","holeId","h","augmentation","newAugmentations","newPanels","augmentationId","updatedPanels","subdivisionId","voidIndex","prevVoid","nextVoid","clampedPosition","updateVoidPosition","newPercentage","recalculatedChildren","idx","newBounds","updatedChildren","recalculateNestedBounds","dimEnd","percentage","loaded","edgeExtensionsMap","panelsWithExtensions","projectState","saveStateToUrl","getShareUrl","Panel","title","className","jsxs","jsx","faceLabels","getDividerPanels","OuterPanelNode","selectedPanelIds","onSelectPanel","hoveredPanelId","onHoverPanel","hiddenFaceIds","isolatedPanelId","onToggleFaceVisibility","onSetIsolatedPanel","isSelected","isHovered","isHidden","isIsolated","DividerPanelNode","onDelete","axisLabel","VoidNode","label","selectedVoidIds","selectedSubAssemblyIds","selectedAssemblyId","onSelectVoid","onSelectSubAssembly","onSelectAssembly","hoveredVoidId","hoveredAssemblyId","onHoverVoid","onHoverAssembly","isolatedVoidId","onToggleVisibility","onSetIsolated","isolatedSubAssemblyId","onToggleSubAssemblyVisibility","onSetIsolatedSubAssembly","onDeleteVoid","onDeleteSubAssembly","isLeaf","hasChildren","hasSubAssembly","getLabel","getDimensions","d","getIcon","treeOps","SubAssemblyNode","React","isAssemblySelected","isAssemblyHovered","getTypeLabel","getTypeIcon","outerFacePanels","MainBoxNode","interiorVoid","BoxTree","selectVoid","selectSubAssembly","selectPanel","selectAssembly","setHoveredVoid","setHoveredPanel","setHoveredAssembly","toggleVoidVisibility","setIsolatedVoid","toggleSubAssemblyVisibility","setIsolatedSubAssembly","toggleFaceVisibility","setIsolatedPanel","removeVoid","removeSubAssembly","hasIsolation","handleShowAll","_box","Box3","_vector","Vector3","LineSegmentsGeometry","InstancedBufferGeometry","uvs","Float32BufferAttribute","matrix","array","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","geometry","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","il","UniformsLib","Vector2","ShaderLib","UniformsUtils","LineMaterial","ShaderMaterial","parameters","_start","_end","_start4","Vector4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","raycastWorldUnits","intersects","matrixWorld","instanceStart","instanceEnd","segmentCount","l","pointOnLine","point","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","Mesh","material","lineDistances","j","instanceDistanceBuffer","raycaster","worldUnits","threshold","sphereMargin","distanceToSphere","boxMargin","distanceToBox","VoidMesh","boxCenter","meshRef","useRef","selectionMode","canvasSize","useThree","isVoidMode","visible","atLeft","atRight","atBottom","atTop","atBack","atFront","leftSolid","rightSolid","bottomSolid","topSolid","backSolid","_e","frontSolid","_f","insetLeft","insetRight","insetBottom","insetTop","insetBack","insetFront","insetBounds","size","lineGeometry","lineMaterial","useMemo","hw","hh","hd","THREE.Vector2","SubAssembly3D","isSelectedSubAssembly","isSelectedAssembly","scaledW","scaledH","scaledD","handleClick","isClickable","THREE.BoxGeometry","createGeometryFromPath","outline","thickness","scaledThickness","shape","THREE.Shape","first","pt","holePath","THREE.Path","extrudeSettings","geo","THREE.ExtrudeGeometry","createEdgeGeometry","frontZ","backZ","vertices","addSegment","x1","y1","z1","x2","y2","z2","addPathOutline","z","p1","p2","addConnectingEdges","seen","key","THREE.BufferGeometry","THREE.Float32BufferAttribute","PanelPathRenderer","onClick","onDoubleClick","onHover","color","selectedColor","hoveredColor","scaledPosition","edgeGeometry","useEffect","nativeEvent","handleDoubleClick","handlePointerOver","handlePointerOut","displayColor","displayOpacity","THREE.DoubleSide","getAssemblyIdFromPanel","PanelCollectionRenderer","onPanelClick","onPanelDoubleClick","panelCollection","Fragment","isDivider","isSubAssemblyPanel","panelAssemblyId","isPanelSelected","isPanelHovered","hovered","findParentSubAssemblyInfo","parentSubAssembly","Box3D","subdivisionPreview","subAssemblyPreview","panelsDirty","generatePanels","showDebugAnchors","leafVoids","previewVoid","previewOffset","subAssemblyInfo","subInteriorW","subInteriorH","subInteriorD","previewSubAssembly","previewInsetBounds","previewFaces","containerW","containerH","containerD","halfMT","anchorCorners","hx","hy","hz","corner","pos","centerX","centerY","centerZ","leafVoid","ViewportToolbar","setSelectionMode","toggleDebugAnchors","tools","handleToolClick","tool","EditorToolbar","activeTool","onToolChange","mirrorX","mirrorY","onMirrorXChange","onMirrorYChange","availableTools","toolId","Viewport3D","forwardRef","_","ref","clearSelection","toggleFace","purgeVoid","canvasContainerRef","useImperativeHandle","handleDeleteSelectedPanels","useCallback","handleKeyDown","Canvas","Grid","OrbitControls","Environment","faceEdgeHasJoints","neighbors","neighborId","neighborFace","getFaceEdgeInfo","hasJoints","getDividerEdgeInfo","getEditableAreas","originalWidth","originalHeight","edgeInfos","topMargin","bottomMargin","leftMargin","rightMargin","mainArea","areas","detectMainCorners","defaultMaxRadius","pathToSvgD","closed","segments","classifySegment","nearTop","nearBottom","nearLeft","nearRight","getEdgeSegments","distanceToSegment","px","py","lengthSq","nearX","nearY","getConceptualBoundary","getJointSegments","joints","avgX","avgY","nearEdge","GridPattern","gridSize","getDividerMeetsFaces","containerDims","SketchView2D","sketchPanelId","exitSketchView","setEdgeExtension","viewBox","setViewBox","useState","isPanning","setIsPanning","panStart","setPanStart","svgRef","hoveredEdge","setHoveredEdge","isDraggingEdge","setIsDraggingEdge","dragEdge","setDragEdge","dragStartPos","setDragStartPos","dragStartExtension","setDragStartExtension","edgeStatuses","edgeSegments","conceptualBoundary","jointSegments","editableAreas","detectedCorners","lockedCount","editableCount","isEdgeEditable","screenToSvg","clientX","clientY","svg","rect","findEdgeAtPoint","svgX","svgY","hitDistance","seg","handleWheel","scaleFactor","mouseX","mouseY","newWidth","newHeight","newX","newY","handleMouseDown","svgPos","currentExtension","handleMouseMove","delta","newExtension","clampedExtension","handleMouseUp","handleFitView","strokeScale","outlineStrokeWidth","holeStrokeWidth","edgeHighlightWidth","getEdgeColor","isLocked","isDragging","getCursor","area","boundary","joint","edgeColor","NumberInput","onChange","min","max","step","localValue","setLocalValue","isFocused","setIsFocused","inputRef","handleFocus","handleBlur","handleChange","inputValue","parsed","validValue","getFaceNormalAxis","getPanelNormalAxis","getPerpendicularAxes","normalAxis","getPanelDescription","getVoidIdFromSubdivisionId","findParentVoid","childVoidId","findVoidBetweenPanels","panel1","panel2","mainVoid","subId1","subId2","voidId1","voidId2","parent1","parent2","childIds","idx1","idx2","minIdx","voidBetween","facePanel","dividerAxis","dividerIdx","isLowFace","targetIdx","analyzeTwoPanelSelection","invalid","axis1","axis2","validAxes","panelDescriptions","getValidAxes","isSolid","xValid","yValid","zValid","SubdivisionControls","setSubdivisionPreview","setSubAssemblyPreview","applySubdivision","createSubAssembly","selectedVoidId","isEditingPreview","setIsEditingPreview","showCreateAssembly","setShowCreateAssembly","createClearance","setCreateClearance","createAxis","setCreateAxis","createFaceOffsets","setCreateFaceOffsets","selectedVoid","twoPanelInfo","isLeafVoid","openParentFaces","previewBounds","startEditing","updatePreviewCount","newCount","cancelPreview","confirmSubdivision","handleAxisHover","handleAxisLeave","startTwoPanelSubdivision","targetVoidId","handleTwoPanelAxisHover","handleTwoPanelAxisLeave","getAxisTooltip","isValid","handleCreateAssembly","handleFaceOffsetChange","handlePurgeVoid","getFaceLabel","getAxisDisplayLabel","getPanelPairDescription","descriptions","EdgePreview","selectedEdge","onEdgeClick","displayW","displayH","viewBoxWidth","viewBoxHeight","getEdgeStatus","getEdgeClass","classes","topY","bottomY","leftX","rightX","handleEdgeClick","EdgeLegend","EdgeControls","edgeNames","faceNames","axisNames","axisLabels","getDividerDimensions","PanelProperties","toggleSubAssemblyFace","setDividerPosition","setDividerPositionMode","enterSketchView","setSelectedEdge","selectedPanelId","selectedPanel","subAssemblyData","isSubAssembly","activeFaces","activeConfig","activeRootVoid","handleEdgeExtensionChange","selectedEdgeStatus","titleSuffix","typeLabel","parentDimStart","parentDimEnd","minPosition","maxPosition","handlePositionChange","AssemblyProperties","setConfig","setSubAssemblyClearance","setAssemblyAxis","setLidTabDirection","setLidInset","setSubAssemblyAxis","setSubAssemblyLidTabDirection","setSubAssemblyLidInset","setFeetConfig","effectiveAssemblyId","FaceButton","onToggle","labels","DimensionForm","Modal","onClose","handleEscape","MaxRectsBin","__publicField","itemWidth","itemHeight","allowRotation","bestScore","bestRect","bestRotated","freeRect","leftover","placedWidth","placedHeight","usedWidth","usedHeight","LABEL_PADDING","packPanelsIntoBeds","bedWidth","bedHeight","gap","showLabels","beds","labelSpace","itemsToPlace","effectiveWidth","effectiveHeight","remainingItems","bin","placedIndices","item","adjustedItems","packPanelsAuto","visiblePanels","items","shelves","maxWidth","placed","shelf","shelfWidth","sum","shelfY","allItems","totalHeight","pathPointsToSVGPath","path","generatePanelPathSVG","kerf","padding","svgWidth","svgHeight","outlinePath","generatePackedBedSVG","bed","bedIndex","totalBeds","panelW","panelH","holePaths","rotatedOutline","rotatedHole","displayWidth","displayHeight","rotatedIndicator","generateAllPanelPathsSVG","bedSeparator","currentY","packed","generateMultipleBedSVGs","downloadSVG","svgContent","filename","blob","link","faceOrder","PRESET_BED_SIZES","ExportModal","setKerf","bedPreset","setBedPreset","customBedWidth","setCustomBedWidth","customBedHeight","setCustomBedHeight","setAllowRotation","setGap","setShowLabels","separateFiles","setSeparateFiles","facePanels","totalPieces","handleExportPanel","getBedDimensions","preset","handleExportAll","bedDims","svgs","STORAGE_KEY","getSavedProjects","stored","saveProject","name","thumbnail","existingId","projects","now","project","loadProject","deleteProject","filtered","renameProject","newName","THUMBNAIL_WIDTH","THUMBNAIL_HEIGHT","THUMBNAIL_ASPECT","captureThumbnail","canvas","tempCanvas","ctx","sourceAspect","sourceX","sourceY","sourceWidth","sourceHeight","ProjectBrowserModal","onLoadProject","setProjects","editingId","setEditingId","editName","setEditName","deleteConfirmId","setDeleteConfirmId","handleDelete","handleStartRename","handleSaveRename","handleCancelRename","handleLoad","formatDate","timestamp","SaveProjectModal","onSave","defaultName","setName","handleSubmit","canSubdivideBetweenPanels","App","isExportModalOpen","setIsExportModalOpen","isProjectBrowserOpen","setIsProjectBrowserOpen","isSaveModalOpen","setIsSaveModalOpen","shareStatus","setShareStatus","saveStatus","setSaveStatus","viewportRef","viewMode","handleShare","textArea","handleSaveProject","handleLoadProject","projectId","currentPanels","handleNewProject","showTwoPanelSubdivision","renderRightSidebar","ReactDOM"],"mappings":"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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsOV,eACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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","x_google_ignoreList":[1,10,11,12]}